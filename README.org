#+TITLE: python（3.5.3）标准库学习笔记

* 内置函数
** *abs* (x)
   返回绝对值，参数可为整数或浮点数，如果为复数，则返回虚部。

** *all* (/iterable/)
   如果所有iterable的元素为true，则返回True。如果iterable为空，也返回
   true。相当于：

   #+BEGIN_SRC python
    def all(iterable):
        for element in iterable:
            if not element:
                return False
        return True
   #+END_SRC

** *any* (iterable)
   如果iterable中任何一个元素为true则返回True，如果为空则返回False。

   #+BEGIN_SRC python
    def any(iterable):
        for element in iterable:
            if element:
                return True
        return false
   #+END_SRC

** *ansii* (object)
   同repr()含义一样，返回object的打印时的字符串。不同的是，会转义非
   ascii码：

   #+BEGIN_EXAMPLE python
    >>> repr("我")
    "'我'"
    >>> ascii("我")
    "'\\u6211'"
   #+END_EXAMPLE

** *bin* (x)
   返回整数x的二进制字符串。如果x不是整数(int)对象，则需为其定义方
   法__index__()：

   #+BEGIN_SRC python
    class Test:
        def __init__(self, num):
            self.num = num

        def __index__(self):
            return self.num

    t = Test(1024)
    print(bin(t)) # 0b10000000000
   #+END_SRC

** class *bool* ([x])
   如果x为false或省略，则返回False，否则返回True。如果x不为布尔型，使用
   [[真假判断]]。

** class *bytearray* ([source[,encoding[,errors]]])
** class *bytes* ([source,[encoding[,errors]]])
** *callable* (object)

   如果object可被调用，则返回True

   #+BEGIN_EXAMPLE
    >>> def foo():
    ...     return
    ...
    >>> callable(foo)
    True
    >>> a = 1
    >>> callable(a)
    False
   #+END_EXAMPLE

** *chr* (i)
   返回Unicode值为i的字符（以字符串表示）。相反的函数为ord(i)。i的取值
   范围为(0-1,114,111)。

   #+BEGIN_EXAMPLE python
    >>> chr(97)
    'a'
    >>> ord('a')
    97
    >>> chr(8364)
    '€'
   #+END_EXAMPLE

** *classmethod*  (function)
** *compile* (source, filename, mode, flag=0, dont_inherit=False, optimize=1)？？？
** class *complex* [real[,img]]

** *delattr* (object,name)
   与setattr()相反。参数分别为对象和字符串。'delattr(x, 'foobar')'相当
   于'del x.foobar'。

** class *dict* (**kwarg)
** class *dict* (mapping, **kwarg)
** class *dict* (iterable, **kwarg)
   创建“字典”。

** *dir* ([object])
   如果无参数，返回当前local scope中的name链表。如果有参数，则返回该对
   象的有效属性链表。

   如果object有__dir__()方法，则返回该方法（必须以链表作为返回值）的返
   回链表值。可使用__getattr__()或__getattribute__()修饰dir()。

  - 如果object是一个module对象，则返回该module的熟悉名链表。
  - 如果object是类实例，则返回其本身的属性名，及递归到的父类属性名。
  - 否则，为该object的熟悉名，加所属类的属性名，加递归到的父类属性名。

  #+BEGIN_EXAMPLE python
    >>> dir()
    ['__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__']
    >>> import struct
    >>> dir()
    ['__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'struct']
    >>> dir(struct)
    ['Struct', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_clearcache', 'calcsize', 'error', 'iter_unpack', 'pack', 'pack_into', 'unpack', 'unpack_from']
    >>> class Shape:
    ...     def __dir__(self):
    ...             return ['1', '2']
    ...
    >>> s = Shape()
    >>> dir(s)
    ['1', '2']
  #+END_EXAMPLE

** *divmode* (a,b)
   接受2个数值（非复数），返回除值和余数组成的tuple。如果都为都为整数结
   果与(a // b, a % b)相同；如果有浮点数，结果为(q, a % b)，其中值通畅
   为math.floor(a / b)，也有可能会小1，任何情况下，q * b + a % b的结果
   都非常难接近a。

** *enumerate* (iterable, start=0)
   返回enumerate对象。参数iterable必须为sequence，或iterator，或其他支
   持迭代的对象。enumerate返回对象的__next__()方法返回tuple，第一个元素
   为索引（从0开始），第二个元素为原来对象的元素。
   #+BEGIN_EXAMPLE python
    >>> seasons = ['spring', 'summer', 'fall', 'winter']
    >>> list(enumerate(seasons))
    [(0, 'spring'), (1, 'summer'), (2, 'fall'), (3, 'winter')]
    >>> list(enumerate(seasons, start=1))
    [(1, 'spring'), (2, 'summer'), (3, 'fall'), (4, 'winter')]
   #+END_EXAMPLE

   相当于：

   #+BEGIN_SRC python
    def enumarate(sequence, start=0):
        n = start
        for elem in sequence:
            yield n, elem
            n += 1
   #+END_SRC

** *eval* (expression,globals=None,locals=None)？？？
** *exec* (object[,globals[,locals]])？？？
** *filter* (function,iterable)
   返回按照function判断后iterable中元素为True的所有元素组成的iterator对
   象。如果function为None，则包含iterable中自身为True的元素（如不含0）。

   如果function不为None，则相当于(item for item in iterable if
   function(item))；如果function为None则相当于(item for item in
   iterable if item)。

** class *float* ([x])
   返回x表示的浮点数，x可为数值或字符串。如果无参数，则返回0.0。

   如果x为字符串，前后可有空格，前面可带正负号，但必须是有效的数值组成
   的字符串。此外，还可使用'nan'和'inf'(或'infinity')表示非数值和无限数，
   且可不区分呢大小写。

   #+BEGIN_EXAMPLE python
    >>> float('+1.23')
    1.23
    >>> float('    -12345\n')
    -12345.0
    >>> float('1e-003')
    0.001
    >>> float('-Infinity')
    -inf
   #+END_EXAMPLE

** *format* (value[,format_spec])
   按照format_spec将value格式转换为字符串。如果format_spec为空字符串，
   则相当于str(value)：

   #+BEGIN_EXAMPLE python
    >>> format('me', '>30')
    '                            me'
    >>> format('me', '<30')
    'me                            '
    >>> format('me', '30')
    'me                            '
    >>> format('me', '')
    'me'
   #+END_EXAMPLE

   调用format(value, format_spec)时，实际上是转换为了
   type(value).__format__(value, format_spec)。即搜索value对应类型
   的__format__()方法。如果递归搜索父类有__format__()方法，且无
   format_spec参数，则使用该方法；如果有使用了format_spec参数，则返回
   TypeError错误。如果format_spec或方法返回值不是字符串，也会返回
   TypeError错误。

** class *frozenset* ([iterable])
** *getattr* (object,name[,default])
   返回对象object属性name对应值。name必须为字符串。如果name是object的属
   性，则返回对应属性值，即getattr(x, 'foobar')相当于x.foobar；如果不存
   在name属性，且有default参数，则返回default参数，否则返回
   AttributeError错误。

** *globals* ()
   返回一个表示当前全局symbol table的dict，总是当前module的全局symbol
   table。

   如果在函数或方法中，module为其定义时的module，而非调用时的module。

** *hasattr* (object, name)
   参数分别为对象和字符串。如果name是object的属性则返回True，否则返回
   False。（实现方法为，调用getattr(object, name)函数，看是否返回
   AttributeError错误。）

** *help* ([object])
   在命令行查看帮助文档。如果不带参数，则进入帮助文档交互模式。如果为字
   符串，则显示对应的module、函数、类、方法、关键字或相关文档。如果参数
   为对象，则显示对应文档，如help(1)显示整型对应的帮助文档。

** *hash* (object)
   返回object的Hash值（如果有）。Hash值通常用在字典（dict）查找是快速比
   较key值。数值相同的数，即使类型不同，也具有相同的返回结果（如1和1.0）。

** *hex* (x)
   将整数转换为小写的16进制字符串。

   #+BEGIN_EXAMPLE python
    >>> hex(255)
    '0xff'
    >>> hex(-42)
    '-0x2a'
   #+END_EXAMPLE

   如需使用16进制字符串表示浮点数，使用float.hex()方法。

** *id* (object)
   返回表示该对象“身份”的整数。此整数在对象的整个生命周期内都独一无二。
   如果两个对象的生命周期没有交集，可能相同。

   *CPython实现中：*  此值为该对象的内存地址。

** *input* ([prompt])
   如果有prompt字符串，则输出到标准输出流（不换行）。此函数读取 *一行*
   输入，将其转换为字符串并去除换行符。如果输入值为EOF，则返回EOFError
   错误。

   #+BEGIN_EXAMPLE python
    >>> s = input('---> ')
    ---> hello world
    >>> s
    'hello world'
   #+END_EXAMPLE

** class *int* (x=0)
** class *int* (x, base=10)
   返回x（可为数字和字符串）表示的数字。如果没有参数，返回0；如果x为数
   字，返回x.__int__()；如果为浮点数，返回值为去除小数点后面的内容。

   如果x不是数字或有base参数，x须为字符串、bytes或bytearray实例。前面可
   有正负号，首位可有空格。base的取值范围内为2-35，默认为10。

** *isinstance* (object,classinfo)
   如果object是，或间接是（递归父类）classinfo的实例则返回True。
   classinfo可为类型名，也可为多个类型名组成的tuple。当为tuple时，
   object直接或间接为其中某个元素的实例即返回True。如果classinfo不为类
   型名或类型名组成的tuple则返回TypeError错误。

** *issubclass* (class, classinfo)
   如果class直接或间接为classinfo的子类，返回True。一个类总是自己的子类。
   classinfo可为单个类名，也可为多个类型名组成的tuple。为tuple时，其中
   的每个类名都会检查。其他任何情况都会返回TypeError错误。

** *iter* (object[,sentinel])
   返回一个iterator对象。第二个参数决定第一个参数的解释方式：

  - 如果无第二个参数：object须为一个支持迭代协议（__iter__()方法）的
    collection对象；或者须支持sequence协议（__getitem__()，整数参数以0
    开始）。如果两种协议都不支持，则返回TypeError错误。

  - 如果有第二个参数sentinel：object须为可调用对象（即函数）。所返回的
    iterator的生成过程为不带参数调用object的__next__()方法。如果返回值
    等于sentinel则返回StopIteration错误，否则返回__next__()方法的返回
    值。

	第二种形式适合于读取文本，直到指定行。如下例直到readline()方法返回
    空字符串：

	#+BEGIN_SRC python
      with open('mydate.txt') as fp:
          for line in iter(fp.readline, ''):
              process_line(line)
	#+END_SRC

** *len* (s)
   返回对象s中的元素个数。s可为sequence（如string、bytes、tuple、list或
   range），也可为collection（如dictionary、set或frozen set）。

** class *list* ([iterable])
   list实际上是一个mutable sequence类型。

** *locals* ()
   在全局作用域内返回值与globals()相同，都是全局作用域内变量组成的dict
   数据。如果在函数内调用，则返回该函数内部作用域内变量组成的dict，但在
   方法中有区别。

** *map* (function, iterable,...)
   对iterable中的元素每个调用function函数，返回map类型，可使用list函数
   转换为list类型。如果有多个iterable参数，则function也需有对应个数的参
   数，结果长度与长度最小的iterable参数相同。

** *max* (iterable, *[,key,default])
** *max* (arg1,arg2,*args[,key])
   返回iterable中，或者是2个或以上参数中最大的一个。

  - 如果只有一个普通参数，则须为iterable类型。可使default关键字参数，
    指定该iterable中无参数时的返回值。如果ietrable参数为空，且无
    default参数，则返回ValueError错误。
  - 如果有多普通参数，不能使用default关键字参数。

  两种情况都能使用key关键字参数（与list.sort()函数的用法相同）。[[http://www.oschina.net/code/snippet_111708_16478][@优雅先
  生]]：

  #+BEGIN_SRC python
  # 最简单的形似：
  max(1,2)
  max('a','b')

  # 也可对list和tuple使用：
  max([1,2])
  max((1,2))

  # 还可指定比较函数
  max('ah', 'bf', key=lambda x: x[1])

  def comparotor(x):
  return x[1]

  max('ah', 'bf', key=comparotor)
  #+END_SRC

** *momeryview* (obj)

** *min* (iterable, *[,key,default])
** *min* (arg1,arg2,*args[,key])
   与max函数用法相同

** *next* (iterator[,default])
   通过调用iterator的__next__()方法返回“下一个”值。如果没有“下一个”，
   且如果无default参数，则返回StopIteration错误，否则返回defualt参数的
   值。

** class *object*
   返回最基础类object的一个实例。此实例具有所有Python实例的方法。此函数
   不接受任何参数。

   *注意* ：基础类object无__dict__方法，所以不能为其实例添加任何属性。

** *oct* (x)
   返回数字x的8进制字符串。如果x不为int对象，则需有__index__()方法，且
   返回一个整数。

** *open* (file,
   mode='r',buffering=-1,encoding=None,errors=None,newline=None,closefd=True,opener=None)
   打开文件file，返回file对象。

   第一个参数file：

   可为指定绝对路径或相对路径的字符串或bytes对象，或者是该文件
   "file descriptor"对应的整数。（如果指定了file descriptor，当其返回
   的I/O对象关闭后，该文件也随之关闭，除非closefd参数值为False。）

   第二个参数mode：

   指定打开文件后的操作，取值可为：

   | 字符 | 含义                                   |
   |------+----------------------------------------|
   | 'r'  | 只读（默认）                           |
   | 'w'  | 写入，打开时就将文件内容清空           |
   | 'x'  | 专用于创建文件，如果文件已存在，则失败 |
   | 'a'  | 写入，向文件末尾追加内容               |
   | 'b'  | 二进制模式                             |
   | 't'  | 文本文件模式（默认）                   |
   | '+'  | 可读可写                               |
   | 'U'  | (deprecated)                           |

   默认模式为'r'（即'rt'），'w+b'为以二进制模式读写，'r+b'为以二进制模
   式读写，但不先清空文件。

   第三个参数buffering：？？？

   指定buffering policy。0为关闭buffering（只能用于二进制模式）;1为选
   择line buffering（只能用于文本模式）,>1表示“ the size in bytes of a
   fixed-size chunk buffer”。如果无此参数，则：？？？

   第四个参数encoding：

   当以文本文件模式打开时，如果不指定此参
   数，encoding值由系统决定，使用local.getpreferredencoding(False)?可
   获取当前值。

   对以二进制模式（'b'）和文本模式（'t'）打开的文件指针，Python会区别
   对待。以二进制模式打开时，返回的bytes内容不经过任何decoding返回；以
   文本模式打开时，则需根据本地系统（或指定的encoding参数）进行解码。

   *注意* ：Python不依靠本地系统对文本文件的描述解码；全依靠Python本身，
   所以platform-independent。

   第五个参数errors：

   指定当encoding和decoding发生错误时的处理方法（不能用于二进制模式）。

   第六个参数newline：

   第七个参数closefd：

   第八个参数opener：

** *ord* (c)
   接受单个Unicode字符组成的字符串，返回对应的Unicode值。比如ord('a')
   返回97。对应的函数为chr()。
** *pow* (x,y[,z])
   返回x的y次方，相当于x**y；如果有第三个参数z，则相当于pow(x, y) % z，
   不过效率更高。
** *print* (*object,sep='',end='\n',file=sys.stdout,flush=False)
   将objects打印到文本流file中，以sep隔开，最后输出end。如果无参数，则
   只打印end。

   所有非关键字参数都先转换为字符串，如str()函数。

   file参数须为有write(string)方法的对象；如果无此方法，或为None，则使
   用sys.stdout对象。由于所有需打印的参数都先转换为字符串，所以不能用
   于二进制模式的文件对象，此情况使用file.write(...)替换。

   输出内容是否被buffer由file参数决定，如果flush参数为true，则强制flush。
** class *property* (fget=None,fset=None,fdel=None,doc=None)
   fget为获取属性值的函数，fset为设置属性值的函数，fdel为删除属性值的
   函数，doc为该属性的文档字符串。

   如下：

   #+BEGIN_SRC python
     class C:
         def __init__(self):
             self._x = None

         def getx(self):
             return self._x

         def setx(self, value):
             self._x = value

         def delx(self):
             del self._x

         x = property(getx, setx, delx, "I'm the 'x' property.")

     c1 = C()
     c2 = C()

     c1.x = 'c1'
     c2.x = 'c2'
     print(c1.x)
     print(c2.x)
   #+END_SRC

   如果c为C的实例，则c.x调用getter函数，c.x=value调用setter函数，del
   c.x调用delete函数。

   如果有doc参数，则为该属性的文档，否则属性文档为fgets的文档字符串
   （如果有）。将property作为”装饰器“（decorator）可方便创建自读属性：

   #+BEGIN_SRC python
     class Parrot:
         def __init__(self):
             self._voltage = 10000

         @property
         def valtage(self):
             '''获取当权voltage值'''
             return self._voltage

     p = Parrot()
     print(p.valtage)
   #+END_SRC

   此例使用@property装饰器将voltage()方法转换为了'getter'函数，来获取
   相同名字的自读属性，且将voltage属性的文档字符串转换为了"获取当权
   voltage值"。

   使用装饰器改写第一个例子的结果为：

   #+BEGIN_SRC python
     class C:
         def __init__(self):
             self._x = None

         @property
         def x(self):
             """I'am the 'x' property."""
             return self._x

         @x.setter
         def x(self, value):
             self._x = value

         @x.deleter
         def x(self):
             del self._x

     c1 = C()
     c2 = C()

     c1.x = 'c1'
     c2.x = 'c2'
     print(c1.x)
     print(c2.x)

     # del c1.x
     # print(c1.x)
   #+END_SRC

** *range* (stop)
** *range* (start,stop,[,step])
   与其说range是一个函数，不如说是一个immutable sequence类型。
** *repr* (object)
   返回打印前用字符串表示的object。

   对大多数对象而言，此函数返回的值与使用eval()函数返回的值相同，否则
   用尖括号表示其类型名及其名称和地址。

   在声明类时，可定义__repr__()方法指定此函数的返回值。

** *reversed* (seq)
   返回一个将seq逆序后的iterator。seq需有__reversed__()方法，或支持
   sequence协议（__len__()方法和__getitem()__整数参数以0开始）。

** *round* (number[,ndigits])
   返回小数点后有ndigits个数的浮点数。如果无ndigits参数或为None，则返
   回最近的整数。

** class *set* ([iterable])
   返回一个新的set对象，可使用iterable中的元素初始化。
** *setattr* (object,name,value)
   与getattr()相反。参数分别为object、字符串和任意值。string可以是
   object已有的属性名，也可是新属性名。setattr(x, 'foobar', '123')相当
   于x.foobar = 123。
** class *slice* (stop)？？？
** class *slice* (start,stop,[,step])
** *sorted* (iterable[,key][,reversed])
   返回排序后的iterable对象。

   key和reversed参数都需使用关键字参数。

   key为排序时对每个元素的操作，比如key=str.lower()。默认值为None。

   reverse参数如果为True，则排序时默认原来元素都已逆序。
** *staticmethod* (function)
   将函数作为静态方法。

   静态方法不接受"self"参数，如：

   #+BEGIN_SRC python
     class C:
         @staticmethod
         def f(arg1,arg2,...)...
   #+END_SRC

   可在实例中调用（C().f()），也可在类上调用（C.f()）。
** class *str* (object='')
** class *str* (object=b'',encoding='utf-8',errors='strict')
   返回object用字符串表示的形式。
** *sum* (iterable[,start])
   将start与iterable中的每个元素从左到右相加，返回总和。iterable中的元
   素通畅为数字，start的值不允许为字符串。

   其他几个函数对特定情况效率更高：

   - ''.join(sequence)：拼接字符串。
   - math.fsum()：求浮点数和，且保留精度。
   - itertools.chain()：拼接多个iterable。

** *super* ([type[,object-or-type]])

   #+BEGIN_SRC python
     class C(B):
         def method(self, arg):
             super().method(arg)     # 相当于super(C, self).method(arg)
   #+END_SRC

** *tuple* ([iterable])
   实际上是tuple类。
** class *type* (object)
** class *type* (name,bases,dict)
   如果只有一个参数object，返回其类型。返回值为type对象，通畅与
   object.__class__属性值相同。

   *注意* ：测试对象类型时，最好使用isinstance()函数，因为其将子类型考
   虑其中。

   如果有3个参数，则返回一个新的type对象。相当于动态的class声明。字
   符串name参数变为__name__属性，tuple类型bases转变为新类型的基础类，
   并变为__bases__属性，dict字典转换为__dict__属性。如下2个语句实际上
   生成的为相同类：

   #+BEGIN_EXAMPLE python
     >>> class X:
     ...     a = 1
     ...
     >>> X = type('X', (object,), dict(a=1))
   #+END_EXAMPLE

** *vars* ([object]) ？？？
** *zip* (*iterables)
   将iterables中的每个元素逐个组成一个由tuple组成的iterator。将最短的
   那个iterable中的元素用完为止。如果只有一个iterable则返回的iterator
   中每个tuple只有1个元素，如果无参数，则返回一个空的iterator。

   #+BEGIN_EXAMPLE python
     >>> l = [1,2,3]
     >>> t = ('a','b','c')
     >>> z = zip(l, t)
     >>> z
     <zip object at 0x7f4868f80c08>
     >>> next(z, None)
     (1, 'a')
     >>> next(z, None)
     (2, 'b')
     >>> next(z, None)
     (3, 'c')
     >>> next(z, None)
     >>>
   #+END_EXAMPLE

** *__import__* (name,globals=None,locals=None,formlist=(),level=0)
   代码中调用import时，相当于调用了此函数。

   *注意* ：如importlib.import_module一样，日常写Python完全不需要。

* 内置常量
** *False*
   bool类型的假值。
** *True*
   bool类型的真值。
** *None*
   NoneType类型唯一的值。常用语表示“无值”，或作为函数的默认参数。
** *NotImplemented* ？？？
** *Ellipsis*
   与"..."相同。常见于在用户自定义数据中表示“切片语法”。
** *__debug__* ？？？

   *注意*: 上面的常量中，除Ellipsis外，都不能重新赋值，或作为属性名，否则返回
   SystaxError错误。

** *site* 模块添加的（常量？？？）函数
   site模块（启动时自动加载，除非在命令行中使用-S参数），添加了下面常
   量：

   - *quit* (code=None)
   - *exit* (code=None)
	 退出时与系统交互返回exit码。
   - *copyright*
   - *licence*
   - *credits*
	 显示相应信息。

* 内置类型
** <<真假判断>>
   除下面情况外都为True：
  - None
  - False
  - 任何形式的数值0，如0、0.0、0j。
  - 空的sequence，如''、()、[]。
  - 空的map，如{}。
  - 自定义类中有__bool__和__len()__方法，且实例的此方法返回0或布尔值
    False。

	操作符（Operations）和内置函数如果返回布尔型，要么返回1或True作为
    “真”，要么返回0或False作为“假”。

	*注意* ：or和and操作符总是将其一个operands作为返回值。

** 布尔值操作-and、or、not
   下表按有限级排序：

   | Operation | 结果                                    | 注意 |
   |-----------+-----------------------------------------+------|
   | x or y    | 如果x为false，则返回y，否则返回x        | (1)  |
   | x an y    | 如果x为false，则返回x，否则返回y        | (2)  |
   | not x     | 如果x为false，则返回True，否则返回False | (3)  |

   注意点：

   1. 只有x为假，才计算y。
   2. 只有x为真，才计算y。
   3. 三者中not的优先级最低，所以not a == b相当于not (a == b)，而a ==
      not b为语法错误。

** 比较
   Python有8个比较操作符，优先级相同，不过都比布尔值操作符高。比较操作
   可任意组合，如x < y <= z等价于x < y and y <= z（与C不同），不过y只
   计算一次，且如果x < y 为加，不计算z，直接返回False。

   | 操作符 | 含义         |
   |--------+--------------|
   | <      | 小于         |
   | <=     | 小于等于     |
   | >      | 大于         |
   | >=     | 大于等于     |
   | ==     | 等于         |
   | !=     | 不等于       |
   | is     | 对象完全相同 |
   | is not | 不为相同对象 |

   除不同类型的数字外，所有不同对象之间的比较都返回False。

   除非声明__eq__()方法，相同类的不同实例不相等。

   相同类的不同实例不能排序，除非有定
   义__lt__()、__le__()、__gt__()和__ge__()方法。（如需只进行比较，定
   义__lt__()和__gt__()方法就足够。）

   is和is not不能定制，可接受任意2个对象，从不返回错误。

   in 和 not in两个操作符具有比较操作符的相同优先级，仅支持sequence类
   型。

** 数字类型-int、float、complex
   一共有3种数字类型：整型、浮点型和复数。此外，布尔型是整型的子类型。
   整型精度无限，浮点型通常与C中的double型精度相同（可使用
   sys.float_info变量查看）。复数分实部和虚部（都为浮点型），如果z为复
   数，则可使用z.real和z.image分别获取实部和虚部。数字后添加j或J可转变
   为虚数。

   Python支持不同的数字类型一起计算。多个类型一起计算时，“窄类型”转换
   为“宽类型”，整型比浮点型窄，浮点型比复数窄。数字之间的比较也使用相
   同方法。

   下表为除复数，所有数字类型都可使用的操作符，按优先级从低到高排序
   （所有数字操作符的优先级都比比较操作符低）。

   | 操作符          | 结果                         | 注意点 | 完整文档  |
   |-----------------+------------------------------+--------+-----------|
   | x + y           | 和                           |        |           |
   | x - y           | 差                           |        |           |
   | x * y           | 积                           |        |           |
   | x / y           | 商                           |        |           |
   | x // y          | x整除y的结果                 | (1)    |           |
   | x % y           | x / y的余值                  | (2)    |           |
   | -x              | 相反数                       |        |           |
   | +x              | 保持不变                     |        |           |
   | abs(x)          | x的绝对值或虚部              |        | abs()     |
   | int(x)          | 将x转换为整型                | (3)(6) | int()     |
   | float(x)        | 将x转换为浮点型              | (4)(6) | float()   |
   | complex(re, im) | 生成复数，img虚数部分默认为0 | (6)    | complex() |
   | c.conjugate()   | 复数c的共轭？                |        |           |
   | divmode(x, y)   | 相当于tuple(x // y, x % y)   | (2)    | divmode() |
   | pow(x, y)       | x的y次方                     | (5)    | pow()     |
   | x ** y          | x的y次方                     | (5)    |           |

   1. 结果无小数，不一定为整型。结果总是向负的最小值靠近：

	  #+BEGIN_EXAMPLE python
        >>> 1 // 2
        0
        >>> (-1) // 2
        -1
        >>> 1 // (-2)
        -1
        >>> (-1) // (-2)
        0
	  #+END_EXAMPLE

   2. 不适用于复数，而是使用abs()函数转换为浮点型。？？？

   3. 将浮点型转换为整数时，同C一样会“舍入”。参考math.floor()和
      math.ceil()函数。

   4. 浮点型可接受字符串“nan”和"inf"作为非数字和无线数，前面可带正负号。

   5. 如其他语言一样，Python规定pow(0,0)和0**0的值都为1。

   6. 可使用0-9和任何Unicode等价的字符。？？

   所有numbers.Real类型（即int和float类型）还可接受如下操作：

   | 操作          | 结果                                                  |
   |---------------+-------------------------------------------------------|
   | math.trunc(x) | 去除小数点后面内容                                    |
   | round(x[,n])  | 小数点后n个数，如果无第二个参数，相当于正真的四舍五入 |
   | math.floor(x) | <=x 的最大整数                                        |
   | math.ceil(x)  | >=x 的最小整数                                        |

*** 整数位运算
	位运算只适用于整数。负数进行位运算时取反补码（以保证足够的bit防止
	计算时溢出）。

	位运算操作符优先级高于比较运算符，低于算术运算符；~运算符与加减运
	算符有相同优先级。

	下表为优先级从低到高的的位运算符：

    | 操作     | 结果 | 注意点 |
    |----------+------+--------|
    | x 竖线 y | 或   |        |
    | x ^ y    | XOR  |        |
    | x & y    | 和   |        |
    | x << n   | 左移 | (1)(2) |
    | x >> n   | 右移 | (1)(3) |
    | ~x       | 取反 |        |

	1. n为负数时返回ValueError错误
	2. 位左移相当于没有溢出检查的乘以pow(2,n)
	3. 位右移相当于没有溢出检查的除以pow(2,n)

*** 整型的额外方法
**** int. *bit_length* ()
	 返回以二进制表示整数的位数：

	 #+BEGIN_EXAMPLE python
       >>> n = -37
       >>> bin(n)
       '-0b100101'
       >>> n.bit_length()
       6
	 #+END_EXAMPLE

	 等价于：

	 #+BEGIN_SRC python
       def bit_length(self):
           s = bin(self)
           s = s.lstrip('-0b')
           return len(s)
	 #+END_SRC

**** int. *to_bytes* (length,byteorder,*,signed=False)？？？
**** clasmethod int *from_bytes* (bytes,byteorder,*,signed=False)？？？
*** 浮点型的额外方法
**** float. *as_integer_ratio* ()
**** float. *is_integer* ()
**** float. *hex* ()
**** classmethod float. *fromhex* (s)
*** numeric类型哈希计算（Hashing）
** Iterator类型
   Python支持在容器（container）外面嵌套一个迭代层。此实现使用了2个不
   同的方法，帮助用户自定义类主持迭代。后面讨论的Sequence总是支持下面
   的迭代方法。

   容器对象需支持container. *__iter__* ()方法提供迭代支持，此方法： 返
   回一个迭代对象。

   迭代对象本身需支持iterator. *__iter__* ()和iterator. *__next__* ()
   方法。

*** Generator类型
	如果容器对象有__iter__()方法，且为generator实现，则自动返回迭代对
	象，且支持__iter__()和__next__()方法。

** Sequence类型-list、tuple、range
   3个基本的Sequence类型为：链表、元组和范围。另外两个专门用于处理二进
   制数据（binary date）和文本字符串（text string）Sequence类型在专门
   章节讨论。
*** 常用的Sequence操作符
	下表的操作对mutable和immutable都有效。其中s和t都是类型相同的
	Sequence，n、i和j都是整数索引，x？

	整个表中的优先级递增。in和not in具有相同的优先级，+和*的优先级同用
	于数字运算一样。

    | 操作符               | 结果                               | 注意点 |
    |----------------------+------------------------------------+--------|
    | x in s               | 如果x与s中某个元素equal，返回True  | (1)    |
    | x not in s           | 如果x与s中某个元素equal，返回False | (1)    |
    | s + t                | 将s和t连接                         | (6)(7) |
    | s * n 或 n * s       | 将s复制n次                         | (2)(7) |
    | s[i]                 | s中的第i个元素，第一个元素为s[0]   | (3)    |
    | s[i:j]               | 截取s中第i到j的元素                | (3)(4) |
    | s[i:j:k]             | 截取s中第i到j的元素，跨度为k       | (3)(5) |
    | len(s)               | s的元素个数                        |        |
    | min(s)               | s中最下的元素                      |        |
    | max(s)               | s中最大的元素                      |        |
    | s.index[x[, i[, j]]] | s中第一个x的索引（索引i后，j前）   | (8)    |
    | s.count(x)           | s中x的个数                         |        |

	同类型的sequence可做比较。比如链表和元组，为逐个比较其中的元素。即
	两个Sequence相等，则需对应位置的元素相等，且类型相同，长度相等。

	注意点：

	1. in和not in通常用来判断是否包含某元素，不过一些特殊的Sequence，
       如str、bytes和bytearray也可同样使用：

	   #+BEGIN_EXAMPLE python
         >>> 'gg' in 'egge'
         True
	   #+END_EXAMPLE

	2. n如果小于0，则作为0对待，返回相同类型的Sequence，但其中无元素。
       注意，复制s本身并不是正真复制，而是多次引用原来的元素：

	   #+BEGIN_EXAMPLE python
         >>> lists = [[]] * 3
         >>> lists
         [[], [], []]
         >>> lists[0].append(3)
         >>> lists
         [[3], [3], [3]]
	   #+END_EXAMPLE

	3. 如果i或j为负数，则相当于les(s)+i和len(s)+j。

	4. 截取s时，如果没有i，则i相当于0；如果没有j，则j相当于len(s)。如
       果i或j大于len(s)，则默认为len(s)；如果i >= j，则结果中没有任何
       元素。

	5. 使用步数k参数：相当于截取元素i、i+k、i+2k...，直到大于或等于
       j（不包含j）。k值不能为0，如果为None则默认为1。

	6. 拼接immutable类型的Sequence时，会生成新对象。意味着复制自身拼接
       时耗时按次方增加，如需使耗时线性等价可：

	   1. 如果是拼接str对象，可先链表再使用str.join()函数合成字符串；
          或者将其写入一个io.StringIO实例，最后再获取。

	   2. 如歌拼接bytes对象，可同字符串一样使用bytes.join()函数或
          io.BytesIO；或者使用bytearray，bytearray对象为mutable类型，
          效率更高。

	   3. 如果拼接元组，可转换为链表再操作。

	   4. 对于其他类型，参考相应文档。

	7. 如range这样的对象，不支持拼接和复制。

	8. 如果s中无元素x，则返回Valueerror错误。如果有i和j参数，则相当于
       s[i:j].index(x)，只是没有数据复制，且返回索引值相对于sequence的
       起始位置，而非截断的起始位置。

*** Immutable Sequence类型
	immutable类型中有，而mutable类型中没有实现的唯一操作是hash()。

	此特性可使immutable类型，如元组，可作为字典(dict)的key值，或另存为
	set或frozenset。

	如果尝试hash含unhashable元素的immutable类型，则返回Typeerror错误。
	如：

	#+BEGIN_EXAMPLE python
      >>> hash((1,2,[2]))
      Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
        TypeError: unhashable type: 'list'
	#+END_EXAMPLE

*** Mutable Sequence类型
	下表为只有mutable类型才有的操作。其中s为mutable类型的实例，t为任何
	可迭代的对象，x?

    | 操作              | 结果                                                 | 注意点 |
    |-------------------+------------------------------------------------------+--------|
    | s[i]=x            | 使用x替换s中索引为i的元素                            |        |
    | s[i:j]=t          | 将s中i->j截断替换为可迭代对象t中的内容               |        |
    | del s[i:j]        | 与s[i:j]=[]同                                        |        |
    | s[i:j:k]=t        | 将截断对应位置上的元素逐个替换为t中的元素            | (1)    |
    | del s[i:j:k]      | 将截断s[i:j:k]从s中删除                              |        |
    | s.append(x)       | 将x添加到s末尾，相当于s[len(s):len(s)]=[x]           |        |
    | s.clear()         | 清除s中所有元素，相当于del s[:]                      | (5)    |
    | s.copy            | 复制s，相当于s[:]                                    | (5)    |
    | s.extend(t)或s+=t | 将t中的元素拼接到s后，基本上等价于s[len(s):len(s)]=t |        |
    | s *= n            | s自身复制n次                                         | (6)    |
    | s.insert(i, x)    | 将s中第i个元素变为x，等价于s[i:i]=x                  |        |
    | s.pop([i])        | 返回s中第i个元素，并将其删除                         | (2)    |
    | s.remove(x)       | 将s中出现的第一个x删除                               | (3)    |
    | s.reverse()       | 将s自身逆序。                                        | (4)    |

	注意点：

	1. t需与截断的长度相等。
	2. 可选参数i默认值为-1，即默认删除最后一个元素。
	3. 如果s中不存在元素x，则返回Valueerror错误。
	4. 为逆序大型sequence时的效率考虑，reverse()方法直接将该sequence逆
       序。为提醒使用者，故意不反悔逆序后的sequence。
	5. clear()和copy()方法是为了兼容不支持截断的mutable序列类型接口，
       如set和dict。
	6. n为整数，或有__index__()方法的对象。当n<=0时，清空。同上，复制
       自身并不是真正复制，而是复制reference：

	   #+BEGIN_EXAMPLE python
         >>> t = [[1],[2]]
         >>> t *= 2
         >>> t
         [[1], [2], [1], [2]]
         >>> t[0].append(1000)
         >>> t
         [[1, 1000], [2], [1, 1000], [2]]
	   #+END_EXAMPLE

*** 链表（List）
	链表为mutable类型的sequence，一般用来存储相同类型的元素。

**** class *list* ([iterable])
	 构建链表有下面方法：

	 - 使用方括号构建空链表。
	 - 使用方括号，指定其中元素4用逗号隔开。如[a]、[a,b,c]。
	 - 或者为[x for x in iterable]的形式。
	 - 或者使用类型构造器：list()或list(iterable)。

	 使用最后一种方法，list构造链表时，新生成的链表中元素顺序同原来的
	 iterable相同。iterable可以是sequence、支持迭代的容器、或者是
	 iterator对象。 如果iterable本身就是链表，则是复制其reference。如
	 果没有参数，则返回空链表：

	 #+BEGIN_EXAMPLE python
       >>> a = [[1],[2]]
       >>> b = list(a)
       >>> b
       [[1], [2]]
       >>> b[0].append(100)
       >>> b
       [[1, 100], [2]]
       >>> a
       [[1, 100], [2]]
	 #+END_EXAMPLE

	 有许多其他操作符可生成链表，如sorted()。

	 除上面第一节Sequence和第二节mutable类型支持的操作符外，链表还支持sort方法：
***** *sort* (*, key=None,reverse=None)
	  元素见比较时，仅能使用“<”比较。如果比较过程中出现语义错误，如“1
	  < 'a'”，则整个排序过程终止（可能将原链表部分排序）。

	  key和reverse参数仅能以关键字参数的形式出现。

	  key参数为接受一个参数的函数，用来指定各元素比较内容，如
	  "key=str.lower"。此函数只在每个元素调用一次。默认值为None，表示
	  不计算每个元素中的key值。

	  如果reverse参数为True，则逆序排序。

	  同reverse函数一样，为保证操作大型sequence时的效率，排序直接改变
	  原来链表，也不返回排序后的链表。（可使用sorted()函数创建一个排序
	  后的新链表实例。）
*** 元组（Tuple）
	元组是immutable类型的Sequence；常用来将类型不同的数据存储在一起，
	如内置函数enumarate()的返回的2元素元组；有时也用于存储immutable类
	型的Sequence，如作为set或dict的元素。？

**** class *tuple* ([iterable])
	 构造元组有下面方法：

	 - 一对小括号表示空元组：()。
	 - 在原始后面加逗号表示一元素元组，可无小括号：a,或(a,)。
	 - 多个元素间用逗号隔开，可无小括号：a,b,c或(a,b,c)。
	 - 使用内置tuple构造器函数：tuple或tuple(iterable)。

	 最后一种方法构造的元组，其元素的顺序与参数iterable中的顺序相同。
	 iterable可为Sequence、支持迭代的容器或iterator对象。如果iterable
	 本来就是元组，则同链表一样，也是复制其reference，如果无参数则生成
	 空元组：

	 #+BEGIN_EXAMPLE python
       >>> t = ([1],[2],[3])
       >>> t
       ([1], [2], [3])
       >>> s = tuple(t)
       >>> s
       ([1], [2], [3])
       >>> t[0].append(1)
       >>> t
       ([1, 1], [2], [3])
       >>> s
       ([1, 1], [2], [3])

       # 元组与链表转换时也只是复制其reference
       >>> t
       ([1], [2], [3])
       >>> t = [[1],[2],[3]]
       >>> s = tuple(t)
       >>> s
       ([1], [2], [3])
       >>> s[0].append(1000)
       >>> s
       ([1, 1000], [2], [3])
       >>> t
       [[1, 1000], [2], [3]]
	 #+END_EXAMPLE

	 *注意* ：实际上是逗号，而非小括号构成的元组。小括号基本可省略，单
	 在造成语义混淆的地方不可少，如f(a,b,c)为函数调用3个参数，二
	 f((a,b,c))则是调用了一个3元素元组参数。

	 元组支持前面第一节中，所有Sequence通用操作符。

	 对于内涵不同类型元素的元组，可使用collections.namedtuple()类型实
	 现通过字符串名称获取索引，比纯数字索引更合适。
*** 范围（Range）
	range类型为immutable的数字Sequence，常与for语句搭配表示循环次数。
**** class *range* (stop)
**** class *range* (start,stop[,step])
	 所有参数都须为整数（内置int类型或有__index__方法的对象）。如果
	 无step参数，默认为1；如果无start参数，默认为0；如果step参数为0，
	 则返回ValueError错误。下面为range的用法举例：

	 #+BEGIN_EXAMPLE python
       >>> list(range(10))
       [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
       >>> list(range(1, 11))
       [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
       >>> list(range(0, 30, 5))
       [0, 5, 10, 15, 20, 25]
       >>> list(range(0, 10, 3))
       [0, 3, 6, 9]
       >>> list(range(0, -10, -1))
       [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
       >>> list(range(0, -10, 1))
       []
       >>> list(range(0))
       []
       >>> list(range(1, 0))
       []
	 #+END_EXAMPLE

	 除拼接和复制外，range支持上面第一小节中所有Sequence支持的操作。原
	 因为range对象只能表示严格模式的Sequence，拼接和复制会损坏此模式。

	 range对象有start、stop和step3属性，分别对应创建时的三个值：

	 #+BEGIN_EXAMPLE python
       >>> r = range(1, 20, 5)
       >>> r.start
       1
       >>> r.stop
       20
       >>> r.step
       5
	 #+END_EXAMPLE

	 较之链表和元组，range占用内存更小。无论表示序列个数多少，所占内存
	 固定：只存储start、stop和step3个值，各元素需要时才计算。

	 range实现了collections.abc.Sequence ABC，支持元素包含测试，索引查
	 找，截断和负截断：

	 #+BEGIN_EXAMPLE python
       >>> r = range(0, 20, 2)
       >>> r
       range(0, 20, 2)
       >>> 11 in r
       False
       >>> 10 in r
       True
       >>> r.index(10)
       5
       >>> r[5]
       10
       >>> r[:5]
       range(0, 10, 2)
       >>> r[-1]
       18
	 #+END_EXAMPLE

	 使用==和!=判断range是否相等时，同一般Sequence一样，即两者中元素是
	 否逐个相等。两个相等的range可有不同的start、stop和step值，如
	 range(0) == range(2, 1, 3)。

** 文本Sequence类型-str
   Python中文本数据使用字符串(str/strings)对象存储。字符串对象为
   immutable类型的Sequence，其中元素为"Unicode code point"。字符串对象
   可用下面方式表示：

   - 单引号：'里面可用"双引号"'。
   - 双引号："里面可有'单引号'"。
   - 三引号：'''可以是三个单引号'''，"""也可以是三个双引号"""。

   三引号表示的字符串可跨行书写，且保留换行符。

   在同一个表达式中，如果字符串间只有空格，则字典拼接：("spam"
   "eggs") == "spam eggs"。

   由于Python并没有字符类型，所以使用索引获得字符串的某个元素时，返回
   值为长度为1的字符串。所以，对于非空字符s，有s[0] == s[0:1]。

   由于字符串本身为immutable，为保证效率，可拼接字符串时可使用
   str.join()和io.StringIO方法。

   - class *str* (object='')
   - class *str* (object='', encoding='utf-8',errors='strict')
	 返回object的字符串形式。如果无object参数，返回空字符串；否则，返
     回值由下面规则决定：

	 如果encoding和errors参数都没有，返回值实际上是object.__str__()方
     法的返回值。对于字符串对象，则是返回该字符串本身；如果
     object无__str__()方法，则是返回调用repr(object)函数的返回值。

	 如果encoding和errors中只要出现任意一个，object就须为类bytes对象
     （bytes或bytearray）。此时，str(bytes, encoding, errors)相当于
     bytes.decode(encoding, errors)。

	 将bytes对象传递给str()函数，且不带encoding和errors参数时，返回"非
     正式"字符串：

	 #+BEGIN_EXAMPLE python
       >>> str(b'Zoot')
       "b'Zoot'"
	 #+END_EXAMPLE

*** 字符串方法
	字符串类型支持第一节中所有Sequence常用的操作，此外还支持下面列举的
	操作。

	字符串支持两种格式化方法：str.format()方法，和与C中printf类似的方
	法。
**** str. *capitalize* ()
	 返回复制后的字符串，第一个字母大写，其余字母小写。
**** str. *casefold* ()
	 相当于str.lower()方法。[[http://www.cnblogs.com/zhanmeiliang/p/5988207.html][@爱尔兰时空]]：

	 lower()只对'A-Z'有效，不能处理其他语言中小写的问题，如德语中'ß'的
	 小写为'ss'：

	 #+BEGIN_EXAMPLE python
       >>> s = 'ß'
       >>> s.lower()
       'ß'
       >>> s.casefold()
       'ss'
	 #+END_EXAMPLE
**** str. *center* (width[,fillchar])
	 将字符串扩展为长度width，原字符串至于中间，空白处使用fillchar字符
	 填充（默认为ASCII空格字符），如果width小于或等于len(s)，则返回原
	 来字符串：

	 #+BEGIN_EXAMPLE python
       >>> s = 'claudio'
       >>> s.center(10)
       ' claudio  '
       >>> s.center(10, '|')
       '|claudio||'
       >>> s.center(1)
       'claudio'
	 #+END_EXAMPLE

**** str. *count* (sub[,start[,end]])
	 返回字符串sub出现的次数，可指定在截断[start:end]间计算：

	 #+BEGIN_EXAMPLE python
       >>> s = 'banana'
       >>> s.count('an')
       2
       >>> s.count('an', -3)
       1
       >>> s.count('an', 3)
       1
	 #+END_EXAMPLE
**** str. *encode* (encoding='utf-8',errors='strict')
	 以bytes对象的形式返回字符串编码后的结果。默认编码为utf-8；默认
	 errors值为strict，即当出现编码错误时返回UnicodeError错误，其他可
	 取值为ignore、replace、xmlcharrefreplace和backslashreplace，以及
	 其他通过codecs.register_error()方法寄存的名称。

	 #+BEGIN_EXAMPLE python
       >>> 'claudio'.encode()
       b'claudio'
       >>> '学习'.encode()
       b'\xe5\xad\xa6\xe4\xb9\xa0';
	 #+END_EXAMPLE
**** str. *endswith* (suffix,[,start[,end]])
	 如果字符串以suffix结尾返回True，否则返回False。可指定在截断
	 [start:end]中计算：

	 #+BEGIN_EXAMPLE
       >>> 'banana'.endswith('na')
       True
       >>> 'banana'.endswith('na', 5)
       False
       >>> '香蕉'.endswith('蕉')
       True
	 #+END_EXAMPLE
**** str. *expandtabs* (tabsize=8)
	 返回复制后的字符串，其中tab字符使用一个或多个空格替代，可指定一个
	 tab字符所占列数：

	 #+BEGIN_EXAMPLE python
       >>> '01\t012\t0123\t01234'.expandtabs()
       '01      012     0123    01234'
       >>> '01\t012\t0123\t01234'.expandtabs(4)
       '01  012 0123    01234'
	 #+END_EXAMPLE
**** str. *find* (sub[,start[,end]])
	 返回从左到右起，sub出现在字符串中的索引，可指定在截断[start:end]
	 中计算，如果无sub字符串出现，则返回-1。

	 #+BEGIN_EXAMPLE python
       >>> 'banana'.find('a')
       1
       >>> 'banana'.find('a', 4)
       5
       >>> 'banana'.find('a', 19)
       -1
	 #+END_EXAMPLE

	 为效率考虑，只有需知道sub在字符串中的索引时才使用find()方法，如果
	 只是判断是否出现sub，使用in操作符即可：

	 #+BEGIN_EXAMPLE python
       >>> 'Py' in 'Python'
       True
       >>> 'py' in 'Python'
       False
	 #+END_EXAMPLE

**** str. *format* (*args,**kwargs)
	 对字符串进行格式化。字符串中可含普通字符，也可含需被替换的place
	 holder，用{}表示。{}中可为数字或关键字参数，分别对应format中的
	 args和kwargs：

	 #+BEGIN_EXAMPLE python
       >>> 'The sum of 1 + 2 is {0}'.format(1+2)
       'The sum of 1 + 2 is 3'
       >>> 'The sum of {a} + {b} is {0}'.format(1+2, a=1, b=2)
       'The sum of 1 + 2 is 3'
	 #+END_EXAMPLE

	 如需打印大括号本身，使用双层大括号：

	 #+BEGIN_EXAMPLE python
       >>> 'format 中使用{{}}表示placeholder'.format()
       'format 中使用{}表示placeholder'
	 #+END_EXAMPLE

**** str. *format_map* (mapping)
	 与str.format(***mapping)类型，不过是直接使用mapping，而不是复制到
	 dict中。如果mapping本身就是dict的一个子类，则非常方便。？？？：

	 #+BEGIN_EXAMPLE
       >>> d = {'name': 'Guido'}
       >>> '{name} was born in ?'.format(**d)
       'Guido was born in ?'

       >>> class Default(dict):
       ...     def __missing__(self, key):
       ...             return key
       ...
       >>> '{name} was born in {country}'.format_map(Default(name='Guido'))
       'Guido was born in country'
	 #+END_EXAMPLE

**** str. *index* (sub[,start[,end]])
	 同find()方法类似，不过当不能在字符串中找到sub时返回ValueError错误，
	 而非-1：

	 #+BEGIN_EXAMPLE
       >>> 'banana'.index('a')
       1
       >>> 'banana'.index('aD')
       Traceback (most recent call last):
         File "<stdin>", line 1, in <module>
         ValueError: substring not found
	 #+END_EXAMPLE

**** str. *isalnum* ()
	 如果字符串不为空，且其中所有字符非数字即"字母"，则返回True：

	 #+BEGIN_EXAMPLE
       >>> '111'.isalnum()
       True
       >>> ''.isalnum()
       False
       >>> '11#'.isalnum()
       False
	 #+END_EXAMPLE

	 只要c.isalpha()、c.isdecimal()、c.isdigit()或c.isnumeric()中一个
	 返回True，则c.isalnum()就返回True。

**** str. *isalpha* ()
	 如果字符串中不为空，且所有字符窦唯“字母”则返回True。只要Unicode字
	 符数据库中认为是"字母"都可。

	 *注意* ：不同于Unicode Standard中定义的"Alphabetic"。

	 #+BEGIN_EXAMPLE python
       >>> 'a'.isalpha()
       True
       >>> '一'.isalpha()
       True
	 #+END_EXAMPLE
**** str. *isdecimal* ()
	 字符串不为空，且所有字符都是十进制数字符，即所有能用于表示十进制
	 数的字符。
**** str. *isdigit* ()
	 除isdecimal字符外，还包含“compatibility superscript digits”。？？？
**** str. *isidentifier* ()
	 如果是Python中合法的identifier（变量名、函数名和类名），则返回
	 True：

	 #+BEGIN_EXAMPLE python
       >>> 'is_identifer'.isidentifier()
       True
       >>> 'is-identifer'.isidentifier()
       False
       >>> 'is2identifer'.isidentifier()
       True
       >>> '_is_identifer'.isidentifier()
       True
       >>> '_is_identifer#'.isidentifier()
       False
	 #+END_EXAMPLE

	 如需判断是否是“保留字”，使用keuword.iskeyword()方法：

	 #+BEGIN_EXAMPLE python
       >>> import keyword
       >>> keyword.iskeyword('def')
       True
       >>> keyword.iskeyword('class')
       True
       >>> keyword.iskeyword('name')
       False
       >>> keyword.iskeyword('__init__')
       False
	 #+END_EXAMPLE
**** str. *islower* ()
	 含至少一个有大小写区分的字符，且所有有大小写区别的字符都为小写：

	 #+BEGIN_EXAMPLE
       >>> 'abc'.islower()
       True
       >>> ''.islower()
       False
       >>> 'ab三'.islower()
       True
       >>> 'ab3'.islower()
       True
       >>> '一'.islower()
       False
	 #+END_EXAMPLE

**** str. *isnumeric* ()？？？
	 字符串不为空，且所有字符都为数字字符：

	 #+BEGIN_EXAMPLE python
       >>> '012'.isnumeric()
       True
       >>> '0X12'.isnumeric()
       False
       >>> '0x12'.isnumeric()
       False
	 #+END_EXAMPLE

	 *？* ：和isdigit的区别。

**** str. *isprintable* ()
	 只含所有可见字符+空格字符，以及空字符串返回True：

	 #+BEGIN_EXAMPLE python
       >>> ' '.isprintable()
       True
       >>> '\n '.isprintable()
       False
       >>> ''.isprintable()
       True
	 #+END_EXAMPLE
**** str. *isspace* ()
	 所有空白字符。
	 #+BEGIN_EXAMPLE python
       >>> ''.isspace()
       False
       >>> ' '.isspace()
       True
       >>> '\n\t'.isspace()
       True
	 #+END_EXAMPLE
**** str. *istitle* ()
	 含至少一个字符，为标题形式的字符串返回True。

	 #+BEGIN_EXAMPLE
       >>> 'I Have A Dream'.istitle()
       True
       >>> 'I Have a Dream'.istitle()
       False
       >>> 'I HAVE A Dream'.istitle()
       False
       >>> 'I HavE A Dream'.istitle()
       False
       >>> '我是标题'.istitle()
       False
       >>> 'The Way to Go'.istitle()
       False
	 #+END_EXAMPLE
**** str. *isupper* ()
	 含至少一个有大小写区分的字符，且所有区分大小写的字符都为大写。
**** str. *join* (iterable)
	 使用字符串将iterable中的所有元素拼接，如果任何一个元素不为字符串
	 （含bytes类型），则返回Valueerror错误。

	 #+BEGIN_EXAMPLE python
       >>> '|'.join(['a','b','c'])
       'a|b|c'

       >>> '|'.join(['a','b',3])
       Traceback (most recent call last):
         File "<stdin>", line 1, in <module>
         TypeError: sequence item 2: expected str instance, int found
       >>> '|'.join(['a','b',b'c'])
       Traceback (most recent call last):
         File "<stdin>", line 1, in <module>
         TypeError: sequence item 2: expected str instance, bytes found

       >>> '|'.join([])
       ''
	 #+END_EXAMPLE
**** str. *ljust* (width[,fillchar])
	 返回指定宽带为width，左对齐后的字符串，使用fillchar填充空白字符。
	 如果width<=len(s)则返回原来字符串。

	 #+BEGIN_EXAMPLE python
       >>> 'claudio'.ljust(10)
       'claudio   '
       >>> 'claudio'.ljust(10, '|')
       'claudio|||'
       >>> 'claudio'.ljust(1, '|')
       'claudio'
	 #+END_EXAMPLE
**** str. *lower* ()
	 返回复制后的字符串，并将所有有大小写区别的字符转换为小写。
**** str. *lstrip* ([chars])
	 返回复制后的字符串，将左边的含chars中字符的所有字符删除，如果参数
	 为None，则char默认为' '。

	 *注意* ：chars不是前缀，而是单个字符的组合：

	 #+BEGIN_EXAMPLE python
       >>> '   i have a dream    '.lstrip()
       'i have a dream    '
       >>> 'www.bing.com'.lstrip('w.com')
       'bing.com'
	 #+END_EXAMPLE
**** static str. *maketrans* (x[,y[,z]])
	 此方法为静态方法。作用是返回一个用于str.translate()方法翻译字符串
	 的字典类型。

	 如果只有一个参数，则须为字典型，key值可为单个字符字符串或Unocide
	 值，value值可为单个字符字符串、Unicode值，任意长度字符串或None。

	 如果是两个参数，则须为长度相等的字符串，对应位置的字符分别成为生
	 成字典的key值和value值。

	 如果是三个参数，最后一个参数需为字符串，其中的字符为会成为生成字
	 典的key值，对应的value值则为None，即使用str.translate()方法时将删
	 除的字符：

	 #+BEGIN_EXAMPLE python
       >>> str.maketrans({'a': '98'})
       {97: '98'}
       >>> str.maketrans({'a': 98})
       {97: 98}
       >>> str.maketrans({'a': None})
       {97: None}
       >>> str.maketrans({97: 'qw' })
       {97: 'qw'}

       >>> str.maketrans('aeiou', '123')
       Traceback (most recent call last):
         File "<stdin>", line 1, in <module>
         ValueError: the first two maketrans arguments must have equal length
       >>> str.maketrans('aeiou', '12345')
       {97: 49, 111: 52, 117: 53, 101: 50, 105: 51}
       >>> str.maketrans('aeiou', '12345', 'XZ')
       {97: 49, 117: 53, 88: None, 105: 51, 90: None, 101: 50, 111: 52}

	 #+END_EXAMPLE
**** str. *partition* (sep)
	 将字符串在第一次出现sep时分割，返回一个3元素元组，其中第一个元素
	 为sep前面的字符串，第二个元素为sep本身，第三个元素为后面的字符串。
	 如果字符串中不含sep，则第一个元素为字符串本身，后面两个元素为空字
	 符串：

	 #+BEGIN_EXAMPLE python
       >>> s = 'banana'
       >>> s.partition('a')
       ('b', 'a', 'nana')
       >>> s.partition('an')
       ('b', 'an', 'ana')
       >>> s.partition('X')
       ('banana', '', '')
       >>> s.partition('')
       Traceback (most recent call last):
         File "<stdin>", line 1, in <module>
         ValueError: empty separator
	 #+END_EXAMPLE
**** str. *replace* (old,new[,count])
	 将字符串中所有的old都替换为new。如果有count参数，则只替换左起
	 count个：

	 #+BEGIN_EXAMPLE python
       >>> s = 'banana'
       >>> s.replace('an', 'AN')
       'bANANa'
       >>> s.replace('an', 'AN', 1)
       'bANana'
       >>> s.replace('an', 'AN', 100)
       'bANANa'
       >>> s.replace('an', 'AN', 0)
       'banana'
       >>> s.replace('an', 'AN', -1)
       'bANANa'
       >>> s.replace('an', 'AN', -2)
       'bANANa'
	 #+END_EXAMPLE
**** str. *rfind* (sub[,start[,end]])
	 返回从右其字符串中第一次出现sub的索引，可指定在截断[start:end]中
	 计算。如果无sub字符串出现，则返回-1：

	 #+BEGIN_EXAMPLE python
       >>> s = 'banana'
       >>> s.rfind('a')
       5
       >>> s.rfind('A')
       -1
       >>> s.rfind('a', -4, -2)
       3
	 #+END_EXAMPLE
**** str. *rindex* (sub[,start[,end]])
	 同rfind，不过如果无sub字符串出现返回ValueError错误：

	 #+BEGIN_EXAMPLE python
       >>> s = 'banana'
       >>> s.rindex('a')
       5
       >>> s.rindex('A')
       Traceback (most recent call last):
         File "<stdin>", line 1, in <module>
         ValueError: substring not found
	 #+END_EXAMPLE

**** str. *rjust* (width[,fillchar])
	 返回右对齐后的字符串，使用fillchar填充空白字符，默认为空格字符。
	 如果width小于或等于len(s)，则返回字符串本身：

	 #+BEGIN_EXAMPLE python
       >>> 'claudio'.rjust(10)
       '   claudio'
       >>> 'claudio'.rjust(10, '|')
       '|||claudio'
       >>> 'claudio'.rjust(1, '|')
       'claudio'
	 #+END_EXAMPLE
**** str. *rpartition* (sep)
	 同str.partition，不过是从右起分割；且如果sep不出现在字符串中，返
	 回的3元素元组前两个元素为空字符串，最后一个为字符串本身：

	 #+BEGIN_EXAMPLE python
       >>> s = 'banana'
       >>> s.rpartition('a')
       ('banan', 'a', '')
       >>> s.rpartition('n')
       ('bana', 'n', 'a')
       >>> s.rpartition('X')
       ('', '', 'banana')
	 #+END_EXAMPLE
**** str. *rsplit* (sep=None,maxsplit=-1)
	 与split函数相同，只是从右边分割。

	 *？* ：既然有split函数，此函数还有啥子卵用？

**** str. *rstrip* ([chars])
	 返回字符串的副本，末尾中的字符只要出现在chars则被移除。如果无
	 chars参数，或为None，则默认移除末尾的空白字符。

	 *注意* ：chars不是后缀，而是所有需移除字符的集合。

	 #+BEGIN_EXAMPLE
       >>> 'www.bing.com'.rstrip('w.com')
       'www.bing'
	 #+END_EXAMPLE

**** str. *split* (sep=None,maxsplit=-1)
	 返回字符串中所有“单词”组成的链表，使用sep作为单词间的分隔符。如果
	 指定maxsplit参数，则进行maxsplit次分割（即结果最多可有maxsplit+1
	 个元素）；如果未指定maxsplit参数，或其值为-1，则最大限度分割。

	 #+BEGIN_EXAMPLE
       >>> s = 'banana'
       >>> s.split('a')
       ['b', 'n', 'n', '']
       >>> s.split('a', 1)
       ['b', 'nana']
	 #+END_EXAMPLE

	 如果有sep参数，连续的分割字符串间会生成空白字符：

	 #+BEGIN_EXAMPLE python
       >>> '1,,2'.split(',')
       ['1', '', '2']
	 #+END_EXAMPLE

	 分割字符串可为多个字符：

	 #+BEGIN_EXAMPLE python
       >>> '1<>2<>3'.split('<>')
       ['1', '2', '3']
	 #+END_EXAMPLE

	 如果指定sep参数，且字符串为空，则生成的链表只含一个空字符串；如果
	 不指定sep参数，且原字符串为空，或只含空白字符，则返回控链表：

	 #+BEGIN_EXAMPLE python
       >>> ''.split()
       []
       >>> ''.split(',')
       ['']

       >>> '   '.split()
       []
	 #+END_EXAMPLE

	 如果无sep参数，或为None，则使用不同的算法：使用空白字符作为分割字
	 符，且删除相邻的空字符，即使首位有空格，返回的链表中也不会含空字
	 符串：

	 #+BEGIN_EXAMPLE python
       >>> '1 2 3'.split()
       ['1', '2', '3']
       >>> '1 2 3'.split(maxsplit=1)
       ['1', '2 3']
       >>> '1     2  3'.split()
       ['1', '2', '3']
	 #+END_EXAMPLE

**** str. *splitlines* ([keepends])
	 在字符串中换行符处分割，返回链表。下表中的字符都会被当做换行符：

     | 字符     | 含义 |
     |----------+------|
     | \n       |      |
     | \r       |      |
     | \r\n     |      |
     | \v或\x0b |      |
     | \f或\x0c |      |
     | \x1c     |      |
     | \x1d     |      |
     | \x1e     |      |
     | \x85     |      |
     | \u2028   |      |
     | \u2029   |      |

	 #+BEGIN_EXAMPLE python
       >>> 'ab c\n\rde fd\rkl\r\n'.splitlines()
       ['ab c', '', 'de fd', 'kl']
	 #+END_EXAMPLE

	 结果中如需包含各种换行符，可指定keppends：

	 #+BEGIN_EXAMPLE python
       >>> 'ab c\n\rde fd\rkl\r\n'.splitlines(keepends=True)
       ['ab c\n', '\r', 'de fd\r', 'kl\r\n']
       >>> 'ab c\n\rde fd\rkl\r\n'.splitlines(keepends='\n')
       Traceback (most recent call last):
         File "<stdin>", line 1, in <module>
         TypeError: an integer is required (got type str)
	 #+END_EXAMPLE

	 不同于split()函数，如果指定sep参数，且原字符串为空，此函数返回空
	 链表，末尾的换行符后并不生成一个空字符串：

	 #+BEGIN_EXAMPLE python
       >>> ''.splitlines()
       []
       >>> 'One line\n'.splitlines()
       ['One line']
	 #+END_EXAMPLE

	 而split('\n')的对应结果为：

	 #+BEGIN_EXAMPLE
       >>> ''.split('\n')
       ['']
       >>> 'One line\n'.split('\n')
       ['One line', '']
	 #+END_EXAMPLE

**** str. *startswith* (prefix[,start[,end]])
	 如果字符串有前缀prefix，则返回True，可指定在截断[start:end]中计算：

	 #+BEGIN_EXAMPLE python
       >>> 'banana'.startswith('b')
       True
       >>> 'banana'.startswith('a')
       False
       >>> 'banana'.startswith('')
       True
       >>> 'banana'.startswith('n', 2)
       True
	 #+END_EXAMPLE
**** str. *strip* ([chars])
	 返回原字符串副本，移除收尾中在chars中出现的字符。如果无chars参数，
	 或为None，则默认删除首尾的空白字符。

	 *注意* ：chars不是前缀或后缀，而是所有需移除字符的集合。

	 #+BEGIN_EXAMPLE
       >>> 'www.bing.com'.strip('w.com')
       'bing'
	 #+END_EXAMPLE

**** str. *swapcase* ()

	 返回大小写交换后的字符串副本。

	 *注意* ：s.swapcase().swapcase() 可能并不等于s。

	 #+BEGIN_EXAMPLE
       >>> s = 'Banana'
       >>> s.swapcase()
       'bANANA'
       >>> s.swapcase().swapcase()
       'Banana'

       >>> s = '一二三'
       >>> s.swapcase()
       '一二三'
       >>> s.swapcase().swapcase()
       '一二三'

       >>> s = 'ß'
       >>> s.swapcase()
       'SS'
       >>> s.swapcase().swapcase()
       'ss'
	 #+END_EXAMPLE
**** str. *title* ()
	 将原字符串中每个单词首字母大写，其他字母小写作为返回值：

	 #+BEGIN_EXAMPLE python
       >>> 'i have a dream'.title()
       'I Have A Dream'
       >>> 'I Have a Dream'.title()
       'I Have A Dream'
       >>> '我有一个梦想'.title()
       '我有一个梦想'
	 #+END_EXAMPLE

	 *注意* ：此函数只将连续字母看做"单词"，所以可能结果不能如愿：

	 #+BEGIN_EXAMPLE
       >>> "they'are bill's friends from the UK".title()
       "They'Are Bill'S Friends From The Uk"
	 #+END_EXAMPLE

	 可使用正则勉强解决：

	 #+BEGIN_SRC python
       #!/usr/bin/python3.5
       import re

       def titlecase(s):
           return re.sub(r"[A-Za-z]+('[A-Za-z]+)?",
                         lambda mo: mo.group(0)[0].upper() + mo.group(0)[1:].lower(),
                         s)

       print(titlecase("they're bill's friends from UK"))
       # They're Bill's Friends From Uk
	 #+END_SRC

**** str. *translate* (table)
	 将字符串中的字符逐个与参数table中的元素对应，如果相同，则转换，返
	 回转换后的结果。可使用静态方法str.maketrans(in, out)创建字典：

	 [[http://www.runoob.com/python/att-string-translate.html][@runoob]]：

	 #+BEGIN_EXAMPLE python
       >>> str = 'a a'
       >>> intab = 'aeiou'
       >>> outtab = '12345'
       >>> tantab = str.maketrans(intab, outtab) #创建翻译字典
       >>> tantab
       {97: 49, 111: 52, 117: 53, 101: 50, 105: 51}
       >>> str = 'this is a string example...wow!!!'
       >>> str.translate(tantab)       #翻译
       'th3s 3s 1 str3ng 2x1mpl2...w4w!!!'
	 #+END_EXAMPLE

	 table参数须为通过__getitem__()方法实现索引的对象，即mapping或
	 sequence对象。当字典key值为整数时，可翻译为：单个字符、Unicode值；
	 如果为None则删除原来字符。

	 #+BEGIN_EXAMPLE python
       >>> str = 'a a'
       >>> str.translate({97:'A'})
       'A A'
       >>> str.translate({97:'ABC'})
       'ABC ABC'
       >>> str.translate({97: None})
       ' '
       >>> str.translate({97: 'A'})
       'A A'
       >>> str.translate({97: 1234})
       'Ӓ Ӓ'
	 #+END_EXAMPLE

**** str. *upper* ()
	 返回字符串副本，将有大小写区别的字符转换为大写。

	 *注意* ：如果str中只含无大小写区分字符，str.upper().isupper()可能
	 返回False：

	 #+BEGIN_EXAMPLE python
       >>> '测试'.isupper()
       False
       >>> 'abc测试'.upper().isupper()
       True
       >>> '测试'.upper().isupper()
       False
	 #+END_EXAMPLE

**** str. *zfill* (width)
	 返回字符串副本，使用ASCII'0'填充扩张到width长度后的左边的空白。如果有正
	 负号，则先添加。如果width小于或等于len(s)则返回字符串本身：

	 #+BEGIN_EXAMPLE python
       >>> '42'.zfill(5)
       '00042'
       >>> '-42'.zfill(5)
       '-0042'
       >>> '-qwdqw'.zfill(5)
       '-qwdqw'
	 #+END_EXAMPLE

*** printf风格的格式化输出
	*注意* ：最好使用str.format()接口格式化字符串。

** 二进制Sequence类型-bytes、bytearray、menoryview

*** Bytes

** Set类型-set、frozenset

** Mapping类型-dict

** Context Manager 类型

** 其他内置类型

** 特殊属性
* 文本处理函数
* 二进制数据函数
* 数据类型
* 数字和数学计算模块
* 函数式编程模块
* 文件和文件夹操作
* 数据保持
* 数据压缩和打包
* 文件格式
* 加密函数
* 基本系统操作
* 并发执行
* 进程通话和网络
* 网络数据处理
* 标记语言处理工具
* 网络协议和支持
* 多媒体服务
* 国际化
