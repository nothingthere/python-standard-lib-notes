# Author: Claudio <3261958605@qq.com>
# Created: 2017-05-03 17:18:04
# Commentary:
#+TITLE: 常用系统服务
本章介绍模块的接口适用于绝大多数操作系统，如文件和时钟。接口主要基于
Unix或C，但可用于大多数系统。

* os - 各种操作系统接口
  
  #+BEGIN_QUOTE
  *注意* ：当不能访问文件名或路径，或其他参数类型正确，但不被操作系统
  接受时，此模块中所有函数都抛出OSError错误。
  #+END_QUOTE
  
  - exception os. *error* ： 内置OSError别名。
  - os. *name* ：操作系统类型。目前支持的名称有：posix、nt、ce、java。
    
    #+BEGIN_SRC python :session
      import os
      print(os.name)
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - posix
    - posix.uname_result(sysname='Linux', nodename='kali', release='4.9.0-kali3-amd64', version='#1 SMP Debian 4.9.18-1kali1 (2017-04-04)', machine='x86_64')
    #+END_SRC
    
    另外，还有sys.platform模块，以及os.uname()获取系统详细信息：
    
    #+BEGIN_SRC python :session
      import sys
      import os
      print(sys.platform)
      print(os.uname())
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> linux
    - posix.uname_result(sysname='Linux', nodename='kali', release='4.9.0-kali3-amd64', version='#1 SMP Debian 4.9.18-1kali1 (2017-04-04)', machine='x86_64')
    #+END_SRC
    
** 文件名、命令行参数和环境变量
   在Python中，文件名、命令行参数和环境变量都使用字符串表示。在一些系
   统中，传给操作系统前，会对这些字符串编码和解码。这时，Python文件系
   统编码编码这些字符串：

   #+BEGIN_SRC python :session
     import sys
     print(sys.getfilesystemencoding())
   #+END_SRC

   #+RESULTS:
   #+BEGIN_SRC org
   - utf-8
   #+END_SRC

** 获取进程参数
   下面这些函数和数据表示当前进程和用户信息：
*** os. *ctermid* ()
    返回控制当前进程的终端文件。

    #+BEGIN_SRC python :session
      import os
      print(os.ctermid())
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - /dev/tty
    #+END_SRC

    兼容：Unix。
*** os. *environ*
    返回表示当前系统环境的映射对象，以字符串表示。比如environ['HOME']
    等价于C中的getenv("HOME")。

    #+BEGIN_SRC python :eval never
      import os
      for k, v in sorted(os.environ.items()):
          print(k + ' -> ' + v)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
      ...
      - LANG -> en_HK.UTF-8
      - LOGNAME -> claudio
      ...
      ...
      - _ -> /usr/bin/emacs24
    #+END_SRC

    此映射对象在os模块第一次导入时获取，即Python启动时处理site.py时计
    算。此后如果系统修改变量，不会改变此映射对象，除非直接修改os.environ
    本身。

    在支持putenv()的系统中，修改此映射后会自动调用putenv()函数，实现对
    此映射和系统变量的同时修改。？？？

    在Unix中，键值字符串编码使用
    sys.getfilesystemencoding()和'surrogateeascape'处理错误。如需使用
    其他编码形式，使用environb。

    #+BEGIN_QUOTE
    *注意* ：

    1. 直接使用putenv()不能改变os.environ，所以最好直接修改os.environ
       值。
    2. 在FreeBSD和Mac OS X等平台上，修改environ可能会会造成内存泄露。
       具体可参考系统的putenv()文档。
    #+END_QUOTE

    如果系统没有putenv()，此映射会传递给进程创建函数，使子进程修改系统
    变量。

    如果系统支持unsetenv()，使用pop()或clear()删除映射中键值对后，系统
    会自动调用unsetenv()，删除环境变量。

*** os. *environb*
    与environ相同，只是键值对使用bytes对象表示。environ和environb自动
    同步，即修改其中一个另一个会自动修改。

    只有当os.supports_bytes_environ为True时，才支持environb属性。

    #+BEGIN_SRC python :session
      import os
      print(os.supports_bytes_environ)
      os.environ['LANG'] = 'whatever'
      os.environb[b'LANG']
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - True
    - >>> b'whatever'
    #+END_SRC

*** os. *chdir* (path)
*** os. *fchdir* (fd)
*** os. *getcwd* ()
    这3个函数在下面文件和文件夹章节介绍。
    
*** os. *fsencode* (filename)
    使用系统编码，附带surrogateescape错误处理（Windows为strict），使用
    文件系统编码，编码FILENAME。

    #+BEGIN_SRC python :session
      import os
      import sys
      filename = '文件'
      print(os.fsencode(filename))
      os.fsencode(filename) == filename.encode(sys.getfilesystemencoding())
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> b'\xe6\x96\x87\xe4\xbb\xb6'
    - True
    #+END_SRC

*** os. *fsdecode* (filename)
    使用系统编码，附带surrogateescape错误处理（Windows为strict），使用
    文件系统编码，解码FILENAME。

*** os. *getenv* (key,default=None)
    如果KEY存在，返回对应系统变量；如果不存在，返回DEFAULT值。

    在Unix中，键值字符串使用sys.getfilesystemencoding()解码，并使用
    surrogateescape错误处理函数。如需使用不同编码形式，使用
    os.getenvb()。

    #+BEGIN_SRC python :session
      import os
      os.getenv('TERM')
      os.getenv('non-exists', 'HAHA!')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 'dumb'
    - 'HAHA!'
    #+END_SRC

    兼容：绝大多数Unix，Windows。

*** os. *getenvb* (key,default=None)
    同getenv()，返回值为bytes对象。

    只有os.supports_bytes_environ返回True时才支持。

    兼容：绝大多数Unix。

*** os. *get_exec_path* (env=None)
    返回系统变量$PATH中路径组成的链表。

    如果使用env参数，须为含PATH键的映射。默认为None，即使用os.environ。

    #+BEGIN_SRC python :session
      import os
      os.get_exec_path()
      os.get_exec_path({'PATH': 'w'})
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - ['/home/claudio/tools', '/home/claudio/python', '/home/claudio/bin', '/home/claudio/.local/bin', '/usr/local/bin', '/usr/bin', '/bin', '/usr/local/games', '/usr/games']
    - ['w']
    #+END_SRC

*** os. *getegid* ()
    返回当前进程的“有效”用户组ID。？？？
    
    #+BEGIN_SRC python :session
      import os
      os.getegid()
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - 1000
    #+END_SRC

    兼容：Unix。
*** os. *geteuid* ()
    返回当前进程的用户ID。

    #+BEGIN_SRC python :session
      import os
      os.geteuid()
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 1000
    #+END_SRC

    兼容：Unix。

*** os. *getgid* ()
    返回当前进程的真正用户组ID。

    #+BEGIN_SRC python :session
      import os
      os.getgid()
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - 1000
    #+END_SRC

    兼容：Unix。

*** os. *getgrouplist* (user,group) ？？？
    返回用户USER所属用户组ID组成的链表。如果group不包含在返回值内，将
    其加入；GROUP为USER添加到password中的用户组ID。

    #+BEGIN_SRC python :session
      import os
      os.getgrouplist('claudio', 1000)
      os.getgrouplist('claudio', 0)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - [1000]
    - [0]
    #+END_SRC

    兼容：Unix。
*** os. *getgroups* ()
    返回当前进程所属用户组ID组成的链表。
    
    #+BEGIN_SRC python :session
      import os
      os.getgroups()
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - [1000]
    #+END_SRC

    兼容：Unix。

*** os. *getlogin* ()
    返回控制当前进程命令行的登录用户名。大多数情况下，使用下面几种方式
    更有效：
    
    - environ['LOGNAME']
    - environ['USERNAME']
    - pwd.getpwuid(os.getuid()).pw_name
      
    #+BEGIN_SRC python :session
      import os
      import sys
      import pwd
      os.getlogin()
      os.environ['LOGNAME']
      os.environ['USERNAME']
      pwd.getpwuid(os.getuid()).pw_name
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> 'claudio'
    - 'claudio'
    - 'claudio'
    - 'claudio'
    #+END_SRC

    兼容：Unix，Windows。
*** os. *getpgid* (pid) ？？？
    返回进程为ID值为PID的进程用户组ID。如果pid为0，返回当前进程的用户
    组ID。

    #+BEGIN_SRC python :session
      import os
      os.getpgid(0)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 2465
    #+END_SRC

    兼容：Unix。

*** os. *getpgrp* ()
    返回当前经常用户组ID。

    #+BEGIN_SRC python :session
      import os
      os.getpgrp()
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 2465
    #+END_SRC

    兼容：Unix。
*** os. *getpid* ()
    返回当前进程ID。

    #+BEGIN_SRC python :session
      import os
      os.getpid()
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 2465
    #+END_SRC

*** os. *getppid* ()
    返回父进程ID。
    
    当父进程退出，在Unix中返回值为初始化进程ID（1），在Windows中，不会
    有变化，但该父进程ID可能已经他用。
    
    #+BEGIN_SRC sh :session
      ps aux | grep emacs24
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - claudio   1692  1.1  2.1 361824 82160 pts/0    Sl+  08:46   2:29 emacs24 -nw
    - claudio   8352  0.0  0.0  12720   968 ?        S    12:32   0:00 grep emacs24
    #+END_SRC
    
    #+BEGIN_SRC python :session
      import os
      os.getppid()
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - 1692
    #+END_SRC
    
*** os. *getpriority* () （待续）
*** os. *PRIO_PROCESS* （待续）
*** os. *PRIO_PGRP* （待续）
*** os. *PRIO_USER* （待续）
*** os. *getresuid* ()
    返回元组（ruid, euid, suid），即当前进程用户（真实ID,有效ID,以保存
    ID）。

    #+BEGIN_SRC python :session
      import os
      os.getresuid()
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - (1000, 1000, 1000)
    #+END_SRC

    兼容：Unix。

*** os. *getresgid* ()
    返回元组（ruid, euid, suid），即当前进程用户组（真实ID,有效ID,以保
    存ID）。

    #+BEGIN_SRC python :session
      import os
      os.getresgid()
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - (1000, 1000, 1000)
    #+END_SRC

*** os. *getuid* ()
    返回当前进程真实用户ID。

    #+BEGIN_SRC python :session
      import os
      os.getuid()
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 1000
    #+END_SRC

*** os. *initgroups* (username,gid) ？？？
    调用系统initgroups()函数。

    兼容：Unix。

*** os. *putenv* (key,value)
    将环境变量KEY设置为VALUE。此更改只在os.system()、popen()、fork()、
    execv()开始执行时影响子进程。

    #+BEGIN_QUOTE
    *注意* ：在FreeBSD和Mac OS X等平台上，修改environ映射属性可能造成
    内存泄露。参考系统putenv()函数。
    #+END_QUOTE

    如果支持putenv()，修改os.environ直接翻译为调用putenv()；但是，调用
    putenv()不会更新os.environ，所以建议直接修改os.environ。

*** os. *setegid* (egid)
    设置当前进程的有效用户组ID。

    兼容：Unix。

*** os. *seteuid* (euid)
    设置当前进程的有效用户ID。

    兼容：Unix。
*** os. *setgid* (gid)
    设置当前进程的用户组ID。

    兼容：Unix。

*** os. *setgroups* (groups) ？？？
*** os. *setpgrp* ()
*** os. *setpgid* (pid,pgrp)
*** os. *setpriority* (which,who,priority)
*** os. *setregid* (rgid,egid)
*** os. *setresid* (rgid,egid,sgid)
*** os. *setresuid* (ruid,euid,suid)
*** os. *setreuid* (ruid,euid)
*** os. *getsid* (pid)
*** os. *setsid* ()
*** os. *setuid* (uid)
*** os. *strerror* (code)
*** os. *supports_bytes_environ*
*** os. *umask* (mask)
    设置当前当前umask值为MASK，并返回原来umask值。
*** os. *uname* ()
    返回当前操作系统信息组成的namedtuple。返回值有下面5个属性：
    
    - sysname： 操作系统名称。
    - nodename：主机在网络中的名称。
    - release：操作系统发行信息。
    - version：操作系统版本。
    - machine：硬件信息。

    #+BEGIN_SRC python :session
      import os
      print(os.uname().release)
      for x in os.uname():
          print(x)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 4.9.0-kali3-amd64
    - ... ... Linux
    - kali
    - 4.9.0-kali3-amd64
    - #1 SMP Debian 4.9.18-1kali1 (2017-04-04)
    - x86_64
    #+END_SRC

    一些系统会将nodename属性删减为8个字符；获取nodename更可靠的方式为
    socket.gethostname()或socket.gethostbyaddr(socket.gethostname())：
    
    #+BEGIN_SRC python :session
      import socket
      socket.gethostname()
      socket.gethostbyaddr(socket.gethostname())
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 'kali'
    - ('kali', [], ['127.0.1.1'])
    #+END_SRC
    
    兼容：最近版本的Unix。

*** os. *unsetenv* (key)
** 创建文件对象
*** os. *fdopen* (fd,*args,**kwargs)
    返回FD文件描述符对应的文件对象。与内置函数open()使用相同参数，唯一
    不同为第一个参数为文件描述符（整数）。

    #+BEGIN_SRC python :session
      import os
      fd = os.open('files/emma.txt', os.O_RDONLY)
      print('当前文件描述符为：', fd)
      fo = os.fdopen(fd)
      fo.read()
      fo.close()
      # print(fd)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> 当前文件描述器为： 3
    - >>> '10'
    #+END_SRC

** 文件描述器操作
   下面的函数使用文件描述符操作I/O流。
   
   文件描述符为小整数，与当前进程打开文件数相关。比如，标注输入流描述
   符为0，标准输出流为1，标准错误流为2。以后，每打开一个文件，此数字递
   增，并对应当前打开文件。在Unix中，sockets和pip都会有对应文件描述符。
   
   io.fileno()可获取文件对象对应的文件描述符：
   
   #+BEGIN_SRC python :session
     import sys
     sys.stdin.fileno()
     sys.stdout.fileno()
     sys.stderr.fileno()
     with open('files/emma.txt') as f:
         print(f.fileno())
   #+END_SRC
   
   #+RESULTS:
   #+BEGIN_SRC org
   - 0
   - 1
   - 2
   - ... ... 3
   #+END_SRC
   
*** 普通函数
**** os. *close* (fd)
     关闭文件描述符FD。

     #+BEGIN_QUOTE
     *注意* ：此函数专用于底层I/O调用，只能关闭os.open()或os.pipe()打
     开的文件描述符。如需关闭open()、popen()或fdopen()打开的文件对象，
     则需使用该文件对象的close()方法。
     #+END_QUOTE

     #+BEGIN_SRC python :session
       import os
       fd = os.open('files/emma.txt', os.O_RDONLY)
       os.read(fd, 1)
       os.close(fd)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> b'1'
     #+END_SRC

**** os. *closerange* (fd_low,fd_high)
     关闭文件描述符从FD_LOW（包含）到FD_HIGH（不包含）的所有文件描述符，
     忽视抛出错误。基本上等价于（但快于）：

     #+BEGIN_EXAMPLE python
       for fd in range(fd_low, fd_high):
           try:
               os.close(fd)
           except OSError:
               pass
     #+END_EXAMPLE
     
**** os. *device_encoding* (fd)
     如果FD为终端的文件描述符，返回其编码形式；否则返回None。
     #+BEGIN_SRC python :session
       import os
       import sys
       fd = os.open('files/emma.txt', os.O_RDONLY)
       print(os.device_encoding(fd))
       print(os.device_encoding(sys.stdin.fileno()))
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> None
     - UTF-8
     #+END_SRC

**** os. *dup* (fd)
     返回FD的副本，不会被子进程继承。

     在Windows中，（0:stdin、1:stdout、2:stderr）会被子进程继承。

     #+BEGIN_SRC python :session
       import os
       fd = os.open('files/emma.txt', os.O_RDONLY)
       fd1 = os.dup(fd)
       print(fd, fd1)
       os.read(fd, 1)
       os.read(fd1, 1)
       os.closerange(fd, fd1 + 1)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> 27 28
     - b'1'
     - b'0'
     #+END_SRC

**** os. *dup2* (fd, fd2, inheritable=True)
     将FD复制成FD2，如果必要关闭FD。可设置INHERITABLE参数指定FD2是否可
     被子进程继承。
     
     #+BEGIN_SRC python :session
       import os

       print('files/a.txt中的内容：')
       with open('files/a.txt') as f:
           print(repr(f.read()))

       print('files/b.txt中的内容：')
       with open('files/b.txt') as f:
           print(repr(f.read()))

       fda = os.open('files/a.txt', os.O_RDONLY)
       fdb = os.open('files/b.txt', os.O_RDONLY)

       os.read(fda, 2)
       print('将fdb指向fda后，fdb就相当于fda：')
       print(fda, fdb)
       os.dup2(fda, fdb)
       os.read(fda, 2)

       os.close(fda)
       os.close(fdb)
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> files/a.txt中的内容：
     - ... ... '1\n2\n3\n'
     - files/b.txt中的内容：
     - ... ... 'a\nb\nc\n'
     - >>> >>> >>> b'1\n'
     - 将fdb指向fda后，fdb就相当于fda：
     - 27 28
     - >>> b'2\n'
     #+END_SRC
     
**** os. *fchmod* (fd,mode)
     
**** os. *fchown* (fd,uid,gid)
**** os. *fdatasync* (fd)
**** os. *fpathconf* (fd,name)
**** os. *fstat* (fd)
**** os. *fstatvfs* (fd)
**** os. *fsync* (fd)
**** os. *ftruncate* (fd,length)
**** os. *get_blocking* (fd)
**** os. *isatty* (fd)
**** os. *lockf* (fd,cmd,len)
**** os. *F_LOCK*
**** os. *F_TLOCK*
**** os. *F_ULOCK*
**** os. *F_TEST*
**** os. *lseek* (fd,pos,how)
**** os. *SEEK_SET*
**** os. *SEEK_CUR*
**** os. *SEEK_END*
**** os. *open(path,flags,mode=0o777,*,dir_fd=None)
**** os. *O_RDONLY*
**** os. *O_WRONLY*
**** os. *O_RDWR*
**** os. *O_APPEND*
**** os. *O_CREATE*
**** os. *O_EXCL*
**** os. *O_TRUNC*
**** os. *O_DSYNC*
**** os. *O_RSYNC*
**** os. *O_SYNC*
**** os. *O_NDELAY*
**** os. *O_NONBLOCK*
**** os. *O_NOCTTY*
**** os. *O_CLOEXEC*
**** os. *O_BINARY*
**** os. *O_NOINHERIT*
**** os. *O_SHORT_LIVED*
**** os. *O_TEMPORARY*
**** os. *O_RANDOM*
**** os. *O_SEQUENTIAL*
**** os. *O_TEXT*
**** os. *O_ASYNC*
**** os. *O_DIRECT*
**** os. *O_DIRECTORY*
**** os. *O_NOFOLLOW*
**** os. *O_NOATIME*
**** os. *O_PATH*
**** os. *O_TMPFILE*
**** os. *O_SHLOCK*
**** os. *O_EXLOCK*
**** os. *openpty* ()
**** os. *pipe* ()
**** os. *pipe2* (flags)
**** os. *posix_fallocate* (fd,offset,len)
**** os. *posix_fadvise* (fd,offset,len,advice)
**** os. *POSIX_FADV_NORMAL*
**** os. *POSIX_FADV_SEQUENTIAL*
**** os. *POSIX_FADV_RANDOM*
**** os. *POSIX_FADV_NOREUSE*
**** os. *POSIX_FADV_WILLNEED*
**** os. *POSIX_FADV_DONTNEED*
**** os. *pread* (fd,buffersize,offset)
**** os. *pwrite* (fd,str,offset)
**** os. *read* (fd,n)
**** os. *sendfile* (out,in,offset,count)
**** os. *sendfile* (out,in,count,[headers,][trailers,]flags=0)
**** os. *set_blocking* (fd,blocking)
**** os. *SF_NODISKIO*
**** os. *SF_MNOWAIT*
**** os. *SF_SYNC*
**** os. *readv* (fd,buffers)
**** os. *tcgetpgrp* (fd)
**** os. *tcsetpgrp* (fd,pg)
**** os. *ttyname* (fd)
**** os. *write* (fd,str)
**** os. *writev* (fd,buffers)

*** 获取命令行大小
*** 文件描述器继承
** 文件和文件夹
*** os. *access* (path,mode,*,dir_fd=None,effective_ids=False,follow_symlinks=True)
*** os. *F_OK*
*** os. *R_OK*
*** os. *W_OK*
*** os. *X_OK*
*** os. *chdir* (path)
*** os. *chflags* (path,flags,*,follow_symlinks=True)
*** os. *chmod* (path,mode,*,dir_fd=None,follow_symlinks=True)
    
*** os. *chown* (path,uid,gid,*,dir_fd=None,follow_symlinks=True)
*** os. *chroot* (path)
*** os. *fchdir* (fd)
*** os. *getcwd* ()
*** os. *getcwdb* ()
*** os. *lchflags* ()
*** os. *lchmod* (path,mode)
*** os. *lchown* (path,uid,gid)
*** os. *link* (src,dst,*,src_dir_fd=None,dst_dir_fd=None,follow_symlinks=True)
*** os. *lstdir* (path='.')
*** os. *lstat* (path,*,dir_fd=None)
*** os. *mkdir* (path,mode=0o777,*,dir_fd=None)
*** os. *makedirs* (name,mode=0o777,exist_ok=False)
*** os. *mkfifo* (path,mode=0o666,*,dir_fd=None)
*** os. *mknod* (path,mode=0o600,device=0,*,dir_fd=None)
*** os. *major* (device)
*** os. *minor* (device)
*** os. *makedev* (major,minor)
*** os. *pathconf* (path,name)
*** os. *pathconf_names*
*** os. *readlink* (path,*,dir_fd=None)
*** os. *remove* (path,*,dir_fd=None)
*** os. *removedirs* (name)
*** os. *rename* (src,dst,*,src_dir_fd=None,dst_dir_fd=None)
*** os. *renames* (old,new)
*** os. *replace* (src,dst,*,src_dir_fd=None,dst_dir_fd=None)
*** os. *rmdir* (path,*,dir_fd=None)
*** os. *scandir* (path='.')
*** class os. *DirEntry*
**** name
**** path
**** inode()
**** is_dir(*,follow_symlinks=True)
**** is_file(*,follow_symlinks=True)
**** is_symlink()
**** stat(*,follow_symlinks=True)
*** os. *stat* (path,*,dir_fd=None,follow_symlinks=True)
*** class os. *stat_result*
**** st_mode
**** st_ino
**** st_dev
**** st_nlink
**** st_uid
**** st_gid
**** st_size
**** st_atime
**** st_mtime
**** st_ctime
**** st_atime_ns
**** st_mtime_ns
**** st_ctime_ns
**** st_blocks
**** st_blksize
**** st_rdev
**** st_flags
**** st_birthtime
**** st_creator
**** st_type
**** st_file_attibutes
*** os. *stat_float_times* ([newvalue])
*** os. *statvsf* (path)
*** os. *supports_dir_fd*
*** os. *supports_effective_ids*
*** os. *supports_fd*
*** os. *supports_follow_symlinks*
*** os. *symlinks* (src,dst,target_is_directory=False,*,dir_fd=None)
*** os. *sync* ()
*** os. *truncate* (path,length)
*** os. *unlink* (path,*,dir_fd=None)
*** os. *utime* (path,times=None,*,[ns,]dir_fd=None,follow_symlinks=True)
*** os. *walk* (top,topdown=True,onerror=None,follow_symlinks=False)
*** os. *fwalk* (top='.',topdown=True,onerror=None,*,follow_symlinks=False,dir_fd=None)
*** Linux扩展属性
** 进程管理
** scheduler接口
** 其他系统信息
** 其他函数
* io
* time
* argparse - 解析命令行参数、选择和子命令
  argparse模块提供易用的命令行接口。程序定义所需参数后，argparse可解析
  sys.argv获取。argparse模块还可自动生成帮助和使用信息，且当参数无效时
  显示错误信息。

** 例子
   如接受一系列整数获取最大值或和：

   #+BEGIN_SRC python :eval never
    import argparse

    parser = argparse.ArgumentParser(description='处理整数。')
    parser.add_argument('integers', metavar='N', type=int, nargs='+',
                        help='用于加法的整数')
    parser.add_argument('--sum', dest='accumulate', action='store_const',
                        const=sum, default=max,
                        help='整数相加（默认：找到最大值）')

    args = parser.parse_args()
    print(args.accumulate(args.integers))
   #+END_SRC

   如果将上面代码存储在argparse_demo.py中，则：

   #+BEGIN_EXAMPLE python
    $ python3 argparse_demo.py -h
    usage: argparse_demo.py [-h] [--sum] N [N ...]

    处理整数。

    positional arguments:
      N           用于加法的整数

    optional arguments:
      -h, --help  show this help message and exit
      --sum       整数相加（默认：找到最大值）
   #+END_EXAMPLE
   
   获取最大值或和：
   
   #+BEGIN_EXAMPLE python
    $ python3 argparse_demo.py  1 2 3     4
    4
    $ python3 argparse_demo.py  1 2 3 4 --sum
    10
   #+END_EXAMPLE
   
   传入错误参数：
   
   #+BEGIN_EXAMPLE python
    $ python3 argparse_demo.py  a b c
    usage: argparse_demo.py [-h] [--sum] N [N ...]
    argparse_demo.py: error: argument N: invalid int value: 'a'
   #+END_EXAMPLE
   
   通过下面各小节来理解上面程序。
   
*** 创建解析器
    第一步为使用argparse创建ArgumentParser对象：

    #+BEGIN_SRC python :eval never
      import argparse
      parse = argparse.ArgumentParser(description='处理整数')
    #+END_SRC

    ArgumentParser对象保有所有将命令行参数转换为Python数据的信息。

*** 添加参数
    使用add_argument()方法向ArgumentParser添加参数。通常情况下，此方法
    告知ArgumentParser对象如何将命令行参数转换为对象。这些信息在使用
    parse_args()方法时用到。

    #+BEGIN_SRC python :eval never
      parser.add_argument('integers', metavar='N', type=int, nargs='+',
                          help='用于加法的整数')
      parser.add_argument('--sum', dest='accumulate', action='store_const',
                          default=max, help='整数加法（默认：找到最大值）')
    #+END_SRC

    随后，调用parse_args()方法时，会返回一个有integers和accumulate属性
    的对象。integers属性可为1个或多个整数；如果使用了--sum选项，则
    accumulate属性为sum()函数，否则为max()函数。

*** 解析参数
    解析参数使用parse_args()方法。检查命令行参数，将每个参数转换为适当
    的类型并执行行为。大多数情况下，会根据解析的命令行参数转换成的对象
    生成一个Namespace对象。

    #+BEGIN_SRC python :eval never
      args = parse.parse_args()
    #+END_SRC

    在脚本中，parse_args()一般不带参数，ArgumentParser会通过sys.argv自
    动判断命令行参数。

** ArgumentParser对象
*** class argparse. *ArgumentParser* (pron=None,usage=None,description=None,epilog=None,parents=[],formatter_class=argparse.HelpFormatter,prefix_chars='-',fromfile_prefix_chars=None,argument_default=None,conflict_handler='error',add_help=True,allow_abbrev=True)
    创建ArgumentParser对象。所有参数都需使用关键字参数方式传递。各个参
    数的简要描述为：
    
    - prog： 程序名称（默认值：sys.argv[0]）。
    - usage：描述程序用法的字符串（默认值：通过添加到parser的参数自动
      生成）。
    - description：显示在帮助内容前的文本（默认值：None）。
    - epilog：显示在帮助内容后的文本（默认值：None）。
    - parents：由ArgumentParser对象组成的链表，用来包含其中每个元素的
      参数。
    - formatter_class：用来定制帮助内容输出的类。
    - prefix_chars：可选参数前缀字符（默认值：“-”）。
    - fromfile_prefix_chars：一组字符。用于指定读取其他参数的前缀文件。
      （默认值：None）。
    - argument_default：所有参数的全局默认值（默认值：None）。
    - conflict_handler：可选参数冲突时的解决方法（通常没必要）。
    - allow_abbrev：如果选项缩写明确，允许生成缩写选项（默认值：True）。
    - add_help：自动添加-h/--help选项（默认值：True）。
      
**** prog
     ArgumentParser对象默认使用sys.argv[0]作为帮助输出的程序名。比如有
     argparse_demo_prog.py程序:

     #+BEGIN_SRC python :eval never
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo', help='foo help')
       parser.print_help()
     #+END_SRC

     不管在哪个路径下，都使用argparse_demo_prog.py作为程序名：

     在声明ArgumentParser对象时，也可手动声明prog参数来指定：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(prog='argparse_demo_prog')
       parser.print_help()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> usage: argparse_demo_prog [-h]
     - optional arguments:
     -   -h, --help  show this help message and exit
     #+END_SRC

     不管是自动获取自sys.argv[0]，还是prog=参数，在帮助文本中都可使用
     “%(prog)s”获取其名称：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(prog='myprog')
       parser.add_argument('--foo', help='foo of the %(prog)s program')
       parser.print_help()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help='foo of the %(prog)s program', metavar=None)
     - usage: myprog [-h] [--foo FOO]
     - optional arguments:
     -   -h, --help  show this help message and exit
     -   --foo FOO   foo of the myprog program
     #+END_SRC

**** usage
     默认情况下，ArgumentParser会根据包含的参数计算：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(prog='PROG')
       parser.add_argument('--foo', nargs='?', help='foo help')
       parser.add_argument('bar', nargs='+', help='bar help')
       parser.print_help()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs='?', const=None, default=None, type=None, choices=None, help='foo help', metavar=None)
     - _StoreAction(option_strings=[], dest='bar', nargs='+', const=None, default=None, type=None, choices=None, help='bar help', metavar=None)
     - usage: PROG [-h] [--foo [FOO]] bar [bar ...]
     - positional arguments:
     -   bar          bar help
     - optional arguments:
     -   -h, --help   show this help message and exit
     -   --foo [FOO]  foo help
     #+END_SRC
     
     可使用USAGE参数重置：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(prog='PROG', usage='%(prog)s [options]')
       parser.print_help()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> usage: PROG [options]
     - optional arguments:
     -   -h, --help  show this help message and exit
     #+END_SRC
     
**** description
     通常情况下都会使用此参数。用来简要描述程序作用及原理。在帮助信息
     中，输出在命令行选项用法和帮助信息之间：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(description='这是一个没用的程序')
       parser.print_help()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> usage: [-h]
     - 这是一个没用的程序
     - optional arguments:
     -   -h, --help  show this help message and exit
     #+END_SRC
     
     默认情况下，如果过长会自动折叠。参考formatter_class参数定制。
     
**** epilog
     显示在帮助信息最后。

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(
           description='没用的程序',
           epilog='在最后'
       )
       parser.print_help()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - ... ... ... >>> usage: [-h]
     - 没用的程序
     - optional arguments:
     -   -h, --help  show this help message and exit
     - 在最后
     #+END_SRC

     同description参数一样，如果过长会折叠，可使用formatter_class参数
     定制。

**** parents
     允许多个parser可能共享一组参数。避免重复定义这些参数，可将此参数
     值链表中所有ArgumentParser的必选和可选参数添加到当前参数中：

     #+BEGIN_SRC python :session
       import argparse

       parent_parser = argparse.ArgumentParser(add_help=False)
       parent_parser.add_argument('--parent', type=int)

       foo_parser = argparse.ArgumentParser(parents=[parent_parser])
       foo_parser.add_argument('foo')
       foo_parser.parse_args(['--parent', '2', 'XXX'])

       bar_parser = argparse.ArgumentParser(parents=[parent_parser])
       bar_parser.add_argument('--bar')
       bar_parser.parse_args(['--bar', 'YYY'])
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> _StoreAction(option_strings=['--parent'], dest='parent', nargs=None, const=None, default=None, type=<class 'int'>, choices=None, help=None, metavar=None)
     - >>> >>> _StoreAction(option_strings=[], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - Namespace(foo='XXX', parent=2)
     - >>> >>> _StoreAction(option_strings=['--bar'], dest='bar', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - Namespace(bar='YYY', parent=None)
     #+END_SRC

     *注意* ：如需作为parent，则其属性add_help须为False。否则当前的
     ArgumentParser对象会认为有2个-h/--help选项，从而抛出错误。

     *注意* ：作为parent的ArgumentParser需在所有parents参数内容前完全
     实现，在实现子parser后再修改父parser不会反应在子parser中。

**** formatter_class
     ArgumentParser对象的帮助文本可使用下面4个类定制：
     
     - class argparse. *RawDescriptionHelpFormatter*
     - class argparse. *RawTextHelpFormatter*
     - class argparse. *ArgumentDefaultsHelpFormatter*
     - class argparse. *MetavarTypeHelpFormatter*
       
     RawDescriptionHelpFormatter和RawTextHelpFormatter用于描述信息输出
     格式。默认情况下，ArgumentParser对象会自动折叠description和epilog
     文本输出：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(
           prog='PROG',
           description='''this description
           was indent weird
               but that is okay''',
           epilog='''
               likewise for this epilog whose whitespace will
           be cleaned up and whose worlds will be wrapped
           across a couple lines'''
       )
       parser.print_help()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - ... ... ... ... ... ... ... ... ... >>> usage: PROG [-h]
     - this description was indent weird but that is okay
     - optional arguments:
     -   -h, --help  show this help message and exit
     - likewise for this epilog whose whitespace will be cleaned up and whose worlds will be wrapped across a couple lines
     #+END_SRC
     
     将FORMATTER_CLASS参数设置为RawDescriptionHelpFormatter使
     DESCRIPTION和EPILOG参数保持原样输出：
     
     #+BEGIN_SRC python :session
       import argparse
       import textwrap
       parser = argparse.ArgumentParser(
           prog='PROG',
           formatter_class=argparse.RawDescriptionHelpFormatter,
           description=textwrap.dedent('''\
           Please do not mess up this text!
           --------------------------------
               I have indented it
               exactly the way
               I want it
       ''')
       )
       parser.print_help()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> ... ... ... ... ... ... ... ... ... ... >>> usage: PROG [-h]
     - Please do not mess up this text!
     - --------------------------------
     -     I have indented it
     -     exactly the way
     -     I want it
     - optional arguments:
     -   -h, --help  show this help message and exit
     #+END_SRC
     
     而RawTextHelpFormatter则是将所有帮助信息文本（含参数描述）用原因
     输出。
     
     ArgumentDefaultsHelpFormatter则是自动添加参数默认信息值：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(
           prog='PROG',
           formatter_class=argparse.ArgumentDefaultsHelpFormatter
       )
       parser.add_argument('--foo', type=int, default=42, help='FOO!')
       parser.add_argument('bar', nargs='*', default=[1, 2, 3], help='BAR!')
       parser.print_help()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - ... ... ... >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=42, type=<class 'int'>, choices=None, help='FOO!', metavar=None)
     - _StoreAction(option_strings=[], dest='bar', nargs='*', const=None, default=[1, 2, 3], type=None, choices=None, help='BAR!', metavar=None)
     - usage: PROG [-h] [--foo FOO] [bar [bar ...]]
     - positional arguments:
     -   bar         BAR! (default: [1, 2, 3])
     - optional arguments:
     -   -h, --help  show this help message and exit
     -   --foo FOO   FOO! (default: 42)
     #+END_SRC

     MetavarTypeHelpFormatter则是使用add_argument的type参数作为帮助信
     息中的参数值。（而不是通常情况下的dest值）：

     *注意* ：使用此值后，所有add_argument中都需指定type值。

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(
           prog='PROG',
           formatter_class=argparse.MetavarTypeHelpFormatter
       )
       parser.add_argument('--foo', type=int)
       parser.add_argument('bar', type=float)
       parser.print_help()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - ... ... ... >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=<class 'int'>, choices=None, help=None, metavar=None)
     - _StoreAction(option_strings=[], dest='bar', nargs=None, const=None, default=None, type=<class 'float'>, choices=None, help=None, metavar=None)
     - usage: PROG [-h] [--foo int] float
     - positional arguments:
     -   float
     - optional arguments:
     -   -h, --help  show this help message and exit
     -   --foo int
     #+END_SRC

**** prefix_chars
     绝大多数命令行选项使用“-”作为前缀，如“-f/--foo”。如需使其他前缀合
     法，可定制PREFIX_CHARS参数：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(prog='PROG', prefix_chars='-+')
       parser.add_argument('+f')
       parser.add_argument('--bar')
       parser.parse_args('+f X --bar Y'.split())
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> _StoreAction(option_strings=['+f'], dest='f', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - _StoreAction(option_strings=['--bar'], dest='bar', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - Namespace(bar='Y', f='X')
     #+END_SRC

     *注意* ：PREFIX_CHARS中需包含“-”，否则会使“-f/--foo”非法。

**** fromfile_prefix_chars
     如果命令行参数过程，可置于文件中。指定FROMFILE_PREFIX_CHARS一个特
     殊符号，则所有以此特殊符号开始的参数都会作为从文件中获取：

     #+BEGIN_SRC python :session
       import argparse
       with open('files/args.txt', 'w') as fp:
           fp.write('-f\nbar')

       parser = argparse.ArgumentParser(fromfile_prefix_chars='@')
       parser.add_argument('-f')
        parser.parse_args(['-f', 'foo', '@files/args.txt'])
       # 相当于：
       # parser.parse_args(['-f', 'foo', '-f', 'bar'])
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - ... ... 6
     - >>> _StoreAction(option_strings=['-f'], dest='f', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - ... ... Namespace(f='bar')
     #+END_SRC

     *注意* ：文件中，选项和参数需保证每行一个。

**** argument_default
     通常情况下，为参数设置默认值可在add_argument()方法中传递默认值，
     或使用ArgumentParser对象的set_defaults()方法。但也可以通过设置
     ARGUMENT_DEFAULT参数实现为所有命令行参数。如抑制所有没传递的参数：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)
       parser.add_argument('--foo')
       parser.add_argument('bar', nargs='?')
       parser.parse_args('--foo 1 BAR'.split())
       parser.parse_args([])
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default='==SUPPRESS==', type=None, choices=None, help=None, metavar=None)
     - _StoreAction(option_strings=[], dest='bar', nargs='?', const=None, default='==SUPPRESS==', type=None, choices=None, help=None, metavar=None)
     - Namespace(bar='BAR', foo='1')
     - Namespace()
     #+END_SRC

**** allow_abbrev
     默认情况下，parse_args()方法会自动匹配缩写的选项。如需禁用此功能，
     可将ALLOW_ABBREV设置为False。

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foobar', action='store_true')
       parser.add_argument('--foonley', action='store_true')
       parser.parse_args(['--foon'])
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreTrueAction(option_strings=['--foobar'], dest='foobar', nargs=0, const=True, default=False, type=None, choices=None, help=None, metavar=None)
     - _StoreTrueAction(option_strings=['--foonley'], dest='foonley', nargs=0, const=True, default=False, type=None, choices=None, help=None, metavar=None)
     - Namespace(foobar=False, foonley=True)
     #+END_SRC

**** conflict_handler
     默认情况下，不允许选项重复，否则抛出错误：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(prog='PROG')
       parser.add_argument('-f', '--foo', help='old foo help')
       parser.add_argument('--foo', help='new foo help')
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['-f', '--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help='old foo help', metavar=None)
     - Traceback (most recent call last):
     -   File "<stdin>", line 1, in <module>
     -   File "/usr/lib/python3.5/argparse.py", line 1353, in add_argument
     -     return self._add_action(action)
     -   File "/usr/lib/python3.5/argparse.py", line 1716, in _add_action
     -     self._optionals._add_action(action)
     -   File "/usr/lib/python3.5/argparse.py", line 1557, in _add_action
     -     action = super(_ArgumentGroup, self)._add_action(action)
     -   File "/usr/lib/python3.5/argparse.py", line 1367, in _add_action
     -     self._check_conflict(action)
     -   File "/usr/lib/python3.5/argparse.py", line 1506, in _check_conflict
     -     conflict_handler(action, confl_optionals)
     -   File "/usr/lib/python3.5/argparse.py", line 1515, in _handle_conflict_error
     -     raise ArgumentError(action, message % conflict_string)
     - argparse.ArgumentError: argument --foo: conflicting option string: --foo
     #+END_SRC

     如需覆盖久的选项字符串，可将conflict_handler参数设置为'resolve'：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(prog='PROG', conflict_handler='resolve')
       parser.add_argument('-f', '--foo', help='old foo help')
       parser.add_argument('--foo', help='new foo help')
       parser.print_help()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['-f', '--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help='old foo help', metavar=None)
     - _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help='new foo help', metavar=None)
     - usage: PROG [-h] [-f FOO] [--foo FOO]
     - optional arguments:
     -   -h, --help  show this help message and exit
     -   -f FOO      old foo help
     -   --foo FOO   new foo help
     #+END_SRC

     可见，覆盖了第一个选项的“--foo”，使第二个选项的“--foo”生效。

**** add_help
     默认情况下，会自动添加“-h/--help”选项。如需禁用，可设置ADD_HELP参
     数为False：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(add_help=False)
       parser.add_argument('--foo', help='foo help')
       parser.print_help()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help='foo help', metavar=None)
     - usage: [--foo FOO]
     - optional arguments:
     -   --foo FOO  foo help
     #+END_SRC

     如果设置PREFIX_CHAR参数，且其中不含“-”，“-h/--help”默认使用第一个
     字符作为前缀：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(prefix_chars='#+')
       parser.print_help()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> usage: [#h]
     - optional arguments:
     -   #h, ##help  show this help message and exit
     #+END_SRC
     
** add_argument()方法
*** ArgumentParser. *add_argument* (name of flags...[,action][,nargs][,const][,default][,type][,choices][,required][,help][,metavar][,dest])
    定义如歌解析单个命令行参数。各参数简要描述如下：
    
     - name or flags： 一个或多个字符串。如“foo”、“--foo”或“-f”
     - action：当命令行中出现此参数时的基本操作。
     - nargs：指定消耗的命令行参数个数。
     - const：action和nargs指定后，所需的常量。
     - default：如果命令行缺省对应参数的默认值。
     - type：命令行中参数转换成的Python类型。
     - choices：指定命令行中只能出现的参数。
     - required：命令行中此选项是否必须（只对可选选项有效）。
     - help：对此选项的简要描述。
     - metavar：在“Usage”信息中此选项的名字。
     - dest：parse_args()返回值对应的属性。
       
     下面为详细介绍：
     
**** name或flags
     一个或单个字符串，以“-”前缀开始时表示命令行可选参数，无前缀表示命
     令行必选参数。

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('-f', '--foo')
       parser.add_argument('bar')
       parser.parse_args(['BAR'])
       parser.parse_args('BAR --foo FOO'.split())
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> _StoreAction(option_strings=['-f', '--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - _StoreAction(option_strings=[], dest='bar', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - Namespace(bar='BAR', foo=None)
     - Namespace(bar='BAR', foo='FOO')
     #+END_SRC

**** action
     指定对命令行参数的操作。可对命令行参数进行任意操作，但将其作为
     parse_args()方法的返回值属性为最常用操作。ACTION对应的字符串指定
     操作类型：
     
     - store：存储参数值，为默认操作：
       
       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser()
         parser.add_argument('--foo')
         parser.parse_args('--foo 1'.split())
       #+END_SRC
       
       #+RESULTS:
       #+BEGIN_SRC org
       - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - Namespace(foo='1')
       #+END_SRC
       
     - store_const：存储CONST参数指定的值。常用于可选参数：
       
       #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo', action='store_const', const=42)
       parser.parse_args(['--foo'])
       #+END_SRC
       
       #+RESULTS:
       #+BEGIN_SRC org
       - >>> _StoreConstAction(option_strings=['--foo'], dest='foo', nargs=0, const=42, default=None, type=None, choices=None, help=None, metavar=None)
       - Namespace(foo=42)
       #+END_SRC
       
     - store_true和store_false：是store_const的特殊形式，分别存储True
       和False。
       
       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser()
         parser.add_argument('--foo', action='store_true')
         parser.add_argument('--bar', action='store_false')
         parser.add_argument('--baz', action='store_false')
         parser.parse_args('--foo --bar'.split())
       #+END_SRC
       
       #+RESULTS:
       #+BEGIN_SRC org
       - >>> >>> _StoreTrueAction(option_strings=['--foo'], dest='foo', nargs=0, const=True, default=False, type=None, choices=None, help=None, metavar=None)
       - _StoreFalseAction(option_strings=['--bar'], dest='bar', nargs=0, const=False, default=True, type=None, choices=None, help=None, metavar=None)
       - _StoreFalseAction(option_strings=['--baz'], dest='baz', nargs=0, const=False, default=True, type=None, choices=None, help=None, metavar=None)
       - Namespace(bar=False, baz=True, foo=True)
       #+END_SRC
       
       *注意* ：如果缺省对应命令行选项，对应值为相反值，即True得到
       False，反之亦然。
       
     - append：命令行中多次使用选项时，将参数集中到一个链表中：
       
       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser()
         parser.add_argument('--foo', action='append')
         parser.parse_args('--foo 1 --foo 2 --foo 3'.split())
       #+END_SRC
       
       #+RESULTS:
       #+BEGIN_SRC org
       - >>> _AppendAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - Namespace(foo=['1', '2', '3'])
       #+END_SRC
       
     - append_const：将CONST参数指定值集中到一个链表中。常用于将多个命
       令行选项的参数集中到一个链表中：
       
       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser()
         parser.add_argument('--str', dest='types', action='append_const', const=str)
         parser.add_argument('--int', dest='types', action='append_const', const=int)
         parser.parse_args('--int --str'.split())
         parser.parse_args(['--int'])
       #+END_SRC
       
       #+RESULTS:
       #+BEGIN_SRC org
       - >>> _AppendConstAction(option_strings=['--str'], dest='types', nargs=0, const=<class 'str'>, default=None, type=None, choices=None, help=None, metavar=None)
       - _AppendConstAction(option_strings=['--int'], dest='types', nargs=0, const=<class 'int'>, default=None, type=None, choices=None, help=None, metavar=None)
       - Namespace(types=[<class 'int'>, <class 'str'>])
       - Namespace(types=[<class 'int'>])
       #+END_SRC
       
     - count：计数命令行中选项出现的次数：
       
       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser()
         parser.add_argument('--verbose', '-v', action='count')
         parser.parse_args(['-vvvv', '-v'])
       #+END_SRC
       
       #+RESULTS:
       #+BEGIN_SRC org
       - >>> _CountAction(option_strings=['--verbose', '-v'], dest='verbose', nargs=0, const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - Namespace(verbose=5)
       #+END_SRC
       
     - help：？？？
       
     - version：打印版本信息：
       
       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser(prog='PROG')
         parser.add_argument('--version', action='version', version='%(prog)s 2.0')
         parser.parse_args(['--version'])
       #+END_SRC

     如需定制action，可将此参数值设置为Action的子类或有相同接口的对象。
     建议方法是重置Action的__call__和__init__方法：
     
     #+BEGIN_SRC python :session
       import argparse

       class FooAction(argparse.Action):
           def __init__(self, option_strings, dest, nargs=None, **kwargs):
               if nargs is not None:
                   raise ValueError('nargs not allowed')
               super(FooAction, self).__init__(option_strings, dest, **kwargs)
           def __call__(self, parser, namespace, values, option_string=None):
               print('{} {} {}'.format(namespace, values, option_string))
               setattr(namespace, self.dest, values)

       parser = argparse.ArgumentParser()
       parser.add_argument('--foo', action=FooAction)
       parser.add_argument('bar', action=FooAction)
       args = parser.parse_args('1 --foo 2'.split())
       print(args)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> ... ... ... ... ... ... ... ... >>> >>> >>> FooAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - FooAction(option_strings=[], dest='bar', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - Namespace(bar=None, foo=None) 1 None
     - Namespace(bar='1', foo=None) 2 --foo
     - Namespace(bar='1', foo='2')
     #+END_SRC

**** nargs
     默认情况下，一个命令行选项只消耗一个命令行参数，使用NARGS参数可指
     定单个选项消耗的参数个数。可选值为：
     
     - N（整数）。将N和参数集中到一起：
       
       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser()
         parser.add_argument('--foo', nargs=2)
         parser.add_argument('bar', nargs=1)
         parser.parse_args('--foo a b c'.split())
       #+END_SRC
       
       #+RESULTS:
       #+BEGIN_SRC org
       - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=2, const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - _StoreAction(option_strings=[], dest='bar', nargs=1, const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - Namespace(bar=['c'], foo=['a', 'b'])
       #+END_SRC
       
       *注意* ：nargs=1时是生成单个参数组成的链表，区别与默认时将选项
       直接作为指。
       
     - ?：可消耗一个命令行参数，或不消耗命令行选项，生成单个选项值（不
       为链表）。如果没消耗命令行选项，使用DEFAULT参数值。如果为可选选
       项，且没消耗命令行参数，则使用CONST参数值：
       
       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser()
         parser.add_argument('--foo', nargs='?', const='c', default='d')
         parser.add_argument('bar', nargs='?', default='d')
         parser.parse_args('XX --foo YY'.split())
         parser.parse_args('XX --foo'.split())
         parser.parse_args([])
       #+END_SRC
       
       #+RESULTS:
       #+BEGIN_SRC org
       - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs='?', const='c', default='d', type=None, choices=None, help=None, metavar=None)
       - _StoreAction(option_strings=[], dest='bar', nargs='?', const=None, default='d', type=None, choices=None, help=None, metavar=None)
       - Namespace(bar='XX', foo='YY')
       - Namespace(bar='XX', foo='c')
       - Namespace(bar='d', foo='d')
       #+END_SRC
       
     “nargs='?'”的常用方法为允许必选命令行选项中的文件参数缺省：
     
     #+BEGIN_SRC python :session
       import argparse
       import sys
       parser = argparse.ArgumentParser()
       parser.add_argument('infile', nargs='?',
                           type=argparse.FileType('r'), default=sys.stdin)
       parser.add_argument('outfile', nargs='?',
                           type=argparse.FileType('w'), default=sys.stdout)
       parser.parse_args(['files/input.txt', 'files/output.txt'])
       parser.parse_args([])
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> ... _StoreAction(option_strings=[], dest='infile', nargs='?', const=None, default=<_io.TextIOWrapper name='<stdin>' mode='r' encoding='UTF-8'>, type=FileType('r'), choices=None, help=None, metavar=None)
     - ... _StoreAction(option_strings=[], dest='outfile', nargs='?', const=None, default=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>, type=FileType('w'), choices=None, help=None, metavar=None)
     - Namespace(infile=<_io.TextIOWrapper name='files/input.txt' mode='r' encoding='UTF-8'>, outfile=<_io.TextIOWrapper name='files/output.txt' mode='w' encoding='UTF-8'>)
     - Namespace(infile=<_io.TextIOWrapper name='<stdin>' mode='r' encoding='UTF-8'>, outfile=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)
     #+END_SRC
     
     - *：将所有命令行参数集中到一个链表中：
       
       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser()
         parser.add_argument('--foo', nargs='*')
         parser.add_argument('--bar', nargs='*')
         parser.add_argument('baz', nargs='*')
         parser.parse_args('--foo x y --bar 1 2'.split())
         parser.parse_args('a b --foo x y'.split())
       #+END_SRC
       
       #+RESULTS:
       #+BEGIN_SRC org
       - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs='*', const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - _StoreAction(option_strings=['--bar'], dest='bar', nargs='*', const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - _StoreAction(option_strings=[], dest='baz', nargs='*', const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - Namespace(bar=['1', '2'], baz=[], foo=['x', 'y'])
       - Namespace(bar=None, baz=['a', 'b'], foo=['x', 'y'])
       #+END_SRC
       
     - +：与“*”相同，将所有有效参数集中到链表中。但是至少需一个参数，
       否则抛出错误：
       
       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser()
         parser.add_argument('foo', nargs='+')
         parser.parse_args('a b'.split())
       #+END_SRC

       #+RESULTS:
       #+BEGIN_SRC org
       - >>> _StoreAction(option_strings=[], dest='foo', nargs='+', const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - Namespace(foo=['a', 'b'])
       #+END_SRC

     - argparse.REMAINDER：将剩下的所有命令行参数集中到链表中：

       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser()
         parser.add_argument('--foo')
         parser.add_argument('command')
         parser.add_argument('args', nargs=argparse.REMAINDER)
         parser.parse_args('--foo B cmd --arg1 XX ZZ'.split())
       #+END_SRC

       #+RESULTS:
       #+BEGIN_SRC org
       - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - _StoreAction(option_strings=[], dest='command', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - _StoreAction(option_strings=[], dest='args', nargs='...', const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - Namespace(args=['--arg1', 'XX', 'ZZ'], command='cmd', foo='B')
       #+END_SRC

     如果没提供NARGS参数，则消耗的命令行参数个数由ACTION参数决定。一般
     情况下，单个命令行选项消耗单个命令行参数，并生成非链表的单个属性
     值。
     
**** const
     此参数最常见的两个用法为：

     - 当ACTION的值为"store_const"或"append_const"时，使用CONST参数的
       值作为parse_args()方法返回对象的属性值。
     - 当NARGS的值为"?"时，如果命令行中无参数，则使用CONST参数的值。

     *注意* ：如果ACTION参数值为"store_const"或"append_const"，必须声
     明CONST关键字参数值。其他ACTION值情况下，其默认值为None。

**** default
     命令行中可选选项和一些必选选项可缺省参数。缺省时，使用DEFAULT参数
     值（默认为None）作为parse_args()方法返回对象的属性值。
     
     对于可选选项，如果命令行中没有参数，使用DEFAULT参数的值：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo', default=42)
       parser.parse_args('--foo 2'.split())
       parser.parse_args([])
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=42, type=None, choices=None, help=None, metavar=None)
     - Namespace(foo='2')
     - Namespace(foo=42)
     #+END_SRC
     
     如果DEFAULT参数值类型为字符串，parse_args()方法会将其等同命令行中
     的参数对待，使用TYPE参数指定的类型对其实现类型转换，否则不管：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--length', default='10', type=int)
       parser.add_argument('--width', default=10.5, type=int)
       parser.parse_args([])
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--length'], dest='length', nargs=None, const=None, default='10', type=<class 'int'>, choices=None, help=None, metavar=None)
     - _StoreAction(option_strings=['--width'], dest='width', nargs=None, const=None, default=10.5, type=<class 'int'>, choices=None, help=None, metavar=None)
     - Namespace(length=10, width=10.5)
     #+END_SRC

     对于必须选项，如果NARGS参数值为"?"或"*"，当无命令行参数时，也使用
     DEFAULT参数值作为默认值：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('foo', nargs='?', default=42)
       parser.parse_args(['a'])
       parser.parse_args()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=[], dest='foo', nargs='?', const=None, default=42, type=None, choices=None, help=None, metavar=None)
     - Namespace(foo='a')
     - Namespace(foo=42)
     #+END_SRC

     如果default=argparse.SUPPRESS，则当命令行中无参数时，parse_args()
     方法返回的对象不具备对于属性：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo', default=argparse.SUPPRESS)
       parser.parse_args([])
       parser.parse_args('--foo 1'.split())
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default='==SUPPRESS==', type=None, choices=None, help=None, metavar=None)
     - Namespace()
     - Namespace(foo='1')
     #+END_SRC

**** type
     ArgumentParser只是将命令行中的参数作为字符串，可在add_argument()
     方法中使用type参数指定类型转换。可为内置类型和接受单个字符串参数
     的函数。如果指定了DEFAULT参数，也会根据type参数对其自动转换类型。
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('foo', type=int)
       parser.add_argument('bar', type=open)
       parser.parse_args('2 files/input.txt'.split())
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=[], dest='foo', nargs=None, const=None, default=None, type=<class 'int'>, choices=None, help=None, metavar=None)
     - _StoreAction(option_strings=[], dest='bar', nargs=None, const=None, default=None, type=<built-in function open>, choices=None, help=None, metavar=None)
     - Namespace(bar=<_io.TextIOWrapper name='files/input.txt' mode='r' encoding='UTF-8'>, foo=2)
     #+END_SRC
     
     为简化文件类型的使用，argparse模块还提供了FileType工厂函数，接受
     与open函数相同的mode、bufsize、encoding和errors参数。如将参数转换
     为可写的文件对象：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('bar', type=argparse.FileType('w'))
       parser.parse_args(['files/output.txt'])
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=[], dest='bar', nargs=None, const=None, default=None, type=FileType('w'), choices=None, help=None, metavar=None)
     - Namespace(bar=<_io.TextIOWrapper name='files/output.txt' mode='w' encoding='UTF-8'>)
     #+END_SRC

     也可为接受单个字符串参数的任意函数：

     #+BEGIN_SRC python :session
       import argparse
       import math

       def perfect_square(string):
           value = int(string)
           sqrt = math.sqrt(value)
           if sqrt != int(sqrt):
               msg = '{} is not a perfect square'.format(string)
               raise argparse.ArgumentError(msg)
           return value

       parser = argparse.ArgumentParser()
       parser.add_argument('foo', type=perfect_square)
       parser.parse_args(['9'])
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> ... ... ... ... ... ... ... >>> >>> _StoreAction(option_strings=[], dest='foo', nargs=None, const=None, default=None, type=<function perfect_square at 0x7ff2678e3158>, choices=None, help=None, metavar=None)
     - Namespace(foo=9)
     #+END_SRC

**** choices
     使用CHOICES参数可限定命令行参数为只为其中的元素。当解析命令行参数
     时，如果不在其中则抛出错误：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('move', choices=['rock', 'paper', 'scissors'])
       parser.parse_args(['rock'])
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=[], dest='move', nargs=None, const=None, default=None, type=None, choices=['rock', 'paper', 'scissors'], help=None, metavar=None)
     - Namespace(move='rock')
     #+END_SRC

     *注意* ：包含测试在类型type指定转换后进行，所有CHOICES中的元素类
     型需与type指定的一致：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('door', type=int, choices=range(1, 4))
       parser.parse_args(['3'])
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=[], dest='door', nargs=None, const=None, default=None, type=<class 'int'>, choices=range(1, 4), help=None, metavar=None)
     - Namespace(door=3)
     #+END_SRC

     任何支持“in”操作的对象都可所谓CHOICES参数的值，即dict、set等都可。

**** required
     一般情况下，name或flags为“-f”或“-bar”形式时表示命令行可选选择，可
     缺省。如需将可选选项设置为必须选项，可设置参数REQUIRED为True：

     *注意* ：最好不要将可选选项转换为必选选项。
     
**** help
     用于简要表示描述命令行选项的字符串，用于使用“-h/--help”时打印：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo', action='store_true', help='foo选项用法')
       parser.add_argument('bar', nargs='+', help='bar选项用法')
       parser.print_help()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreTrueAction(option_strings=['--foo'], dest='foo', nargs=0, const=True, default=False, type=None, choices=None, help='foo选项用法', metavar=None)
     - _StoreAction(option_strings=[], dest='bar', nargs='+', const=None, default=None, type=None, choices=None, help='bar选项用法', metavar=None)
     - usage: [-h] [--foo] bar [bar ...]
     - positional arguments:
     -   bar         bar选项用法
     - optional arguments:
     -   -h, --help  show this help message and exit
     -   --foo       foo选项用法
     #+END_SRC
     
     在字符串中，可使用绝大多数add_argument()方法的参数：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(prog='PROG')
       parser.add_argument('bar', nargs='?', type=int, default=24,
                           help='程序%(prog)s的选项bar，类型%(type)s， 默认值为%(default)s')
       parser.print_help()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> ... _StoreAction(option_strings=[], dest='bar', nargs='?', const=None, default=24, type=<class 'int'>, choices=None, help='程序%(prog)s的选项bar，类型%(type)s， 默认值为%(default)s', metavar=None)
     - usage: PROG [-h] [bar]
     - positional arguments:
     -   bar         程序PROG的选项bar，类型int， 默认值为24
     - optional arguments:
     -   -h, --help  show this help message and exit
     #+END_SRC

     如需不在“usage”和“help”信息中显示帮助信息，可使用
     argparse.SUPPRESS：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo', help=argparse.SUPPRESS)
       parser.print_help()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help='==SUPPRESS==', metavar=None)
     - usage: [-h]
     - optional arguments:
     -   -h, --help  show this help message and exit
     #+END_SRC

**** metavar
     默认情况下，在显示帮助信息时，使用DEST参数值作为选项参数提示。如
     果为必选选项，直接使用该值；可选选项则使用大写形式：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo')
       parser.add_argument('bar')
       parser.print_help()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - _StoreAction(option_strings=[], dest='bar', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - usage: [-h] [--foo FOO] bar
     - positional arguments:
     -   bar
     - optional arguments:
     -   -h, --help  show this help message and exit
     -   --foo FOO
     #+END_SRC
     
     使用metavar可修改此打印值：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo', metavar='XXX')
       parser.add_argument('bar', metavar='YYY')
       parser.print_help()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar='XXX')
     - _StoreAction(option_strings=[], dest='bar', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar='YYY')
     - usage: [-h] [--foo XXX] YYY
     - positional arguments:
     -   YYY
     - optional arguments:
     -   -h, --help  show this help message and exit
     -   --foo XXX
     #+END_SRC

     修改METAVAR只是改变了打印值，而非DEST的值。

     对于不同的NARGS值，会多次打印METAVAR值，此时可使用元组设置多个打
     印值：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo', nargs=2)
       parser.add_argument('--bar', nargs=2, metavar=('bar', 'baz'))
       parser.print_help()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=2, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - _StoreAction(option_strings=['--bar'], dest='bar', nargs=2, const=None, default=None, type=None, choices=None, help=None, metavar=('bar', 'baz'))
     - usage: [-h] [--foo FOO FOO] [--bar bar baz]
     - optional arguments:
     -   -h, --help     show this help message and exit
     -   --foo FOO FOO
     -   --bar bar baz
     #+END_SRC
     
**** dest
     定制parse_args()方法返回对象的属性名。默认情况下，对于可选选项，
     如果有“--foo”形式，则使用第一个该形式，“foo”作为默认属性名，如果
     没有，则使用第一个“-f”的“f”作为属性名，其中的任何短横线“-”都自动
     转换为“下划线”，以得到合法的属性名；如果为必选选项“bar”形式，则为
     add_argument()方法的第一个参数：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('-f', '--foo-bar', '--foo')
       parser.add_argument('-x', '-y')
       parser.parse_args('-f 1 -x 2'.split())
       parser.parse_args('--foo 1 -y 2'.split())
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['-f', '--foo-bar', '--foo'], dest='foo_bar', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - _StoreAction(option_strings=['-x', '-y'], dest='x', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - Namespace(foo_bar='1', x='2')
     - Namespace(foo_bar='1', x='2')
     #+END_SRC

     使用DEST参数则是定制此属性名：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo', dest='bar')
       parser.parse_args('--foo 1'.split())
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='bar', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - Namespace(bar='1')
     #+END_SRC

*** Action - 定制add_argument方法的action参数？？？

** parse_args()方法
*** ArgumentParser. *parse_args* (args=None,namespace=None)
    将命令行参数转换为namespace对象属性，返回namespace对象。
    
    由add_argument()方法决定如何转换命令行参数。
    
    默认情况下，通过sys.argv获取命令行参数，创建全新Namespace对象赋值
    属性。
    
*** 可选语法
    对于可选选项，parse_args()方法支持多种命令行参数形式，最简单的方式
    为选项和参数为各自独立：
    
    #+BEGIN_SRC python :session
      import argparse
      parser = argparse.ArgumentParser()
      parser.add_argument('-x')
      parser.add_argument('--foo')
      parser.parse_args('-x X'.split())
      parser.parse_args('--foo FOO'.split())
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> _StoreAction(option_strings=['-x'], dest='x', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
    - _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
    - Namespace(foo=None, x='X')
    - Namespace(foo='FOO', x=None)
    #+END_SRC
    
    如果为全写形式选项，与参数间可用“=”连接：
    
    #+BEGIN_SRC python :session
      parser.parse_args('--foo=FOO'.split())
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - Namespace(foo='FOO', x=None)
    #+END_SRC

    如果为简写形式的选项，可与参数连写：

    #+BEGIN_SRC python :session
      parser.parse_args(['-xX'])
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - Namespace(foo=None, x='X')
    #+END_SRC

    多个简写形式的选项有默认值，则可连写，只有最后一个必须提供参数值：

    #+BEGIN_SRC python :session
      import argparse
      parser = argparse.ArgumentParser()
      parser.add_argument('-x', action='store_true')
      parser.add_argument('-y', action='store_true')
      parser.add_argument('-z')
      parser.parse_args(['-xyzZ'])
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> _StoreTrueAction(option_strings=['-x'], dest='x', nargs=0, const=True, default=False, type=None, choices=None, help=None, metavar=None)
    - _StoreTrueAction(option_strings=['-y'], dest='y', nargs=0, const=True, default=False, type=None, choices=None, help=None, metavar=None)
    - _StoreAction(option_strings=['-z'], dest='z', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
    - Namespace(x=True, y=True, z='Z')
    #+END_SRC

*** 无效参数
    当parse_args()方法解析命令行时，如果遇到选项不明确、参数类型不正确、
    必选选项参数个数不正确等会抛出错误，打印错误及使用方法：

    #+BEGIN_SRC python :eval never
      import argparse
      parser = argparse.ArgumentParser()
      parser.add_argument('--foo', type=int)
      parser.add_argument('bar', nargs='?')

      # 参数类型不正确
      parser.parse_args('--foo spam'.split())
      # 选项错误
      parser.parse_args(['--bar'])
      # 参数个数不正确
      parser.parse_args('spam badger'.split())
    #+END_SRC

*** 参数包含 - 短横线（“-”）？？？
*** 参数缩写（前缀匹配）
    如果缩写明确，parse_args()解析命令行选项时允许缩写。可将
    ArgumentParser的参数allow_abbrev设置成False取消此功能：

    #+BEGIN_SRC python :session
      import argparse
      parser = argparse.ArgumentParser()
      parser.add_argument('--bacon')
      parser.add_argument('--badger')
      parser.parse_args('--bac MMM'.split())
      parser.parse_args('--bad WOOD'.split())

      # 缩写不明确，不能正确解析
      # parser.parse_args('--ba BA'.split())
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> _StoreAction(option_strings=['--bacon'], dest='bacon', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
    - _StoreAction(option_strings=['--badger'], dest='badger', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
    - Namespace(bacon='MMM', badger=None)
    - Namespace(bacon=None, badger='WOOD')
    #+END_SRC

*** sys.argv之外
    普通用法中，一般parse_args()方法都不带参数，直接解析命令行，即
    sys.argv。上面所有例子中为演示方便，都是直接提供链表模仿命令行。此
    方法在测试时很有用：

    #+BEGIN_SRC python :session
      import argparse
      parser = argparse.ArgumentParser()
      parser.add_argument(
          'integers', nargs='+', metavar='int', type=int,
          choices=range(10), help='0-9间的整数'
      )
      parser.add_argument(
          '--sum', dest='accumulate', action='store_const', const=sum,
          default=max, help='将整数相加（默认：找到最大值）'
      )
      parser.parse_args('1 2 3 4'.split())
      parser.parse_args('1 2 3 4 --sum'.split())
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> ... ... ... _StoreAction(option_strings=[], dest='integers', nargs='+', const=None, default=None, type=<class 'int'>, choices=range(0, 10), help='0-9间的整数', metavar='int')
    - ... ... ... _StoreConstAction(option_strings=['--sum'], dest='accumulate', nargs=0, const=<built-in function sum>, default=<built-in function max>, type=None, choices=None, help='将整数相加（默认：找到最大值）', metavar=None)
    - Namespace(accumulate=<built-in function max>, integers=[1, 2, 3, 4])
    - Namespace(accumulate=<built-in function sum>, integers=[1, 2, 3, 4])
    #+END_SRC

*** Namespace对象
**** class argparse. *Namespace*
     parse_args()方法使用的一个简单的类，创建来保存属性并返回。
     
     此类仅是object的一个子类。如需将其转换为字典，可使用内置函数
     vars()：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo')
       args = parser.parse_args('--foo BAR'.split())
       vars(args)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - >>> {'foo': 'BAR'}
     #+END_SRC

     如需将解析结果添加到已有对象上，可使用NAMESPACE参数：

     #+BEGIN_SRC python :session
       import argparse

       class C:
           pass

       c = C()
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo')
       parser.parse_args(args='--foo BAR'.split(), namespace=c)
       vars(c)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> ... ... >>> >>> >>> >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - <__main__.C object at 0x7fdbe6213780>
     - {'foo': 'BAR'}
     #+END_SRC

** 其他用法 （待续）
*** 子命令
*** FileType对象
*** 参数分组
*** 共有排除（Mutual exclusion）
*** Parser defaults
*** Printing help
*** Partial parsing
*** Customizing file parsing
*** Exiting methods
** 更新argparse （待续）
* getopt
  
  #+BEGIN_QUOTE
  *注意* ：此模块的功能也是解析命令行，只是使用了与C的getopt()函数相同
  的API。如果不属性C的getopt()函数，或不想多写代码，可使用argparse模块。
  #+END_QUOTE
  
* logging
* logging.config
* logging.handlers
* getpass
* curses
* curses.textpad
* curses.ascii
* curses.panel
* platform
* errno
* ctypes
