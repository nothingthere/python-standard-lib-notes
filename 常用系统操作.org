# Author: Claudio <3261958605@qq.com>
# Created: 2017-05-03 17:18:04
# Commentary:
#+TITLE: 常用系统服务

本章介绍模块的接口适用于绝大多数操作系统，如文件和时钟。接口主要基于
Unix或C，但可用于大多数系统。

* os - 各种操作系统接口

  #+BEGIN_QUOTE
  *注意* ：当不能访问文件名或路径，或其他参数类型正确，但不被操作系统
  接受时，此模块中所有函数都抛出OSError错误。
  #+END_QUOTE

  - exception os. *error* ： 内置OSError别名。
  - os. *name* ：操作系统类型。目前支持的名称有：posix、nt、ce、java。

    #+BEGIN_SRC python :session
      import os
      print(os.name)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - posix
    #+END_SRC

    另外，还有sys.platform模块，以及os.uname()获取系统详细信息：

    #+BEGIN_SRC python :session
      import sys
      import os
      print(sys.platform)
      print(os.uname())
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> linux
    - posix.uname_result(sysname='Linux', nodename='kali', release='4.9.0-kali3-amd64', version='#1 SMP Debian 4.9.18-1kali1 (2017-04-04)', machine='x86_64')
    #+END_SRC

** 文件名、命令行参数和环境变量
   在Python中，文件名、命令行参数和环境变量都使用字符串表示。在一些系
   统中，传给操作系统前，会对这些字符串编码和解码。这时，Python使用文
   件系统编码编码这些字符串：

   #+BEGIN_SRC python :session
     import sys
     print(sys.getfilesystemencoding())
   #+END_SRC

   #+RESULTS:
   #+BEGIN_SRC org
   - >>> utf-8
   #+END_SRC

** 获取进程参数
   下面这些函数和数据表示当前进程和用户信息：
*** os. *ctermid* ()
    返回控制当前进程的终端文件。

    #+BEGIN_SRC python :session
      import os
      print(os.ctermid())
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - /dev/tty
    #+END_SRC

    兼容：Unix。
*** os. *environ*
    返回表示当前系统环境的映射对象，以字符串表示。比如environ['HOME']
    等价于C中的getenv("HOME")。

    #+BEGIN_SRC python :eval never
      import os
      for k, v in sorted(os.environ.items()):
          print(k + ' -> ' + v)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
      ...
      - LANG -> en_HK.UTF-8
      - LOGNAME -> claudio
      ...
      ...
      - _ -> /usr/bin/emacs24
    #+END_SRC

    此映射对象在os模块第一次导入时获取，即Python启动时处理site.py时计
    算。此后如果系统修改变量，不会改变此映射对象，除非直接修改os.environ
    本身。

    在支持putenv()的系统中，修改此映射后会自动调用putenv()函数，实现对
    此映射和系统变量的同时修改。？？？

    在Unix中，键值字符串编码使用
    sys.getfilesystemencoding()和'surrogateeascape'处理错误。如需使用
    其他编码形式，使用environb。

    #+BEGIN_QUOTE
    *注意* ：
    
    1. 直接使用putenv()不能改变os.environ，所以最好直接修改os.environ
       值。
    2. 在FreeBSD和Mac OS X等平台上，修改environ可能会会造成内存泄露。
       具体可参考系统的putenv()文档。
    #+END_QUOTE

    如果系统没有putenv()，此映射会传递给进程创建函数，使子进程修改系统
    变量。

    如果系统支持unsetenv()，使用pop()或clear()删除映射中键值对后，系统
    会自动调用unsetenv()，删除环境变量。

*** os. *environb*
    与environ相同，只是键值对使用bytes对象表示。environ和environb自动
    同步，即修改其中一个另一个会自动修改。

    只有当os.supports_bytes_environ为True时，才支持environb属性。

    #+BEGIN_SRC python :session
      import os
      print(os.supports_bytes_environ)
      os.environ['LANG'] = 'whatever'
      os.environb[b'LANG']
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - True
    - >>> b'whatever'
    #+END_SRC

*** os. *chdir* (path)
*** os. *fchdir* (fd)
*** os. *getcwd* ()
    这3个函数在下面文件和文件夹章节介绍。

*** os. *fsencode* (filename)
    使用系统编码，附带surrogateescape错误处理（Windows为strict），编码
    FILENAME。
    
    #+BEGIN_SRC python :session
      import os
      import sys
      filename = '文件'
      print(os.fsencode(filename))
      os.fsencode(filename) == filename.encode(sys.getfilesystemencoding())
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> b'\xe6\x96\x87\xe4\xbb\xb6'
    - True
    #+END_SRC
    
*** os. *fsdecode* (filename)
    使用系统编码，附带surrogateescape错误处理（Windows为strict），使用
    文件系统编码，解码FILENAME。

*** os. *getenv* (key,default=None)
    如果KEY存在，返回对应系统变量；如果不存在，返回DEFAULT值。

    在Unix中，键值字符串使用sys.getfilesystemencoding()解码，并使用
    surrogateescape错误处理函数。如需使用不同编码形式，使用
    os.getenvb()。

    #+BEGIN_SRC python :session
      import os
      os.getenv('TERM')
      os.getenv('non-exists', 'HAHA!')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 'dumb'
    - 'HAHA!'
    #+END_SRC

    兼容：绝大多数Unix，Windows。

*** os. *getenvb* (key,default=None)
    同getenv()，返回值为bytes对象。
    
    只有os.supports_bytes_environ返回True时才支持。

    兼容：绝大多数Unix。

*** os. *get_exec_path* (env=None)
    返回系统变量$PATH中路径组成的链表。

    如果使用env参数，须为含PATH键的映射。默认为None，即使用os.environ。

    #+BEGIN_SRC python :session
      import os
      os.get_exec_path()
      os.get_exec_path({'PATH': 'w'})
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - ['/home/claudio/tools', '/home/claudio/python', '/home/claudio/bin', '/home/claudio/.local/bin', '/usr/local/bin', '/usr/bin', '/bin', '/usr/local/games', '/usr/games']
    - ['w']
    #+END_SRC

*** os. *getegid* ()
    返回当前进程的“有效”用户组ID。？？？
    
    #+BEGIN_SRC python :session
      import os
      os.getegid()
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - 1000
    #+END_SRC
    
    兼容：Unix。
    
**** 有效用户/用户组ID和实际用户/用户组ID。 [[http://www.cnblogs.com/kunhu/p/3699883.html][@流云揽月]]
     
     - 实际用户/用户组ID：即登录时的用户/用户组ID。
     - 有效用户/用户组ID：可以简单理解为执行当前程序的用户/用户组ID。
       
*** os. *geteuid* ()
    返回当前进程的用户ID。

    #+BEGIN_SRC python :session
      import os
      os.geteuid()
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 1000
    #+END_SRC

    兼容：Unix。

*** os. *getgid* ()
    返回当前进程的真正用户组ID。

    #+BEGIN_SRC python :session
      import os
      os.getgid()
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 1000
    #+END_SRC

    兼容：Unix。

*** os. *getgrouplist* (user,group) ？？？
    返回用户USER所属用户组ID组成的链表。如果group不包含在返回值内，将
    其加入；GROUP为USER添加到password中的用户组ID。

    #+BEGIN_SRC python :session
      import os
      os.getgrouplist('claudio', 1000)
      os.getgrouplist('claudio', 0)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - [1000]
    - [0]
    #+END_SRC

    兼容：Unix。
*** os. *getgroups* ()
    返回当前进程所属用户组ID组成的链表。
    
    #+BEGIN_SRC python :session
      import os
      os.getgroups()
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - [1000]
    #+END_SRC

    兼容：Unix。

*** os. *getlogin* ()
    返回控制当前进程命令行的登录用户名。大多数情况下，使用下面几种方式
    更有效：
    
    - environ['LOGNAME']
    - environ['USERNAME']
    - pwd.getpwuid(os.getuid()).pw_name
      
    #+BEGIN_SRC python :session
      import os
      import sys
      import pwd
      os.getlogin()
      os.environ['LOGNAME']
      os.environ['USERNAME']
      pwd.getpwuid(os.getuid()).pw_name
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> 'claudio'
    - 'claudio'
    - 'claudio'
    - 'claudio'
    #+END_SRC

    兼容：Unix，Windows。
*** os. *getpgid* (pid) ？？？
    返回进程为ID值为PID的进程用户组ID。如果pid为0，返回当前进程的用户
    组ID。

    #+BEGIN_SRC python :session
      import os
      os.getpgid(0)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 2465
    #+END_SRC

    兼容：Unix。

*** os. *getpgrp* ()
    返回当前经常用户组ID。

    #+BEGIN_SRC python :session
      import os
      os.getpgrp()
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 2465
    #+END_SRC

    兼容：Unix。
*** os. *getpid* ()
    返回当前进程ID。

    #+BEGIN_SRC python :session
      import os
      os.getpid()
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 2465
    #+END_SRC

*** os. *getppid* ()
    返回父进程ID。
    
    当父进程退出，在Unix中返回值为初始化进程ID（1），在Windows中，不会
    有变化，但该父进程ID可能已经他用。
    
    #+BEGIN_SRC sh :session
      ps aux | grep emacs24
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - claudio   1692  1.1  2.1 361824 82160 pts/0    Sl+  08:46   2:29 emacs24 -nw
    - claudio   8352  0.0  0.0  12720   968 ?        S    12:32   0:00 grep emacs24
    #+END_SRC
    
    #+BEGIN_SRC python :session
      import os
      os.getppid()
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - 1692
    #+END_SRC
    
*** os. *getpriority* () （待续）
*** os. *PRIO_PROCESS* （待续）
*** os. *PRIO_PGRP* （待续）
*** os. *PRIO_USER* （待续）
*** os. *getresuid* ()
    返回元组（ruid, euid, suid），即当前进程用户（真实ID,有效ID,以保存
    ID）。

    #+BEGIN_SRC python :session
      import os
      os.getresuid()
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - (1000, 1000, 1000)
    #+END_SRC

    兼容：Unix。

*** os. *getresgid* ()
    返回元组（ruid, euid, suid），即当前进程用户组（真实ID,有效ID,以保
    存ID）。

    #+BEGIN_SRC python :session
      import os
      os.getresgid()
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - (1000, 1000, 1000)
    #+END_SRC

*** os. *getuid* ()
    返回当前进程真实用户ID。

    #+BEGIN_SRC python :session
      import os
      os.getuid()
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 1000
    #+END_SRC

*** os. *initgroups* (username,gid) ？？？
    调用系统initgroups()函数。

    兼容：Unix。

*** os. *putenv* (key,value)
    将环境变量KEY设置为VALUE。此更改只在os.system()、popen()、fork()、
    execv()开始执行时影响子进程。

    #+BEGIN_QUOTE
    *注意* ：在FreeBSD和Mac OS X等平台上，修改environ映射属性可能造成
    内存泄露。参考系统putenv()函数。
    #+END_QUOTE

    如果支持putenv()，修改os.environ直接翻译为调用putenv()；但是，调用
    putenv()不会更新os.environ，所以建议直接修改os.environ。

*** os. *setegid* (egid)
    设置当前进程的有效用户组ID。

    兼容：Unix。

*** os. *seteuid* (euid)
    设置当前进程的有效用户ID。

    兼容：Unix。
*** os. *setgid* (gid)
    设置当前进程的用户组ID。

    兼容：Unix。

*** os. *setgroups* (groups) ？？？
*** os. *setpgrp* ()
*** os. *setpgid* (pid,pgrp)
*** os. *setpriority* (which,who,priority)
*** os. *setregid* (rgid,egid)
*** os. *setresid* (rgid,egid,sgid)
*** os. *setresuid* (ruid,euid,suid)
*** os. *setreuid* (ruid,euid)
*** os. *getsid* (pid)
*** os. *setsid* ()
*** os. *setuid* (uid)
*** os. *strerror* (code)
*** os. *supports_bytes_environ*
*** os. *umask* (mask)
    设置当前当前umask值为MASK，并返回原来umask值。
*** os. *uname* ()
    返回当前操作系统信息组成的namedtuple。返回值有下面5个属性：
    
    - sysname： 操作系统名称。
    - nodename：主机在网络中的名称。
    - release：操作系统发行信息。
    - version：操作系统版本。
    - machine：硬件信息。

    #+BEGIN_SRC python :session
      import os
      print(os.uname().release)
      for x in os.uname():
          print(x)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 4.9.0-kali3-amd64
    - ... ... Linux
    - kali
    - 4.9.0-kali3-amd64
    - #1 SMP Debian 4.9.18-1kali1 (2017-04-04)
    - x86_64
    #+END_SRC

    一些系统会将nodename属性删减为8个字符；获取nodename更可靠的方式为
    socket.gethostname()或socket.gethostbyaddr(socket.gethostname())：

    #+BEGIN_SRC python :session
      import socket
      socket.gethostname()
      socket.gethostbyaddr(socket.gethostname())
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 'kali'
    - ('kali', [], ['127.0.1.1'])
    #+END_SRC

    兼容：最近版本的Unix。

*** os. *unsetenv* (key)
** 创建文件对象
*** os. *fdopen* (fd,*args,**kwargs)
    返回FD文件描述符对应的文件对象。与内置函数open()使用相同参数，唯一
    不同为第一个参数为文件描述符（整数）。

    #+BEGIN_SRC python :session
      import os
      fd = os.open('files/emma.txt', os.O_RDONLY)
      print('当前文件描述符为：', fd)
      fo = os.fdopen(fd)
      fo.read()
      # fo.close()
      os.close(fd)
      fo.closed
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> 当前文件描述符为： 3
    - >>> '10'
    - ... >>> False
    #+END_SRC

** 文件描述符（File Descriptor）操作
   下面的函数使用文件描述符操作I/O流。

   文件描述符为小整数，与当前进程打开文件数相关。比如，标注输入流描述
   符为0，标准输出流为1，标准错误流为2。以后，每打开一个文件，此数字递
   增，并对应当前打开文件。在Unix中，sockets和pip都会有对应文件描述符。

   io.fileno()可获取文件对象对应的文件描述符：

   #+BEGIN_SRC python :session
     import sys
     sys.stdin.fileno()
     sys.stdout.fileno()
     sys.stderr.fileno()
     with open('files/emma.txt') as f:
         print(f.fileno())
   #+END_SRC

   #+RESULTS:
   #+BEGIN_SRC org
   - 0
   - 1
   - 2
   - ... ... 3
   #+END_SRC
   
*** 普通函数
**** os. *close* (fd)
     关闭文件描述符FD。

     #+BEGIN_QUOTE
     *注意* ：此函数专用于底层I/O调用，只能关闭os.open()或os.pipe()打
     开的文件描述符。如需关闭open()、popen()或fdopen()打开的文件对象，
     则需使用该文件对象的close()方法。
     #+END_QUOTE

     #+BEGIN_SRC python :session
       import os
       fd = os.open('files/emma.txt', os.O_RDONLY)
       os.read(fd, 1)
       os.close(fd)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> b'1'
     #+END_SRC

**** os. *closerange* (fd_low,fd_high)
     关闭文件描述符从FD_LOW（包含）到FD_HIGH（不包含）的所有文件描述符，
     忽视抛出错误。基本上等价于（但快于）：

     #+BEGIN_EXAMPLE python
       for fd in range(fd_low, fd_high):
           try:
               os.close(fd)
           except OSError:
               pass
     #+END_EXAMPLE

**** os. *device_encoding* (fd)
     如果FD为终端的文件描述符，返回其编码形式；否则返回None。

     #+BEGIN_SRC python :session
       import os
       import sys
       fd = os.open('files/emma.txt', os.O_RDONLY)
       print(os.device_encoding(fd))
       print(os.device_encoding(sys.stdin.fileno()))
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> None
     - UTF-8
     #+END_SRC

**** os. *dup* (fd)
     返回FD的副本，不会被子进程继承。
     
     在Windows中，（0:stdin、1:stdout、2:stderr）会被子进程继承。
     
     #+BEGIN_SRC python :session
       import os
       fd = os.open('files/emma.txt', os.O_RDONLY)
       fd1 = os.dup(fd)
       print(fd, fd1)
       os.read(fd, 1)
       os.read(fd1, 1)
       os.closerange(fd, fd1 + 1)
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> 3 4
     - b'1'
     - b'0'
     #+END_SRC
     
**** os. *dup2* (fd, fd2, inheritable=True)
     将FD复制成FD2，如果必要关闭FD。可设置INHERITABLE参数指定FD2是否可
     被子进程继承。

     #+BEGIN_SRC python :session
       import os

       print('files/a.txt中的内容：')
       with open('files/a.txt') as f:
           print(repr(f.read()))

       print('files/b.txt中的内容：')
       with open('files/b.txt') as f:
           print(repr(f.read()))

       fda = os.open('files/a.txt', os.O_RDONLY)
       fdb = os.open('files/b.txt', os.O_RDONLY)

       os.read(fda, 2)
       print('将fdb指向fda后，fdb就相当于fda：')
       print(fda, fdb)
       os.dup2(fda, fdb)
       os.read(fdb, 2)

       os.close(fda)
       os.close(fdb)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> files/a.txt中的内容：
     - ... ... '1\n2\n3\n'
     - files/b.txt中的内容：
     - ... ... 'a\nb\nc\n'
     - >>> >>> >>> b'1\n'
     - 将fdb指向fda后，fdb就相当于fda：
     - 3 4
     - >>> b'2\n'
     #+END_SRC
     
**** os. *fchmod* (fd,mode)
     自Python3.3以后，等价于os.chmod(FD, MODE)

     #+BEGIN_EXAMPLE ipython
       In [147]: ls -l test.txt
       -rw-r--r-- 1 claudio claudio 0 May 24 11:51 test.txt
     
       In [148]: fd = os.open('test.txt', os.O_RDONLY)

       In [149]: os.fchmod(fd, stat.S_IRWXO)

       In [150]: os.close(fd)

       In [151]: ls -l test.txt
       -------rwx 1 claudio claudio 0 May 24 11:51 test.txt*
     #+END_EXAMPLE

**** os. *fchown* (fd,uid,gid)
     自Python3.3后，等价于ps.chown(FD, MODE)。

**** os. *fdatasync* (fd)
     强制将写入FD的内容同步到磁盘。不强制更新元数据。

     兼容：Unix。
**** os. *fpathconf* (fd,name) （待续）
**** os. *fstat* (fd)
     自Python3.3后，等价于os.stat(fd)。
**** os. *fstatvfs* (fd)
     自Python3.3后，等价于os.statvfs(fd)
**** os. *fsync* (fd)
     强制将对FD的写同步到磁盘。Unix中，底层为系统调用fsync；Windows中，
     为系统调用MS_commit()。
     
     如果启动一个已buffered的文件对象f，首先调用f.flush()，再调用
     os.fsync(f.fileno)，可确保所有与f相关的缓存写入磁盘。

**** os. *ftruncate* (fd,length)
     自Python3.3后，等价于os.truncate(fd,length)。
**** os. *get_blocking* (fd) （待续）
**** os. *isatty* (fd)
     如果FD为已打开的tty形式设备返回True，否则返回False。
     
     #+BEGIN_SRC python :session
       import os
       import sys
       fd = sys.stdin.fileno()
       os.isatty(fd)
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> True
     #+END_SRC

**** os. *lockf* (fd,cmd,len) （待续）
***** os. *F_LOCK*
***** os. *F_TLOCK*
***** os. *F_ULOCK*
***** os. *F_TEST*
**** os. *lseek* (fd,pos,how)
     将当前文件描述符FD的对应文件的指针设置为相当于HOW处的POS位置。HOW
     的取值可为：

     - os.SEEK_SET或0：相当于文件起始位置。
     - os.SEEK_CUR或1：相对于当前位置。
     - os.SEEK_END或2：相对于文件末尾位置。

     返回从文件起始位置按byte计算的位置。

***** os. *SEEK_SET*
***** os. *SEEK_CUR*
***** os. *SEEK_END*
      lseek()函数参数，取值分别为0、1和2。

**** os. *open* (path,flags,mode=0o777,*,dir_fd=None)
     打开字符串PATH指定文件，通过FLAGS设置flags，MODE设置权限（与系统
     umask值一起计算），返回新打开文件对应的文件描述符。返回文件描述符
     不可被子进程继承。
     
     FLAGS和MODE参数使用方法可参考C run-time documentation？？？；FLAG
     常量（如os.O_RDONLY和os.O_WRONLY）定义在os模块中。在Windows系统中，
     以二进制打开文件需添加O_BINARY。
     
     支持“路径相对于文件夹描述符指定目录”。
     
     #+BEGIN_QUOTE
     *注意* ：此函数主要用于底层I/O操作。一般情况下，使用内置函数
     open()即可；将文件描述符包装成文件对象，使用os.fdopen()。
     #+END_QUOTE
     
     下面为FLAGS参数可取值，使用比特或操作组合：
***** Unix和Windows都有效的常量
****** os. *O_RDONLY*
****** os. *O_WRONLY*
****** os. *O_RDWR*
****** os. *O_APPEND*
****** os. *O_CREATE*
****** os. *O_EXCL*
****** os. *O_TRUNC*
***** 只有Unix中才有效的常量
****** os. *O_DSYNC*
****** os. *O_RSYNC*
****** os. *O_SYNC*
****** os. *O_NDELAY*
****** os. *O_NONBLOCK*
****** os. *O_NOCTTY*
****** os. *O_CLOEXEC*
***** 只有Windows中才有效的常量
****** os. *O_BINARY*
****** os. *O_NOINHERIT*
****** os. *O_SHORT_LIVED*
****** os. *O_TEMPORARY*
****** os. *O_RANDOM*
****** os. *O_SEQUENTIAL*
****** os. *O_TEXT*
***** 扩展，但只有在C库中有定义才有效的常量
****** os. *O_ASYNC*
****** os. *O_DIRECT*
****** os. *O_DIRECTORY*
****** os. *O_NOFOLLOW*
****** os. *O_NOATIME*
****** os. *O_PATH*
****** os. *O_TMPFILE*
****** os. *O_SHLOCK*
****** os. *O_EXLOCK*
**** os. *openpty* () （待续）
**** os. *pipe* () （待续）
**** os. *pipe2* (flags) （待续）
**** os. *posix_fallocate* (fd,offset,len) （待续）
**** os. *posix_fadvise* (fd,offset,len,advice) （待续）
***** os. *POSIX_FADV_NORMAL*
***** os. *POSIX_FADV_SEQUENTIAL*
***** os. *POSIX_FADV_RANDOM*
***** os. *POSIX_FADV_NOREUSE*
***** os. *POSIX_FADV_WILLNEED*
***** os. *POSIX_FADV_DONTNEED*
**** os. *pread* (fd,buffersize,offset)
     在文件描述符FD中，从OFFSET处读取内容，最多读取BUFFERSIZE个bytes。
     文件指针保持不变。
**** os. *pwrite* (fd,str,offset)
     向文件描述符FD中，从OFFSET位置开始，写入bytes对象STR。文件指针位
     置保持不变。
**** os. *read* (fd,n)
     从文件描述符FD中读取至多N个bytes，以bytes对象形式返回读取内容。如
     果达到FD末尾，返回空bytes对象。

     #+BEGIN_QUOTE
     *注意* ：此函数只用于底层I/O操作，只能用于os.open()或os.pipe()返
     回的文件描述符。如需读取open()、popen()、fdopen()或sys.stdin文件
     对象内容，使用read()或readline()方法。
     #+END_QUOTE

**** os. *sendfile* (out,in,offset,count)
**** os. *sendfile* (out,in,count,[headers,][trailers,]flags=0) （待续）
**** os. *set_blocking* (fd,blocking) （待续）
***** os. *SF_NODISKIO*
***** os. *SF_MNOWAIT*
***** os. *SF_SYNC*
**** os. *readv* (fd,buffers) （待续）
**** os. *tcgetpgrp* (fd) （待续）
**** os. *tcsetpgrp* (fd,pg) （待续）
**** os. *ttyname* (fd) （待续）
**** os. *write* (fd,str) （待续）
**** os. *writev* (fd,buffers) （待续）
*** 获取命令行大小
    参考shutil.get_terminal_size()。
**** os. *get_terminal_size* (fd=STDOUT_FILENO)
**** class os.terminal_size
***** columns
***** lines
*** 文件描述器继承 （待续）
** 文件和文件夹操作
   在Unix系统中，下面大多数函数支持以下一种或多种特性：

   - 使用文件描述符作为路径：对于一些函数，PATH参数既可以是字符串也可
     以是文件描述符。（对于POSIX系统，实际上是调用的f...版本的对应函
     数。）

     可使用os.supports_fd查看支持文件描述符作为文件路径参数的函数，如
     果没有此常量，抛出NotImplementedError错误：

     #+BEGIN_SRC python :session
       import os
       os.supports_fd
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> {<built-in function execve>, <built-in function stat>, <built-in function pathconf>, <built-in function chmod>, <built-in function truncate>, <built-in function statvfs>, <built-in function chdir>, <built-in function listdir>, <built-in function utime>, <built-in function chown>}
     #+END_SRC

     如果函数还支持DIR_FD或FOLLOW_SYMLINKS参数，使用文件描述符作为PATH
     参数时再设置这两个参数为True将抛出错误：

     #+BEGIN_SRC python :session
       import os
       fd = os.open('files/emma.txt', os.O_RDONLY)
       os.access(fd, os.R_OK, follow_symlinks=True)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> Traceback (most recent call last):
     -   File "<stdin>", line 1, in <module>
     - TypeError: access: illegal type for path parameter
     #+END_SRC

   - 路径相对于文件夹描述符：如果DIR_FD参数不为None，则需为文件夹描述
     符。当前函数的路径参数将相对于此文件夹。如果PATH参数为绝对路径，
     此参数值忽略。（对于POSIX系统，实际上会调用...at或f...at版本对应
     函数。）

     可查看os.supports_dir_fd参数获取支持此参数的函数，如果没有此常量
     抛出NotImplementedError错误：
     
     #+BEGIN_SRC python :session
       import os
       os.supports_dir_fd
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - {<built-in function stat>, <built-in function rmdir>, <built-in function chmod>, <built-in function rename>, <built-in function readlink>, <built-in function mkdir>, <built-in function open>, <built-in function mkfifo>, <built-in function utime>, <built-in function symlink>, <built-in function chown>, <built-in function link>, <built-in function mknod>, <built-in function unlink>, <built-in function access>}
     #+END_SRC
     
   - 不跟随软连接：如果FOLLOW_SYMLINKS参数为False，且PATH为软链接，则
     函数操作对象为该软链接，而非软链接指向的文件。（对应POSIX系统，实
     际上是调用的l...版本的对应函数。）
     
     可使用os.supports_follow_symlinks查看支持的函数，如果没有此常量，
     抛出NotImplementedError错误：
     
     #+BEGIN_SRC python :session
       import os
       os.supports_follow_symlinks
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - {<built-in function stat>, <built-in function utime>, <built-in function chown>, <built-in function link>, <built-in function access>}
     #+END_SRC
     
*** os. *access* (path,mode,*,dir_fd=None,effective_ids=False,follow_symlinks=True)
    使用真实用户/用户组ID检查PATH。大多数操作会使用有效用户/用户组ID，
    所有此函数可用在设置了suid/sgid的环境中测试“申请用户（invoking
    user）？？？”是否有特定访问权限。

    MODE参数需为：F_OK测试路径对应文件是否存在，并与R_OK、W_OK和X_OK使
    用比特或操作连用。

    如果能成功访问返回True，否则返回False。

    如果EFFECTIVE_IDS参数为True，access()会使用有效用户/用户组ID查看权
    限。可能某些系统不支持此参数，可使用os.supports_effective_ids查看，
    如果没有此常量抛出NotImplementedError错误：

    #+BEGIN_SRC python :session
      import os
      os.supports_effective_ids
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - {<built-in function access>}
    #+END_SRC

    此函数支持“路径相对于文件夹描述符”和“不跟随软链接”。
    
    #+BEGIN_QUOTE
    *注意* ：在使用open()真正打开文件前，使用access()判断某个用户是否
    有权限会造成安全漏洞。因为用户可利用测试权限和打开文件的短暂间隙访
    问文件。错误的写法为：
    
    #+BEGIN_EXAMPLE python
      if os.access('myfle'. os.R_OK):
         with open('myfle') as fp:
              return fp.read()
      return 'some default data'
    #+END_EXAMPLE
    
    正确的写法为：
    
    #+BEGIN_EXAMPLE python
      try:
          fp = open('myfile')
      except PermissionError:
          return 'some default data'
      else:
          with fp:
               return fp.read()
    #+END_EXAMPLE
    #+END_QUOTE

    #+BEGIN_QUOTE
    *注意* ：即时access()测试成功，I/O操作也可能失败。比如操作网络文件
    系统文件时，其权限模式与POSIX的权限bit模式不同。
    #+END_QUOTE

**** os. *F_OK*
**** os. *R_OK*
**** os. *W_OK*
**** os. *X_OK*
     用于access的mode参数，分别用于测试路径是否：存在、可读、可写、可
     执行。

*** os. *chdir* (path)
    将当前工作目录切换到PATH中。
    
    此函数支持“文件描述符作为路径”，但此时文件描述符应该为已打开的文件
    夹，而不是文件。
    
    *？* ：怎么打开文件夹，并返回文件描述符？？？
    
*** os. *chflags* (path,flags,*,follow_symlinks=True)
    *？* ：我的Kali上没有chflags系统调用。

    #+BEGIN_SRC sh
      uname -a
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - Linux kali 4.9.0-kali3-amd64 #1 SMP Debian 4.9.18-1kali1 (2017-04-04) x86_64 GNU/Linux
    #+END_SRC
    
    将使用FLAGS设置PATH的flags，FLAGS可使用二进制“或”操作指定多个，选
    值可从stat模块中获取。
    
    支持“不跟随软链接”。

    兼容：Unix。
    
*** os. *chmod* (path,mode,*,dir_fd=None,follow_symlinks=True)
    使用MODE设置PATH的权限。MODE可为多个连用参数，也可使用二进制“或”，
    取值可从stat模块中获取，并使用比特或操作连用：
    
    #+BEGIN_EXAMPLE python
      import stat
      stat.S_ISUID
      stat.S_ISGID
      ...
    #+END_EXAMPLE

    支持使用文件描述符表示PATH，路径相对于文件夹描述符DIR_FD，以及不跟
    随软链接。
    
    支持“使用文件描述符作为路径”、“路径相对于文件夹描述符”和“不跟随软
    链接”。

    #+BEGIN_QUOTE
    *注意* ：尽管Windows支持chmod()操作，但只能使用stat.S_IWRITE和
    stat.S_IREAD常量，其他值被忽视。
    #+END_QUOTE

*** os. *chown* (path,uid,gid,*,dir_fd=None,follow_symlinks=True)
    改变PATH指定文件/文件夹的拥有者或拥有者用户组，如果不改变其中一项，
    可将其设置为-1。

    支持“使用文件描述符作为路径”、“路径相对于文件夹描述符”和“不跟随软
    链接”。

    参考：shutil.chown()即可接受ID，也可接受字符串名称作为参数。

*** os. *chroot* (path)
    将当前进程的根目录切换到PATH。
    
*** os. *fchdir* (fd)
    将当前工作文件夹切换到FD指定的文件夹描述符中。自Python3.3后等价于
    os.chdir(FD)。

*** os. *getcwd* ()
    返回表示当前工作文件夹绝对路径的字符串。
*** os. *getcwdb* ()
    返回表示当前工作文件夹绝对路径的bytes对象。使用系统默认编码方式编
    码。

*** os. *lchflags* (path,flags)
    自Python3.3后等价于os.chflags(PATH,FLAGS,follow_symlinks=False)。
    即不跟随软链接。
    
*** os. *lchmod* (path,mode)
    即os.chmod()不跟随软链接的版本，自Python3.3后等价于
    os.chmod(PATH,MODE,follow_symlinks=False)。

*** os. *lchown* (path,uid,gid)
    即os.chown()的不跟随软链接版本，等价于
    os.chown(PATH,UID,GID,follow_symlinks=False)。
    
*** os. *link* (src,dst,*,src_dir_fd=None,dst_dir_fd=None,follow_symlinks=True)
    创建名为DST的 *硬链接* ，指向SRC。

    支持“路径相对于文件夹描述符”（SRC_DIR_FD或/和DST_DIR_FD）；以及“不
    跟随软链接”。

*** os. *lstdir* (path='.')
    返回PATH文件夹（默认为当前文件夹）中所有文件和文件夹组成的链表。不
    包含"."和".."。顺序不确定。
    
    PATH可为字符串，也可为bytes对象。如果为bytes对象，返回链表的元素也
    为bytes对象，其他任何情况都为字符串。

    支持“使用文件夹描述符表示路径”。
    
    #+BEGIN_QUOTE
    *注意* ：将字符串文件名转换为bytes对象，最好使用os.fsencode()函数。
    #+END_QUOTE

    #+BEGIN_QUOTE
    *另见* ：os.scandir()可获取每个文件更详细的信息。
    #+END_QUOTE

*** os. *lstat* (path,*,dir_fd=None)
    Python3.3后，等价于
    os.stat(PATH,dir_fd=DIR_FD,follow_symlinks=False)，即os.stat()不跟
    随软链接版本。返回结果也为stat_result对象。

    支持“文件描述符作为路径”。

*** os. *mkdir* (path,mode=0o777,*,dir_fd=None)
    创建名为PATH的文件夹，使用MODE参数设置权限。

    如果文件夹已存在，抛出FileExistsError错误。

    在支持umask（如Unix）的系统中，会将MODE值与系统umask值进行比特^操
    作作为最终权限值，如果结果不是3位8进制数，含义由系统决定。在忽视
    MODE参数的系统中，需使用os.chmod()手动设置文件夹权限。

    此函数支持“文件描述符作为路径”。

    如需创建临时文件夹，可参考tempfile中的mkdtmp()函数。

*** os. *makedirs* (name,mode=0o777,exist_ok=False)
    递归创建文件夹。与mkdir()相似，不过会创建不存在的父文件夹。

    MODE参数会传递给mkdir()函数，所以用法相同。

    如果EXIST_OK参数为False（默认），且需创建的文件夹已存在，则抛出
    OSError错误。

    #+BEGIN_QUOTE
    *注意* ：可能不会正确处理NAME中含os.padir的情况。
    #+END_QUOTE

    可正确处理UNC路径。？？？
    
*** os. *mkfifo* (path,mode=0o666,*,dir_fd=None)
    与系统调用mkfifo相同，创建一个名为PATH的FIFO（命名管道），权限为
    MODE与系统umask值使用比特^计算的结果。

    支持“文件描述符作为路径”。

    可使用os.unlink()删除。

*** os. *mknod* (path,mode=0o600,device=0,*,dir_fd=None) （待续）
    参考Linux的mknod系统调用？？？
*** os. *major* (device) （待续）
*** os. *minor* (device) （待续）
*** os. *makedev* (major,minor) （待续）
*** os. *pathconf* (path,name) （待续）
*** os. *pathconf_names* （待续）

    #+BEGIN_SRC python :session
      import os
      os.pathconf_names
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> {'PC_SOCK_MAXBUF': 12, 'PC_PRIO_IO': 11, 'PC_NO_TRUNC': 7, 'PC_FILESIZEBITS': 13, 'PC_CHOWN_RESTRICTED': 6, 'PC_ALLOC_SIZE_MIN': 18, 'PC_LINK_MAX': 0, 'PC_REC_MIN_XFER_SIZE': 16, 'PC_REC_MAX_XFER_SIZE': 15, 'PC_PATH_MAX': 4, 'PC_VDISABLE': 8, 'PC_MAX_INPUT': 2, 'PC_SYMLINK_MAX': 19, 'PC_REC_INCR_XFER_SIZE': 14, 'PC_SYNC_IO': 9, 'PC_REC_XFER_ALIGN': 17, 'PC_PIPE_BUF': 5, 'PC_MAX_CANON': 1, 'PC_ASYNC_IO': 10, 'PC_NAME_MAX': 3}
    #+END_SRC

*** os. *readlink* (path,*,dir_fd=None)
    返回软链接路径PATH指向文件的路径字符串。返回结果可为相对路径，也可
    为绝对路径（与创建时指定路径相同？？？）。如果为相对路径，使用
    os.path.join(os.path.dirname(PATH), result)作为返回值。

    如果PATH为字符串对象，返回值也为字符串对象，可能抛出
    UnicodeDecodeError错误；如果为bytes对象，返回值也为bytes对象。

    也支持“文件夹描述符相对路径目录”。

    兼容：Unix，Windows。

*** os. *remove* (path,*,dir_fd=None)
    删除PATH指定的文件。如果PATH指向文件夹，抛出OSError错误。删除文件
    夹可使用os.rmdir()。

    支持“文件夹描述符作为相对路径目录”。

    语义上等价于os.unlink().

    Windows中，尝试删除正在被使用的文件会抛出错误；Unix在，所在文件夹
    的接口被删除，但该文件所在内存只有在文件不再被使用后才能重新使
    用。？？？

*** os. *removedirs* (name)
    递归删除文件夹。同os.rmdir()一样，只能删除空文件夹。从最深的子文件
    夹开始逐个删除，直到遇到不是空文件为止。
*** os. *rename* (src,dst,*,src_dir_fd=None,dst_dir_fd=None)
    将文件/文件夹SRC重命名为DST。如果DST为已存在文件夹，抛出OSError错
    误了；如果为已存在的文件，则默认替换（有权限的情况下）；在Windows
    中，不管DST是已存在的文件还是文件夹，都会抛出OSError错误。

    在Unix中，如果SRC和DST为不同文件系统文件，执行会失败。

    如需跨平台重命名文件/文件夹，可使用os.replace()。

    #+BEGIN_EXAMPLE ipython
      In [110]: os.makedirs('test/test1/test2')

      In [111]: pathlib.Path('test/test1/test2/test.txt').touch()

      In [112]: os.rename('test/', 'test-renamed')

      In [113]: ls test-renamed/
      test1/

      In [114]: ls test-renamed/test1/
      test2/
    
      In [115]: ls test-renamed/test1/test2/
      test.txt
    #+END_EXAMPLE

*** os. *renames* (old,new)
    递归重命名文件/文件夹。与rename()不同的是，如果需要，会创建中间文
    件夹，重命名完成后OLD中最右边的子文件夹会使用removedis()删除。
    
    #+BEGIN_EXAMPLE ipython
      In [118]: os.makedirs('test/test1/test2')

      In [119]: pathlib.Path('test/test1/test2/test.txt').touch()

      In [120]: os.renames('test/test1/', 'testA/testB')

      In [121]: ls test/

      In [122]: ls testA
      testB/

      In [123]: ls testA/testB/
      test2/

      In [124]: ls testA/testB/test2/
      test.txt
    #+END_EXAMPLE
    
*** os. *replace* (src,dst,*,src_dir_fd=None,dst_dir_fd=None)
    os.rename()的支持跨平台版本。

    *？* ：[[https://bugs.python.org/issue27886][os.rename和os.replace的区别]] 。看了还是没明白，然后还引出一
    个新问题：Path.rename()又有何区别。

*** os. *rmdir* (path,*,dir_fd=None)
    删除PATH指定的文件夹。只能删除空文件夹，否则抛出OSError错误。如需
    删除整个文件树，可使用shutil.rmtree()。

    支持“相对于文件夹描述符指定路径”。

*** os. *scandir* (path='.')
    返回PATH指向文件夹的DirEntry可迭代对象。其中文件夹内容顺序不定，且
    不包含"."和".."。
    
    如需使用文件名和文件属性信息，用scandir()替代listdir()可大幅提高效
    率。因为在扫描文件夹时，DirEntry对象会尽可能保留系统提高的文件信息。
    所有DirEntry的方法都可能执行系统调用，但is_dir()和is_file()通常只
    在用来判断软链接时才进行；DirEntry.stat()在Unix中总是会执行系统调
    用，但在Windows中只会执行一次。
    
    Unix中，PATH可为字符串对象，也可为bytes对象（使用fsendode()和
    fsdecode()编码和解码）。Windows中，PATH只能为字符串对象。在两类系
    统中，DirEntry的name和path属性值类型与PATH类型相同。
    
    下例为简单的scandir()实例：显示不以“.”开始的文件名。其中
    entry.is_file()一般情况下不会执行系统调用：
    
    #+BEGIN_EXAMPLE python
      for entry in os.scandir(path):
          if not entry.name.statswith('.') and entry.is_file():
             print(entry.name)
    #+END_EXAMPLE
    
    #+BEGIN_QUOTE
    *注意* ：以Unix为基础的系统中，scandir()实际使用了系统的
    opendir()和readdir()函数；在Windows中，则是使用了Win32的
    FindFirstFileW和FindNextFileW函数。
    #+END_QUOTE
    
*** class os. *DirEntry*
    scandir()返回结果对象，暴露文件夹的路径和其他文件属性。
    
    scandir()会在不额外进行系统调用的情况下提供尽可能多的信息。当进行
    stat()或lstat()系统调用时，DirEntry会缓存结果。
    
    DirEntry并不适合于存储长时间的数据结构？？？。如果已知文件的元数据
    有改动，或使用DirEntry时距调用scandir()已经间隔较长时间，可使用
    os.stat(entry.path)获取最新数据。
    
    由于DirEntry的方法可以进行系统调用，所以可能抛出OSError错误。如需
    精细控制这些错误，可在调用DirEntry方法是捕捉。
    
    DirEntry有下面方法和属性：
    
**** name
     子项目文件名，相对于scandir()PATH参数指定文件夹。

     为字符串类型还是bytes对象，取决于scandir()的PATH参数。如果为bytes
     对象，可使用os.fsdecode()函数解码。
**** path
     返回子项目全路径，等价于os.path.join(scandir_path, entry.name)，
     其中scandir_path为scandir()的PATH参数。只有当scandir()的PATH参数
     为决对路径时，才为决定路径。

     为字符串类型还是bytes对象，取决于scandir()的PATH参数。如果为bytes
     对象，可使用os.fsdecode()函数解码。

**** inode()
     返回子项目的inode数值。

     结果会缓存在DirEntry对象上，可使用os.stat(entry.path,
     follow_symlinks=False).st_ino获取最新值。

     第一次调用为非缓存调用，Windows会执行系统调用，Unix则不会。

**** is_dir(*,follow_symlinks=True)
     如果子项目为文件夹或指向文件夹的软链接返回True，其他任何文件、执
     行其他任何文件，或不存在返回False。

     如果FOLLOW_SYMLINKS为False，只有当子项目为文件夹时才返回True。

     FOLLOW_SYMLINKS为True和False的返回结果会分别缓存在DirEntry对象上。
     如需获取最新结果，可对子项目先调用os.stat()，再调用stat.S_ISDIR()。

     第一次调用时，大多数情况下不会执行系统调用。尤其是对应非软链接的
     子项目，Windows和Unix都不会进行系统调用；但Unix中个别文件系统除外，
     如网络文件系统中dirent.d_type == DT_UNKNOWN时。如果子项目为软链接，
     且FOLLOW_SYMLINKS参数为True，则进行系统调用。

     此方法可能会抛出OSError，如PermissionError，但FileNotFoundError错
     误会被捕捉但不抛出。

**** is_file(*,follow_symlinks=True)
     如果子项目为文件或指向文件的软链接，返回True；其他任何文件形式或
     不存在则返回False。

     如果FOLLOW_SYMLINKS参数为False，只有当子项目为文件时才返回True，
     其他任何情况返回False。

     返回结果会缓存到DirEntry对象上。缓存方法、系统调用方式和错误抛出
     方式与is_dir()相同。
**** is_symlink()
     如果子项目为软链接（即使为已损坏软链接）返回True，其他任何情况或
     不存在则返回False。

     结果会缓存在DirEntry对象上。调用os.path.islink()可获取最新结果。

     第一次调用时，大多数情况下不会执行系统调用。尤其Windows和Unix都不
     会进行系统调用；但Unix中个别文件系统除外，如网络文件系统中
     dirent.d_type == DT_UNKNOWN时。

     此方法可能会抛出OSError，如PermissionError，但FileNotFoundError错
     误会被捕捉但不抛出。

**** stat(*,follow_symlinks=True)
     返回子项目的stat_result结果对象。默认跟随软链接，如需获取软链接的
     stat信息，可设置FOLLOW_SYMLINKS参数为False。
     
     Unix中，此方法总是会进行系统调用；Windows中，只有当
     FOLLOW_SYMLINKS参数为True，且子项目为软链接时才进行系统调用。
     
     Windows中，返回结果stat_result的st_ino、st_dev和st_nlink属性总是
     为0，可调用os.stat()获取这些属性。
     
     FOLLOW_SYMLINKS为True和False的调用结果会分别缓存在DirEntry对象上。
     可调用os.stat()获取最新信息。
     
     *注意* ：DirEntry的属性和方法，与pathlib.Path的属性和方法联系紧密，
     尤其时name属性、is_dir()、is_file()、is_symlink()和stat()方法含义
     完全相同。
     
*** os. *stat* (path,*,dir_fd=None,follow_symlinks=True)
    获取文件或文件描述符的状态信息。等价于对PATH系统调用stat。PATH可以
    为字符串、bytes对象或文件描述符。返回stat_result对象。

    此函数一般会跟随软链接，如需取消此功能声明FOLLOW_SYMLINKS参数为
    False，或使用os.lstat()。

    支持“文件描述符表示路径”或“不跟随软链接”。

    举例：

    #+BEGIN_SRC python :session
      import os
      statinfo = os.stat('files/emma.txt')
      print(statinfo)
      print('文件大小：', statinfo.st_size)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> os.stat_result(st_mode=33206, st_ino=24779756, st_dev=2049, st_nlink=1, st_uid=1000, st_gid=1000, st_size=2, st_atime=1495858641, st_mtime=1495266124, st_ctime=1495266124)
    - 文件大小： 2
    #+END_SRC

    #+BEGIN_QUOTE
    *另见* ：fstat()和lstat()。
    #+END_QUOTE

*** class os. *stat_result*
    属性基本上包含系统调用stat返回值的对象，为os.stat()、os.fstat()和
    os.lstat()的返回结果形式。

    stat模块定义了提前stat结构体的函数和常量。

    为向后兼容，stat_result实例可作为元组访问，索引访问结果为整数。

**** st_mode
     文件模式：文件类型和模式位（权限）。
**** st_ino
     inode值。
**** st_dev
     所在地标识符。

**** st_nlink
     硬链接数量。
**** st_uid
     拥有者用户标识。
**** st_gid
     拥有者用户组标识。
**** st_size
     普通文件或软链接，为文件内容byte大小。对应软链接，为路径字符串大
     小，且不含结尾的null比特。
**** 时间戳
     #+BEGIN_QUOTE
     *注意* ：st_atime、st_mtime和st_ctime的精度取决于操作系统和文件系
     统。比如使用FAT或FAT32文件系统的Windows，st_mtime有2秒的精度，
     st_atime只有1天的精度。具体可查看操作系统文档。
     
     同样，尽管st_atime_ns、st_mtime_ns和st_ctime_ns总是以纳秒为单位，
     但许多系统不支持纳秒精度。在支持纳秒精度的系统中，st_atime、
     st_mtime和st_ctime浮点数不能表示纳秒精度，如需获取准确时间戳，可
     使用纳秒版本属性。
     #+END_QUOTE
***** st_atime
      最后访问时间。
***** st_mtime
      最近一次内容被修改时间。
***** st_ctime
      由系统决定：
      
      - Unix：元数据最后修改时间。
      - Windows：文件创建时间。（以秒为单位）
        
***** st_atime_ns
      最后访问时间，以整数表示的纳秒。
***** st_mtime_ns
      最后修改时间，以整数表示的纳秒。
***** st_ctime_ns
      由系统决定：
      
      - Unix：元数据最后修改时间。
      - Windows：文件创建时间，以整数表示的纳秒。
**** Unix特有属性 ？？？
***** st_blocks ？？？
      为文件分配的512-bytes块。当文件有holes时，可能小于st_size/512。
***** st_blksize
***** st_rdev
***** st_flags
**** Mac OS特有属性（待续）
***** st_birthtime
***** st_creator
***** st_type
**** Windows特有属性（待续）
***** st_file_attibutes
*** os. *stat_float_times* ([newvalue])
    决定stat_result对象表示时间戳是是否用浮点数。如果NEWVALUE为True，
    以后调用os.stat()的返回值中时间戳都用浮点数表示；如果为False，以后
    调用结果中的时间戳都用整数表示；如果缺省，则返回当前设置。

    #+BEGIN_SRC python :session
      import os
      os.stat_float_times
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - <built-in function stat_float_times>
    #+END_SRC

    为与Python旧版本兼容，将stat_result作为元组访问，获取的时间戳总是
    整数。

    目前，Python默认使用浮点数形式。如果应用不能正确处理浮点数时间戳，
    可使用此函数设置。

    时间戳精度由系统决定。一些系统中的精度为秒，另一些系统中小数部分会
    默认为0。

    建议只在程序启动时，即__main__模块中设置此值；库文件不得改变此值。

*** os. *statvsf* (path) （待续）
*** os. *supports_dir_fd*
    set对象，含os模块中允许使用dir_fd参数的函数，即支持“文件夹描述符作
    为相对路径根目录”的函数。

    #+BEGIN_SRC python :session
      import os
      os.supports_dir_fd
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> {<built-in function stat>, <built-in function rmdir>, <built-in function chmod>, <built-in function unlink>, <built-in function rename>, <built-in function readlink>, <built-in function mkdir>, <built-in function open>, <built-in function mkfifo>, <built-in function utime>, <built-in function symlink>, <built-in function chown>, <built-in function link>, <built-in function mknod>, <built-in function access>}
    #+END_SRC

    可使用in操作判断指定函数是否支持：

    #+BEGIN_EXAMPLE python
      os.stat in os.supports_dir_fd
    #+END_EXAMPLE

*** os. *supports_effective_ids*
    set对象。如果os.access()可使用effective_ids参数，则该参数包含在其
    中，否则返回结果为空set对象。

    #+BEGIN_SRC python :session
      import os
      os.supports_effective_ids
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - {<built-in function access>}
    #+END_SRC

    可使用in操作符查看os.access是否支持该参数：

    #+BEGIN_EXAMPLE python
      os.access in os.supports_effective_ids
    #+END_EXAMPLE

*** os. *supports_fd*
    set对象，含所有os模块中支持“使用文件描述符作为路径”的函数。

    #+BEGIN_SRC python :session
      import os
      os.supports_fd
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - {<built-in function stat>, <built-in function execve>, <built-in function pathconf>, <built-in function chmod>, <built-in function truncate>, <built-in function statvfs>, <built-in function chdir>, <built-in function listdir>, <built-in function utime>, <built-in function chown>}
    #+END_SRC

    可使用in操作符查看指定函数是否支持：

    #+BEGIN_EXAMPLE python
      os.chdir in os.supports_fd
    #+END_EXAMPLE
    
*** os. *supports_follow_symlinks*
    set对象，含os模块中所有可使用follow_symlinks参数的函数，即支持“不
    跟随软链接”特性的函数。
    
    #+BEGIN_SRC python :session
      import os
      for fn in os.supports_follow_symlinks:
          print(fn)
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - ... ... <built-in function stat>
    - <built-in function utime>
    - <built-in function chown>
    - <built-in function link>
    - <built-in function access>
    #+END_SRC

    可使用in操作符查看特定函数是否支持此特性：

    #+BEGIN_EXAMPLE python
      os.stat in os.supports_follow_symlinks
    #+END_EXAMPLE

*** os. *symlinks* (src,dst,target_is_directory=False,*,dir_fd=None)
    创建名为DST的软链接，指向SRC。

    TARGET_IS_DIRECTORY参数在Windows以外的系统上被忽视。

    Windows：（待续）

    兼容：Unix，Windows。
    
*** os. *sync* () ？？？
    强制将所有写入内容同步到磁盘。

    兼容：Unix。
*** os. *truncate* (path,length)
    将PATH指定文件删减到最多LENGTH个bytes大小。

    支持“文件描述符作为文件路径”。
    
    兼容：Unix、Windows。
*** os. *unlink* (path,*,dir_fd=None)
    删除PATH指定的文件。语义上等价于os.remove()。与传统Unix的同名命令
    含义相同，都是删除文件。
    
    具体用法可参考os.remove()函数。
*** os. *utime* (path,times=None,*,[ns,]dir_fd=None,follow_symlinks=True)
    设置PATH指定文件的最后访问时间（atime）和最后修改时间（mtime）。

    可使用可选参数TIMES或NS，用法如下：

    - 如果指定NS，需为2元素元组，形式为(atime_ns,mtime_ns)，其中每个值
      为表示纳秒的整数。
    - 如果指定TIMES，须为2元素元组，形式为(atime,mtime)，其中每个值为
      表示秒的浮点数。
    - 如果两个参数都缺省，相当于ns=(atime_ns,mtime_ns)，使用当前时间。
    - 两个参数不能同时指定。

    文件夹路径是否可作为PATH参数，取决于当前文件系统是否将文件夹实现为
    文件（如Windows就不能）。

    *注意* ：此函数设置时间后，以后调用os.stat()可能不会准确返回对应值，
    精度取决于操作系统。最好的办法是指定NS参数，使用os.stat()获取时使
    用stat_result的st_atime_ns和st_mtime_ns属性。

    此函数支持“文件描述符作为路径”、“相对于文件夹描述符指定的文件夹”和“不
    跟随软链接”。

*** os. *walk* (top,topdown=True,onerror=None,follow_symlinks=False)
    通过自上而下/自下而上递归文件树，生成文件夹中的文件名。对于自
    TOP（含TOP）文件树中的每个文件夹，yield一个3元素元组
    (dirpath,dirnames,filenames)。

    dirpath为字符串，表示当前文件夹的路径；dirnames为链表，含dirpath文
    件夹中所有子文件夹（不含"."和".."）；filenames为链表，含dirpath文
    件夹中除文件夹外所有所有文件。如需获取dirpath中文件/文件夹的全路径，
    可使用os.path.join(dirpath,name)。
    
    如果TOPDOWN参数为True（默认），从顶层文件夹开始；如果为False，则从
    最深层文件夹开始。不管为False还是True，或在yield当前文件夹的元组前
    获取子文件？？？。

    当TOPDOWN为True时，可赋值当前dirnames（如使用del或赋值截断），此后
    walk只在dirnames中剩余的文件夹中递归。如果TOPDOWN为False，修改
    dirnames没有任何效果。 *？* ：测试没有任何效果。

    默认情况下，调用listdir()（Python3.5开始，已使用os.scandir()代替
    os.listdir()）抛出的错误会被忽视。如果设置可选参数ONERROR，需为接
    受一个OSError实例的参数的函数。可用于放弃递归，或报告错误但继续递
    归。exception对象的filename属性为filenames的的元素。

    默认情况下，不会跟随指向文件夹的软链接。可通过FOLLOW_SYMLINKS参数
    修改。但设置为True后，可能造成无限循环，如软链接指向已访问的文件夹。

*** os. *fwalk* (top='.',topdown=True,onerror=None,*,follow_symlinks=False,dir_fd=None)
    与walk()的不同点有：

    1. 各个文件夹中yield的为4元素元组：
       (dirpath,dirnames,filenames,dirfd)，前三个元素与walk相同，最后
       一个元素为表示第一个元素dirpath的文件夹描述符。
    2. 不仅支持“不跟随软链接”，还支持“路径相对于文件夹描述符指定的根目
       录”。

*** Linux扩展属性 （待续）
    下面的函数只在Linux中有效。
**** os. *getxattr* (path,attibute,*,follow_symlinks=True)
**** os. *listxattr* (path=None,*,follow_symlinks=True)
**** os. *removexattr* (path,attribute,*,follow_symlinks=True)
**** os. *setxattr* (path,attribute,value,flags=0,follow_symlinks=True)
**** os. *XATTR_SIZE_MAX*
**** os. *XATTR_CREATE*
**** os. *XATTR_REPLACE*

** 进程管理 （待续）
** scheduler接口 （待续）
** 各种系统信息
*** Unix特有
**** os. *confstr* (name) （待续）
**** os. *confstr_names*

     #+BEGIN_SRC python :session
       import os
       os.confstr_names
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - {'CS_LFS64_LDFLAGS': 1005, 'CS_XBS5_LP64_OFF64_LIBS': 1110, 'CS_XBS5_LPBIG_OFFBIG_LIBS': 1114, 'CS_XBS5_LP64_OFF64_LINTFLAGS': 1111, 'CS_XBS5_LPBIG_OFFBIG_LINTFLAGS': 1115, 'CS_XBS5_ILP32_OFF32_CFLAGS': 1100, 'CS_XBS5_LPBIG_OFFBIG_CFLAGS': 1112, 'CS_XBS5_ILP32_OFFBIG_LDFLAGS': 1105, 'CS_GNU_LIBPTHREAD_VERSION': 3, 'CS_LFS_LIBS': 1002, 'CS_LFS64_CFLAGS': 1004, 'CS_XBS5_ILP32_OFF32_LINTFLAGS': 1103, 'CS_LFS_CFLAGS': 1000, 'CS_LFS64_LINTFLAGS': 1007, 'CS_LFS64_LIBS': 1006, 'CS_XBS5_ILP32_OFFBIG_LINTFLAGS': 1107, 'CS_LFS_LDFLAGS': 1001, 'CS_LFS_LINTFLAGS': 1003, 'CS_XBS5_ILP32_OFFBIG_CFLAGS': 1104, 'CS_XBS5_ILP32_OFF32_LIBS': 1102, 'CS_XBS5_LP64_OFF64_LDFLAGS': 1109, 'CS_XBS5_LPBIG_OFFBIG_LDFLAGS': 1113, 'CS_PATH': 0, 'CS_XBS5_ILP32_OFFBIG_LIBS': 1106, 'CS_GNU_LIBC_VERSION': 2, 'CS_XBS5_LP64_OFF64_CFLAGS': 1108, 'CS_XBS5_ILP32_OFF32_LDFLAGS': 1101}
     #+END_SRC

**** os. *cpu_count* ()
     返回当前系统的CPU数量，如果不能读取，返回None。

     #+BEGIN_SRC python :session
       import os
       os.cpu_count()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - 4
     #+END_SRC

**** os. *getloadavg* () ？？？

     #+BEGIN_SRC python :session
       import os
       os.getloadavg()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - (0.13, 0.05, 0.01)
     #+END_SRC

**** os. *sysconf* (name) ？？？
**** os. *sysconf_names* ？？？

     #+BEGIN_SRC python :session
       import os
       os.sysconf_names
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - {'SC_FSYNC': 15, 'SC_COLL_WEIGHTS_MAX': 40, 'SC_UIO_MAXIOV': 60, 'SC_REALTIME_SIGNALS': 9, 'SC_AVPHYS_PAGES': 86, 'SC_THREAD_ATTR_STACKSIZE': 78, 'SC_PII_OSI': 57, 'SC_EQUIV_CLASS_MAX': 41, 'SC_NL_NMAX': 122, 'SC_XBS5_LP64_OFF64': 127, 'SC_BC_DIM_MAX': 37, 'SC_CHAR_MAX': 102, 'SC_XOPEN_REALTIME': 130, 'SC_MEMLOCK_RANGE': 18, 'SC_XBS5_ILP32_OFF32': 125, 'SC_THREAD_DESTRUCTOR_ITERATIONS': 73, 'SC_SSIZE_MAX': 110, 'SC_MEMORY_PROTECTION': 19, 'SC_THREADS': 67, 'SC_2_VERSION': 46, 'SC_CLK_TCK': 2, 'SC_XOPEN_LEGACY': 129, 'SC_PII_XTI': 54, 'SC_BC_SCALE_MAX': 38, 'SC_XOPEN_XPG4': 100, 'SC_MQ_PRIO_MAX': 28, 'SC_THREAD_PRIO_INHERIT': 80, 'SC_PAGE_SIZE': 30, 'SC_SEM_NSEMS_MAX': 32, 'SC_UCHAR_MAX': 115, 'SC_SEM_VALUE_MAX': 33, 'SC_XOPEN_XCU_VERSION': 90, 'SC_2_C_BIND': 47, 'SC_NL_SETMAX': 123, 'SC_SHRT_MAX': 113, 'SC_XOPEN_UNIX': 91, 'SC_2_CHAR_TERM': 95, 'SC_BC_BASE_MAX': 36, 'SC_XOPEN_SHM': 94, 'SC_RTSIG_MAX': 31, 'SC_EXPR_NEST_MAX': 42, 'SC_XBS5_LPBIG_OFFBIG': 128, 'SC_THREAD_PRIORITY_SCHEDULING': 79, 'SC_PAGESIZE': 30, 'SC_XOPEN_VERSION': 89, 'SC_SHARED_MEMORY_OBJECTS': 22, 'SC_WORD_BIT': 107, 'SC_NL_MSGMAX': 121, 'SC_MQ_OPEN_MAX': 27, 'SC_SYNCHRONIZED_IO': 14, 'SC_SAVED_IDS': 8, 'SC_T_IOV_MAX': 66, 'SC_SCHAR_MAX': 111, 'SC_NL_ARGMAX': 119, 'SC_PII_OSI_M': 65, 'SC_MAPPED_FILES': 16, 'SC_PII_SOCKET': 55, 'SC_CHAR_MIN': 103, 'SC_THREAD_THREADS_MAX': 76, 'SC_THREAD_PROCESS_SHARED': 82, 'SC_PII_INTERNET_DGRAM': 62, 'SC_2_FORT_DEV': 49, 'SC_POLL': 58, 'SC_CHAR_BIT': 101, 'SC_2_LOCALEDEF': 52, 'SC_2_UPE': 97, 'SC_NZERO': 109, 'SC_INT_MIN': 105, 'SC_PII_OSI_COTS': 63, 'SC_PHYS_PAGES': 85, 'SC_PRIORITY_SCHEDULING': 10, 'SC_TIMER_MAX': 35, 'SC_2_FORT_RUN': 50, 'SC_RE_DUP_MAX': 44, 'SC_VERSION': 29, 'SC_TIMERS': 11, 'SC_LONG_BIT': 106, 'SC_PII_INTERNET_STREAM': 61, 'SC_PASS_MAX': 88, 'SC_SCHAR_MIN': 112, 'SC_XOPEN_XPG3': 99, 'SC_SHRT_MIN': 114, 'SC_THREAD_STACK_MIN': 75, 'SC_BC_STRING_MAX': 39, 'SC_AIO_PRIO_DELTA_MAX': 25, 'SC_USHRT_MAX': 118, 'SC_SIGQUEUE_MAX': 34, 'SC_2_C_DEV': 48, 'SC_THREAD_ATTR_STACKADDR': 77, 'SC_XOPEN_REALTIME_THREADS': 131, 'SC_SELECT': 59, 'SC_THREAD_SAFE_FUNCTIONS': 68, 'SC_THREAD_KEYS_MAX': 74, 'SC_CHARCLASS_NAME_MAX': 45, 'SC_PRIORITIZED_IO': 13, 'SC_PII_INTERNET': 56, 'SC_2_SW_DEV': 51, 'SC_NGROUPS_MAX': 3, 'SC_XOPEN_ENH_I18N': 93, 'SC_XOPEN_CRYPT': 92, 'SC_ULONG_MAX': 117, 'SC_GETPW_R_SIZE_MAX': 70, 'SC_ATEXIT_MAX': 87, 'SC_NPROCESSORS_ONLN': 84, 'SC_SEMAPHORES': 21, 'SC_PII_OSI_CLTS': 64, 'SC_TZNAME_MAX': 6, 'SC_IOV_MAX': 60, 'SC_THREAD_PRIO_PROTECT': 81, 'SC_JOB_CONTROL': 7, 'SC_AIO_MAX': 24, 'SC_NPROCESSORS_CONF': 83, 'SC_ASYNCHRONOUS_IO': 12, 'SC_NL_TEXTMAX': 124, 'SC_INT_MAX': 104, 'SC_ARG_MAX': 0, 'SC_MEMLOCK': 17, 'SC_LINE_MAX': 43, 'SC_PII': 53, 'SC_UINT_MAX': 116, 'SC_AIO_LISTIO_MAX': 23, 'SC_LOGIN_NAME_MAX': 71, 'SC_2_C_VERSION': 96, 'SC_OPEN_MAX': 4, 'SC_MESSAGE_PASSING': 20, 'SC_MB_LEN_MAX': 108, 'SC_DELAYTIMER_MAX': 26, 'SC_XBS5_ILP32_OFFBIG': 126, 'SC_NL_LANGMAX': 120, 'SC_GETGR_R_SIZE_MAX': 69, 'SC_CHILD_MAX': 1, 'SC_TTY_NAME_MAX': 72, 'SC_STREAM_MAX': 5, 'SC_XOPEN_XPG2': 98}
     #+END_SRC

*** 路径相关（兼容所有系统）
**** os. *curdir*
     当前文件夹，等价于os.path.curdir。

     #+BEGIN_SRC python :session
       import os
       os.curdir
       os.path.curdir
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - '.'
     - '.'
     #+END_SRC

**** os. *pardir*
     父文件夹，等价于os.path.pardir。

     #+BEGIN_SRC python :session
       import os
       os.pardir
       os.path.pardir
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - '..'
     - '..'
     #+END_SRC

**** os. *sep*
     操作系统路径间隔符，等价于os.path.sep。

     已知此常量并不足以解析和拼接路径，还得使用os.path.split()和
     os.path.join()。

     #+BEGIN_SRC python :session
       import os
       os.sep
       os.path.sep
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - '/'
     - '/'
     #+END_SRC

**** os. *altsep*
     操作系统额外的路径间隔符，等价于os.path.altsep。如果系统无额外路
     径间隔符，返回None。

     Windows中，为斜杠，sep为反斜杠。

     #+BEGIN_SRC python :session
       import os
       print(os.altsep)
       print(os.path.altsep)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - None
     - None
     #+END_SRC

**** os. *extsep*
     文件名与后缀的连接字符，等价于os.path.extsep。

     #+BEGIN_SRC python :session
       import os
       os.extsep
       os.path.extsep
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - '.'
     - '.'
     #+END_SRC

**** os. *pathsep*
     如$PATH环境变量中用于间隔路径的字符，等价于os.path.pathsep。

     #+BEGIN_SRC python :session
       import os
       os.pathsep
       os.path.pathsep
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - ':'
     - ':'
     #+END_SRC

**** os. *defpath*
     当系统中无环境变量$PATH时，exec*p和spawn*p函数的路径搜索备用，等
     价于os.path.defpath。

     #+BEGIN_SRC python :session
       import os
       os.defpath
       os.path.defpath
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - ':/bin:/usr/bin'
     - ':/bin:/usr/bin'
     #+END_SRC

**** os. *linesep*
     系统换行符。

     *注意* ：在以文本模式写入文件时，不管系统类型，都应使用"\n"，而不
     使用此值。

     #+BEGIN_SRC python :session
       import os
       os.linesep
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - '\n'
     #+END_SRC

**** os. *devnull*
     null设备路径位置，等价于os.path.devnull。

     #+BEGIN_SRC python :session
       import os
       os.devnull
       os.path.devnull
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - '/dev/null'
     - '/dev/null'
     #+END_SRC

**** setdlopenflags()和getdlopenflags()使用的flags （待续）
***** os. *RTLD_LAZY*
***** os. *RTLD_NOW*
***** os. *RTLD_GLOBAL*
***** os. *RTLD_LOCAL*
***** os. *RTLD_NODELETE*
***** os. *RTLD_NOLOAD*
***** os. *RTLD_DEEPBIND*
** 各种函数
*** os. *urandom* (n)
    返回有N个bytes的随机bytes对象，用于加密。
    
    根据系统实现生成随机数据，不可预测，可用于加密应用。随机质量取决于
    系统实现。
    
    Linux中，使用getrandom()系统调用；Unix中，会向/dev/urandom发送请求；
    Windows中，使用CryptGenRandom()系统调用。
    
    如需使用系统提供的随机数字生成器，可使用random.SystemRandom()。
    
* io
* time - 时间获取和格式转换
* argparse - 解析命令行参数、选择和子命令
  argparse模块提供易用的命令行接口。程序定义所需参数后，argparse可解析
  sys.argv获取。argparse模块还可自动生成帮助和使用信息，且当参数无效时
  显示错误信息。

** 例子
   如接受一系列整数获取最大值或和：

   #+BEGIN_SRC python :eval never
    import argparse

    parser = argparse.ArgumentParser(description='处理整数。')
    parser.add_argument('integers', metavar='N', type=int, nargs='+',
                        help='用于加法的整数')
    parser.add_argument('--sum', dest='accumulate', action='store_const',
                        const=sum, default=max,
                        help='整数相加（默认：找到最大值）')

    args = parser.parse_args()
    print(args.accumulate(args.integers))
   #+END_SRC

   如果将上面代码存储在argparse_demo.py中，则：

   #+BEGIN_EXAMPLE python
    $ python3 argparse_demo.py -h
    usage: argparse_demo.py [-h] [--sum] N [N ...]

    处理整数。

    positional arguments:
      N           用于加法的整数

    optional arguments:
      -h, --help  show this help message and exit
      --sum       整数相加（默认：找到最大值）
   #+END_EXAMPLE

   获取最大值或和：

   #+BEGIN_EXAMPLE python
    $ python3 argparse_demo.py  1 2 3     4
    4
    $ python3 argparse_demo.py  1 2 3 4 --sum
    10
   #+END_EXAMPLE
   
   传入错误参数：
   
   #+BEGIN_EXAMPLE python
    $ python3 argparse_demo.py  a b c
    usage: argparse_demo.py [-h] [--sum] N [N ...]
    argparse_demo.py: error: argument N: invalid int value: 'a'
   #+END_EXAMPLE
   
   通过下面各小节来理解上面程序。
   
*** 创建解析器
    第一步为使用argparse创建ArgumentParser对象：

    #+BEGIN_SRC python :eval never
      import argparse
      parse = argparse.ArgumentParser(description='处理整数')
    #+END_SRC

    ArgumentParser对象保有所有将命令行参数转换为Python数据的信息。

*** 添加参数
    使用add_argument()方法向ArgumentParser添加参数。通常情况下，此方法
    告知ArgumentParser对象如何将命令行参数转换为对象。这些信息在使用
    parse_args()方法时用到。

    #+BEGIN_SRC python :eval never
      parser.add_argument('integers', metavar='N', type=int, nargs='+',
                          help='用于加法的整数')
      parser.add_argument('--sum', dest='accumulate', action='store_const',
                          default=max, help='整数加法（默认：找到最大值）')
    #+END_SRC

    随后，调用parse_args()方法时，会返回一个有integers和accumulate属性
    的对象。integers属性可为1个或多个整数；如果使用了--sum选项，则
    accumulate属性为sum()函数，否则为max()函数。

*** 解析参数
    解析参数使用parse_args()方法。检查命令行参数，将每个参数转换为适当
    的类型并执行行为。大多数情况下，会根据解析的命令行参数转换成的对象
    生成一个Namespace对象。

    #+BEGIN_SRC python :eval never
      args = parse.parse_args()
    #+END_SRC

    在脚本中，parse_args()一般不带参数，ArgumentParser会通过sys.argv自
    动判断命令行参数。

** ArgumentParser对象
*** class argparse. *ArgumentParser* (pron=None,usage=None,description=None,epilog=None,parents=[],formatter_class=argparse.HelpFormatter,prefix_chars='-',fromfile_prefix_chars=None,argument_default=None,conflict_handler='error',add_help=True,allow_abbrev=True)
    创建ArgumentParser对象。所有参数都需使用关键字参数方式传递。各个参
    数的简要描述为：
    
    - prog： 程序名称（默认值：sys.argv[0]）。
    - usage：描述程序用法的字符串（默认值：通过添加到parser的参数自动
      生成）。
    - description：显示在帮助内容前的文本（默认值：None）。
    - epilog：显示在帮助内容后的文本（默认值：None）。
    - parents：由ArgumentParser对象组成的链表，用来包含其中每个元素的
      参数。
    - formatter_class：用来定制帮助内容输出的类。
    - prefix_chars：可选参数前缀字符（默认值：“-”）。
    - fromfile_prefix_chars：一组字符。用于指定读取其他参数的前缀文件。
      （默认值：None）。
    - argument_default：所有参数的全局默认值（默认值：None）。
    - conflict_handler：可选参数冲突时的解决方法（通常没必要）。
    - allow_abbrev：如果选项缩写明确，允许生成缩写选项（默认值：True）。
    - add_help：自动添加-h/--help选项（默认值：True）。
      
**** prog
     ArgumentParser对象默认使用sys.argv[0]作为帮助输出的程序名。比如有
     argparse_demo_prog.py程序:

     #+BEGIN_SRC python :eval never
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo', help='foo help')
       parser.print_help()
     #+END_SRC

     不管在哪个路径下，都使用argparse_demo_prog.py作为程序名：

     在声明ArgumentParser对象时，也可手动声明prog参数来指定：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(prog='argparse_demo_prog')
       parser.print_help()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> usage: argparse_demo_prog [-h]
     - optional arguments:
     -   -h, --help  show this help message and exit
     #+END_SRC

     不管是自动获取自sys.argv[0]，还是prog=参数，在帮助文本中都可使用
     “%(prog)s”获取其名称：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(prog='myprog')
       parser.add_argument('--foo', help='foo of the %(prog)s program')
       parser.print_help()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help='foo of the %(prog)s program', metavar=None)
     - usage: myprog [-h] [--foo FOO]
     - optional arguments:
     -   -h, --help  show this help message and exit
     -   --foo FOO   foo of the myprog program
     #+END_SRC

**** usage
     默认情况下，ArgumentParser会根据包含的参数计算：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(prog='PROG')
       parser.add_argument('--foo', nargs='?', help='foo help')
       parser.add_argument('bar', nargs='+', help='bar help')
       parser.print_help()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs='?', const=None, default=None, type=None, choices=None, help='foo help', metavar=None)
     - _StoreAction(option_strings=[], dest='bar', nargs='+', const=None, default=None, type=None, choices=None, help='bar help', metavar=None)
     - usage: PROG [-h] [--foo [FOO]] bar [bar ...]
     - positional arguments:
     -   bar          bar help
     - optional arguments:
     -   -h, --help   show this help message and exit
     -   --foo [FOO]  foo help
     #+END_SRC
     
     可使用USAGE参数重置：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(prog='PROG', usage='%(prog)s [options]')
       parser.print_help()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> usage: PROG [options]
     - optional arguments:
     -   -h, --help  show this help message and exit
     #+END_SRC
     
**** description
     通常情况下都会使用此参数。用来简要描述程序作用及原理。在帮助信息
     中，输出在命令行选项用法和帮助信息之间：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(description='这是一个没用的程序')
       parser.print_help()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> usage: [-h]
     - 这是一个没用的程序
     - optional arguments:
     -   -h, --help  show this help message and exit
     #+END_SRC
     
     默认情况下，如果过长会自动折叠。参考formatter_class参数定制。
     
**** epilog
     显示在帮助信息最后。

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(
           description='没用的程序',
           epilog='在最后'
       )
       parser.print_help()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - ... ... ... >>> usage: [-h]
     - 没用的程序
     - optional arguments:
     -   -h, --help  show this help message and exit
     - 在最后
     #+END_SRC

     同description参数一样，如果过长会折叠，可使用formatter_class参数
     定制。

**** parents
     允许多个parser可能共享一组参数。避免重复定义这些参数，可将此参数
     值链表中所有ArgumentParser的必选和可选参数添加到当前参数中：

     #+BEGIN_SRC python :session
       import argparse

       parent_parser = argparse.ArgumentParser(add_help=False)
       parent_parser.add_argument('--parent', type=int)

       foo_parser = argparse.ArgumentParser(parents=[parent_parser])
       foo_parser.add_argument('foo')
       foo_parser.parse_args(['--parent', '2', 'XXX'])

       bar_parser = argparse.ArgumentParser(parents=[parent_parser])
       bar_parser.add_argument('--bar')
       bar_parser.parse_args(['--bar', 'YYY'])
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> _StoreAction(option_strings=['--parent'], dest='parent', nargs=None, const=None, default=None, type=<class 'int'>, choices=None, help=None, metavar=None)
     - >>> >>> _StoreAction(option_strings=[], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - Namespace(foo='XXX', parent=2)
     - >>> >>> _StoreAction(option_strings=['--bar'], dest='bar', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - Namespace(bar='YYY', parent=None)
     #+END_SRC

     *注意* ：如需作为parent，则其属性add_help须为False。否则当前的
     ArgumentParser对象会认为有2个-h/--help选项，从而抛出错误。

     *注意* ：作为parent的ArgumentParser需在所有parents参数内容前完全
     实现，在实现子parser后再修改父parser不会反应在子parser中。

**** formatter_class
     ArgumentParser对象的帮助文本可使用下面4个类定制：
     
     - class argparse. *RawDescriptionHelpFormatter*
     - class argparse. *RawTextHelpFormatter*
     - class argparse. *ArgumentDefaultsHelpFormatter*
     - class argparse. *MetavarTypeHelpFormatter*
       
     RawDescriptionHelpFormatter和RawTextHelpFormatter用于描述信息输出
     格式。默认情况下，ArgumentParser对象会自动折叠description和epilog
     文本输出：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(
           prog='PROG',
           description='''this description
           was indent weird
               but that is okay''',
           epilog='''
               likewise for this epilog whose whitespace will
           be cleaned up and whose worlds will be wrapped
           across a couple lines'''
       )
       parser.print_help()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - ... ... ... ... ... ... ... ... ... >>> usage: PROG [-h]
     - this description was indent weird but that is okay
     - optional arguments:
     -   -h, --help  show this help message and exit
     - likewise for this epilog whose whitespace will be cleaned up and whose worlds will be wrapped across a couple lines
     #+END_SRC
     
     将FORMATTER_CLASS参数设置为RawDescriptionHelpFormatter使
     DESCRIPTION和EPILOG参数保持原样输出：
     
     #+BEGIN_SRC python :session
       import argparse
       import textwrap
       parser = argparse.ArgumentParser(
           prog='PROG',
           formatter_class=argparse.RawDescriptionHelpFormatter,
           description=textwrap.dedent('''\
           Please do not mess up this text!
           --------------------------------
               I have indented it
               exactly the way
               I want it
       ''')
       )
       parser.print_help()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> ... ... ... ... ... ... ... ... ... ... >>> usage: PROG [-h]
     - Please do not mess up this text!
     - --------------------------------
     -     I have indented it
     -     exactly the way
     -     I want it
     - optional arguments:
     -   -h, --help  show this help message and exit
     #+END_SRC
     
     而RawTextHelpFormatter则是将所有帮助信息文本（含参数描述）用原因
     输出。
     
     ArgumentDefaultsHelpFormatter则是自动添加参数默认信息值：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(
           prog='PROG',
           formatter_class=argparse.ArgumentDefaultsHelpFormatter
       )
       parser.add_argument('--foo', type=int, default=42, help='FOO!')
       parser.add_argument('bar', nargs='*', default=[1, 2, 3], help='BAR!')
       parser.print_help()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - ... ... ... >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=42, type=<class 'int'>, choices=None, help='FOO!', metavar=None)
     - _StoreAction(option_strings=[], dest='bar', nargs='*', const=None, default=[1, 2, 3], type=None, choices=None, help='BAR!', metavar=None)
     - usage: PROG [-h] [--foo FOO] [bar [bar ...]]
     - positional arguments:
     -   bar         BAR! (default: [1, 2, 3])
     - optional arguments:
     -   -h, --help  show this help message and exit
     -   --foo FOO   FOO! (default: 42)
     #+END_SRC

     MetavarTypeHelpFormatter则是使用add_argument的type参数作为帮助信
     息中的参数值。（而不是通常情况下的dest值）：

     *注意* ：使用此值后，所有add_argument中都需指定type值。

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(
           prog='PROG',
           formatter_class=argparse.MetavarTypeHelpFormatter
       )
       parser.add_argument('--foo', type=int)
       parser.add_argument('bar', type=float)
       parser.print_help()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - ... ... ... >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=<class 'int'>, choices=None, help=None, metavar=None)
     - _StoreAction(option_strings=[], dest='bar', nargs=None, const=None, default=None, type=<class 'float'>, choices=None, help=None, metavar=None)
     - usage: PROG [-h] [--foo int] float
     - positional arguments:
     -   float
     - optional arguments:
     -   -h, --help  show this help message and exit
     -   --foo int
     #+END_SRC

**** prefix_chars
     绝大多数命令行选项使用“-”作为前缀，如“-f/--foo”。如需使其他前缀合
     法，可定制PREFIX_CHARS参数：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(prog='PROG', prefix_chars='-+')
       parser.add_argument('+f')
       parser.add_argument('--bar')
       parser.parse_args('+f X --bar Y'.split())
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> _StoreAction(option_strings=['+f'], dest='f', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - _StoreAction(option_strings=['--bar'], dest='bar', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - Namespace(bar='Y', f='X')
     #+END_SRC

     *注意* ：PREFIX_CHARS中需包含“-”，否则会使“-f/--foo”非法。

**** fromfile_prefix_chars
     如果命令行参数过程，可置于文件中。指定FROMFILE_PREFIX_CHARS一个特
     殊符号，则所有以此特殊符号开始的参数都会作为从文件中获取：

     #+BEGIN_SRC python :session
       import argparse
       with open('files/args.txt', 'w') as fp:
           fp.write('-f\nbar')

       parser = argparse.ArgumentParser(fromfile_prefix_chars='@')
       parser.add_argument('-f')
        parser.parse_args(['-f', 'foo', '@files/args.txt'])
       # 相当于：
       # parser.parse_args(['-f', 'foo', '-f', 'bar'])
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - ... ... 6
     - >>> _StoreAction(option_strings=['-f'], dest='f', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - ... ... Namespace(f='bar')
     #+END_SRC

     *注意* ：文件中，选项和参数需保证每行一个。

**** argument_default
     通常情况下，为参数设置默认值可在add_argument()方法中传递默认值，
     或使用ArgumentParser对象的set_defaults()方法。但也可以通过设置
     ARGUMENT_DEFAULT参数实现为所有命令行参数。如抑制所有没传递的参数：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)
       parser.add_argument('--foo')
       parser.add_argument('bar', nargs='?')
       parser.parse_args('--foo 1 BAR'.split())
       parser.parse_args([])
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default='==SUPPRESS==', type=None, choices=None, help=None, metavar=None)
     - _StoreAction(option_strings=[], dest='bar', nargs='?', const=None, default='==SUPPRESS==', type=None, choices=None, help=None, metavar=None)
     - Namespace(bar='BAR', foo='1')
     - Namespace()
     #+END_SRC

**** allow_abbrev
     默认情况下，parse_args()方法会自动匹配缩写的选项。如需禁用此功能，
     可将ALLOW_ABBREV设置为False。

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foobar', action='store_true')
       parser.add_argument('--foonley', action='store_true')
       parser.parse_args(['--foon'])
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreTrueAction(option_strings=['--foobar'], dest='foobar', nargs=0, const=True, default=False, type=None, choices=None, help=None, metavar=None)
     - _StoreTrueAction(option_strings=['--foonley'], dest='foonley', nargs=0, const=True, default=False, type=None, choices=None, help=None, metavar=None)
     - Namespace(foobar=False, foonley=True)
     #+END_SRC

**** conflict_handler
     默认情况下，不允许选项重复，否则抛出错误：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(prog='PROG')
       parser.add_argument('-f', '--foo', help='old foo help')
       parser.add_argument('--foo', help='new foo help')
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['-f', '--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help='old foo help', metavar=None)
     - Traceback (most recent call last):
     -   File "<stdin>", line 1, in <module>
     -   File "/usr/lib/python3.5/argparse.py", line 1353, in add_argument
     -     return self._add_action(action)
     -   File "/usr/lib/python3.5/argparse.py", line 1716, in _add_action
     -     self._optionals._add_action(action)
     -   File "/usr/lib/python3.5/argparse.py", line 1557, in _add_action
     -     action = super(_ArgumentGroup, self)._add_action(action)
     -   File "/usr/lib/python3.5/argparse.py", line 1367, in _add_action
     -     self._check_conflict(action)
     -   File "/usr/lib/python3.5/argparse.py", line 1506, in _check_conflict
     -     conflict_handler(action, confl_optionals)
     -   File "/usr/lib/python3.5/argparse.py", line 1515, in _handle_conflict_error
     -     raise ArgumentError(action, message % conflict_string)
     - argparse.ArgumentError: argument --foo: conflicting option string: --foo
     #+END_SRC

     如需覆盖久的选项字符串，可将conflict_handler参数设置为'resolve'：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(prog='PROG', conflict_handler='resolve')
       parser.add_argument('-f', '--foo', help='old foo help')
       parser.add_argument('--foo', help='new foo help')
       parser.print_help()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['-f', '--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help='old foo help', metavar=None)
     - _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help='new foo help', metavar=None)
     - usage: PROG [-h] [-f FOO] [--foo FOO]
     - optional arguments:
     -   -h, --help  show this help message and exit
     -   -f FOO      old foo help
     -   --foo FOO   new foo help
     #+END_SRC

     可见，覆盖了第一个选项的“--foo”，使第二个选项的“--foo”生效。

**** add_help
     默认情况下，会自动添加“-h/--help”选项。如需禁用，可设置ADD_HELP参
     数为False：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(add_help=False)
       parser.add_argument('--foo', help='foo help')
       parser.print_help()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help='foo help', metavar=None)
     - usage: [--foo FOO]
     - optional arguments:
     -   --foo FOO  foo help
     #+END_SRC

     如果设置PREFIX_CHAR参数，且其中不含“-”，“-h/--help”默认使用第一个
     字符作为前缀：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(prefix_chars='#+')
       parser.print_help()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> usage: [#h]
     - optional arguments:
     -   #h, ##help  show this help message and exit
     #+END_SRC
     
** add_argument()方法
*** ArgumentParser. *add_argument* (name of flags...[,action][,nargs][,const][,default][,type][,choices][,required][,help][,metavar][,dest])
    定义如歌解析单个命令行参数。各参数简要描述如下：
    
     - name or flags： 一个或多个字符串。如“foo”、“--foo”或“-f”
     - action：当命令行中出现此参数时的基本操作。
     - nargs：指定消耗的命令行参数个数。
     - const：action和nargs指定后，所需的常量。
     - default：如果命令行缺省对应参数的默认值。
     - type：命令行中参数转换成的Python类型。
     - choices：指定命令行中只能出现的参数。
     - required：命令行中此选项是否必须（只对可选选项有效）。
     - help：对此选项的简要描述。
     - metavar：在“Usage”信息中此选项的名字。
     - dest：parse_args()返回值对应的属性。
       
     下面为详细介绍：
     
**** name或flags
     一个或单个字符串，以“-”前缀开始时表示命令行可选参数，无前缀表示命
     令行必选参数。

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('-f', '--foo')
       parser.add_argument('bar')
       parser.parse_args(['BAR'])
       parser.parse_args('BAR --foo FOO'.split())
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> _StoreAction(option_strings=['-f', '--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - _StoreAction(option_strings=[], dest='bar', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - Namespace(bar='BAR', foo=None)
     - Namespace(bar='BAR', foo='FOO')
     #+END_SRC

**** action
     指定对命令行参数的操作。可对命令行参数进行任意操作，但将其作为
     parse_args()方法的返回值属性为最常用操作。ACTION对应的字符串指定
     操作类型：
     
     - store：存储参数值，为默认操作：
       
       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser()
         parser.add_argument('--foo')
         parser.parse_args('--foo 1'.split())
       #+END_SRC
       
       #+RESULTS:
       #+BEGIN_SRC org
       - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - Namespace(foo='1')
       #+END_SRC
       
     - store_const：存储CONST参数指定的值。常用于可选参数：
       
       #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo', action='store_const', const=42)
       parser.parse_args(['--foo'])
       #+END_SRC
       
       #+RESULTS:
       #+BEGIN_SRC org
       - >>> _StoreConstAction(option_strings=['--foo'], dest='foo', nargs=0, const=42, default=None, type=None, choices=None, help=None, metavar=None)
       - Namespace(foo=42)
       #+END_SRC
       
     - store_true和store_false：是store_const的特殊形式，分别存储True
       和False。
       
       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser()
         parser.add_argument('--foo', action='store_true')
         parser.add_argument('--bar', action='store_false')
         parser.add_argument('--baz', action='store_false')
         parser.parse_args('--foo --bar'.split())
       #+END_SRC
       
       #+RESULTS:
       #+BEGIN_SRC org
       - >>> >>> _StoreTrueAction(option_strings=['--foo'], dest='foo', nargs=0, const=True, default=False, type=None, choices=None, help=None, metavar=None)
       - _StoreFalseAction(option_strings=['--bar'], dest='bar', nargs=0, const=False, default=True, type=None, choices=None, help=None, metavar=None)
       - _StoreFalseAction(option_strings=['--baz'], dest='baz', nargs=0, const=False, default=True, type=None, choices=None, help=None, metavar=None)
       - Namespace(bar=False, baz=True, foo=True)
       #+END_SRC
       
       *注意* ：如果缺省对应命令行选项，对应值为相反值，即True得到
       False，反之亦然。
       
     - append：命令行中多次使用选项时，将参数集中到一个链表中：
       
       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser()
         parser.add_argument('--foo', action='append')
         parser.parse_args('--foo 1 --foo 2 --foo 3'.split())
       #+END_SRC
       
       #+RESULTS:
       #+BEGIN_SRC org
       - >>> _AppendAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - Namespace(foo=['1', '2', '3'])
       #+END_SRC
       
     - append_const：将CONST参数指定值集中到一个链表中。常用于将多个命
       令行选项的参数集中到一个链表中：
       
       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser()
         parser.add_argument('--str', dest='types', action='append_const', const=str)
         parser.add_argument('--int', dest='types', action='append_const', const=int)
         parser.parse_args('--int --str'.split())
         parser.parse_args(['--int'])
       #+END_SRC
       
       #+RESULTS:
       #+BEGIN_SRC org
       - >>> _AppendConstAction(option_strings=['--str'], dest='types', nargs=0, const=<class 'str'>, default=None, type=None, choices=None, help=None, metavar=None)
       - _AppendConstAction(option_strings=['--int'], dest='types', nargs=0, const=<class 'int'>, default=None, type=None, choices=None, help=None, metavar=None)
       - Namespace(types=[<class 'int'>, <class 'str'>])
       - Namespace(types=[<class 'int'>])
       #+END_SRC
       
     - count：计数命令行中选项出现的次数：
       
       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser()
         parser.add_argument('--verbose', '-v', action='count')
         parser.parse_args(['-vvvv', '-v'])
       #+END_SRC
       
       #+RESULTS:
       #+BEGIN_SRC org
       - >>> _CountAction(option_strings=['--verbose', '-v'], dest='verbose', nargs=0, const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - Namespace(verbose=5)
       #+END_SRC
       
     - help：？？？
       
     - version：打印版本信息：
       
       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser(prog='PROG')
         parser.add_argument('--version', action='version', version='%(prog)s 2.0')
         parser.parse_args(['--version'])
       #+END_SRC

     如需定制action，可将此参数值设置为Action的子类或有相同接口的对象。
     建议方法是重置Action的__call__和__init__方法：
     
     #+BEGIN_SRC python :session
       import argparse

       class FooAction(argparse.Action):
           def __init__(self, option_strings, dest, nargs=None, **kwargs):
               if nargs is not None:
                   raise ValueError('nargs not allowed')
               super(FooAction, self).__init__(option_strings, dest, **kwargs)
           def __call__(self, parser, namespace, values, option_string=None):
               print('{} {} {}'.format(namespace, values, option_string))
               setattr(namespace, self.dest, values)

       parser = argparse.ArgumentParser()
       parser.add_argument('--foo', action=FooAction)
       parser.add_argument('bar', action=FooAction)
       args = parser.parse_args('1 --foo 2'.split())
       print(args)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> ... ... ... ... ... ... ... ... >>> >>> >>> FooAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - FooAction(option_strings=[], dest='bar', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - Namespace(bar=None, foo=None) 1 None
     - Namespace(bar='1', foo=None) 2 --foo
     - Namespace(bar='1', foo='2')
     #+END_SRC

**** nargs
     默认情况下，一个命令行选项只消耗一个命令行参数，使用NARGS参数可指
     定单个选项消耗的参数个数。可选值为：
     
     - N（整数）。将N和参数集中到一起：
       
       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser()
         parser.add_argument('--foo', nargs=2)
         parser.add_argument('bar', nargs=1)
         parser.parse_args('--foo a b c'.split())
       #+END_SRC
       
       #+RESULTS:
       #+BEGIN_SRC org
       - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=2, const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - _StoreAction(option_strings=[], dest='bar', nargs=1, const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - Namespace(bar=['c'], foo=['a', 'b'])
       #+END_SRC
       
       *注意* ：nargs=1时是生成单个参数组成的链表，区别与默认时将选项
       直接作为指。
       
     - ?：可消耗一个命令行参数，或不消耗命令行选项，生成单个选项值（不
       为链表）。如果没消耗命令行选项，使用DEFAULT参数值。如果为可选选
       项，且没消耗命令行参数，则使用CONST参数值：
       
       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser()
         parser.add_argument('--foo', nargs='?', const='c', default='d')
         parser.add_argument('bar', nargs='?', default='d')
         parser.parse_args('XX --foo YY'.split())
         parser.parse_args('XX --foo'.split())
         parser.parse_args([])
       #+END_SRC
       
       #+RESULTS:
       #+BEGIN_SRC org
       - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs='?', const='c', default='d', type=None, choices=None, help=None, metavar=None)
       - _StoreAction(option_strings=[], dest='bar', nargs='?', const=None, default='d', type=None, choices=None, help=None, metavar=None)
       - Namespace(bar='XX', foo='YY')
       - Namespace(bar='XX', foo='c')
       - Namespace(bar='d', foo='d')
       #+END_SRC
       
     “nargs='?'”的常用方法为允许必选命令行选项中的文件参数缺省：
     
     #+BEGIN_SRC python :session
       import argparse
       import sys
       parser = argparse.ArgumentParser()
       parser.add_argument('infile', nargs='?',
                           type=argparse.FileType('r'), default=sys.stdin)
       parser.add_argument('outfile', nargs='?',
                           type=argparse.FileType('w'), default=sys.stdout)
       parser.parse_args(['files/input.txt', 'files/output.txt'])
       parser.parse_args([])
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> ... _StoreAction(option_strings=[], dest='infile', nargs='?', const=None, default=<_io.TextIOWrapper name='<stdin>' mode='r' encoding='UTF-8'>, type=FileType('r'), choices=None, help=None, metavar=None)
     - ... _StoreAction(option_strings=[], dest='outfile', nargs='?', const=None, default=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>, type=FileType('w'), choices=None, help=None, metavar=None)
     - Namespace(infile=<_io.TextIOWrapper name='files/input.txt' mode='r' encoding='UTF-8'>, outfile=<_io.TextIOWrapper name='files/output.txt' mode='w' encoding='UTF-8'>)
     - Namespace(infile=<_io.TextIOWrapper name='<stdin>' mode='r' encoding='UTF-8'>, outfile=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)
     #+END_SRC
     
     - *：将所有命令行参数集中到一个链表中：
       
       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser()
         parser.add_argument('--foo', nargs='*')
         parser.add_argument('--bar', nargs='*')
         parser.add_argument('baz', nargs='*')
         parser.parse_args('--foo x y --bar 1 2'.split())
         parser.parse_args('a b --foo x y'.split())
       #+END_SRC
       
       #+RESULTS:
       #+BEGIN_SRC org
       - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs='*', const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - _StoreAction(option_strings=['--bar'], dest='bar', nargs='*', const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - _StoreAction(option_strings=[], dest='baz', nargs='*', const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - Namespace(bar=['1', '2'], baz=[], foo=['x', 'y'])
       - Namespace(bar=None, baz=['a', 'b'], foo=['x', 'y'])
       #+END_SRC
       
     - +：与“*”相同，将所有有效参数集中到链表中。但是至少需一个参数，
       否则抛出错误：
       
       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser()
         parser.add_argument('foo', nargs='+')
         parser.parse_args('a b'.split())
       #+END_SRC

       #+RESULTS:
       #+BEGIN_SRC org
       - >>> _StoreAction(option_strings=[], dest='foo', nargs='+', const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - Namespace(foo=['a', 'b'])
       #+END_SRC

     - argparse.REMAINDER：将剩下的所有命令行参数集中到链表中：

       #+BEGIN_SRC python :session
         import argparse
         parser = argparse.ArgumentParser()
         parser.add_argument('--foo')
         parser.add_argument('command')
         parser.add_argument('args', nargs=argparse.REMAINDER)
         parser.parse_args('--foo B cmd --arg1 XX ZZ'.split())
       #+END_SRC

       #+RESULTS:
       #+BEGIN_SRC org
       - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - _StoreAction(option_strings=[], dest='command', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - _StoreAction(option_strings=[], dest='args', nargs='...', const=None, default=None, type=None, choices=None, help=None, metavar=None)
       - Namespace(args=['--arg1', 'XX', 'ZZ'], command='cmd', foo='B')
       #+END_SRC

     如果没提供NARGS参数，则消耗的命令行参数个数由ACTION参数决定。一般
     情况下，单个命令行选项消耗单个命令行参数，并生成非链表的单个属性
     值。
     
**** const
     此参数最常见的两个用法为：

     - 当ACTION的值为"store_const"或"append_const"时，使用CONST参数的
       值作为parse_args()方法返回对象的属性值。
     - 当NARGS的值为"?"时，如果命令行中无参数，则使用CONST参数的值。

     *注意* ：如果ACTION参数值为"store_const"或"append_const"，必须声
     明CONST关键字参数值。其他ACTION值情况下，其默认值为None。

**** default
     命令行中可选选项和一些必选选项可缺省参数。缺省时，使用DEFAULT参数
     值（默认为None）作为parse_args()方法返回对象的属性值。
     
     对于可选选项，如果命令行中没有参数，使用DEFAULT参数的值：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo', default=42)
       parser.parse_args('--foo 2'.split())
       parser.parse_args([])
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=42, type=None, choices=None, help=None, metavar=None)
     - Namespace(foo='2')
     - Namespace(foo=42)
     #+END_SRC
     
     如果DEFAULT参数值类型为字符串，parse_args()方法会将其等同命令行中
     的参数对待，使用TYPE参数指定的类型对其实现类型转换，否则不管：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--length', default='10', type=int)
       parser.add_argument('--width', default=10.5, type=int)
       parser.parse_args([])
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--length'], dest='length', nargs=None, const=None, default='10', type=<class 'int'>, choices=None, help=None, metavar=None)
     - _StoreAction(option_strings=['--width'], dest='width', nargs=None, const=None, default=10.5, type=<class 'int'>, choices=None, help=None, metavar=None)
     - Namespace(length=10, width=10.5)
     #+END_SRC

     对于必须选项，如果NARGS参数值为"?"或"*"，当无命令行参数时，也使用
     DEFAULT参数值作为默认值：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('foo', nargs='?', default=42)
       parser.parse_args(['a'])
       parser.parse_args()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=[], dest='foo', nargs='?', const=None, default=42, type=None, choices=None, help=None, metavar=None)
     - Namespace(foo='a')
     - Namespace(foo=42)
     #+END_SRC

     如果default=argparse.SUPPRESS，则当命令行中无参数时，parse_args()
     方法返回的对象不具备对于属性：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo', default=argparse.SUPPRESS)
       parser.parse_args([])
       parser.parse_args('--foo 1'.split())
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default='==SUPPRESS==', type=None, choices=None, help=None, metavar=None)
     - Namespace()
     - Namespace(foo='1')
     #+END_SRC

**** type
     ArgumentParser只是将命令行中的参数作为字符串，可在add_argument()
     方法中使用type参数指定类型转换。可为内置类型和接受单个字符串参数
     的函数。如果指定了DEFAULT参数，也会根据type参数对其自动转换类型。
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('foo', type=int)
       parser.add_argument('bar', type=open)
       parser.parse_args('2 files/input.txt'.split())
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=[], dest='foo', nargs=None, const=None, default=None, type=<class 'int'>, choices=None, help=None, metavar=None)
     - _StoreAction(option_strings=[], dest='bar', nargs=None, const=None, default=None, type=<built-in function open>, choices=None, help=None, metavar=None)
     - Namespace(bar=<_io.TextIOWrapper name='files/input.txt' mode='r' encoding='UTF-8'>, foo=2)
     #+END_SRC
     
     为简化文件类型的使用，argparse模块还提供了FileType工厂函数，接受
     与open函数相同的mode、bufsize、encoding和errors参数。如将参数转换
     为可写的文件对象：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('bar', type=argparse.FileType('w'))
       parser.parse_args(['files/output.txt'])
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=[], dest='bar', nargs=None, const=None, default=None, type=FileType('w'), choices=None, help=None, metavar=None)
     - Namespace(bar=<_io.TextIOWrapper name='files/output.txt' mode='w' encoding='UTF-8'>)
     #+END_SRC

     也可为接受单个字符串参数的任意函数：

     #+BEGIN_SRC python :session
       import argparse
       import math

       def perfect_square(string):
           value = int(string)
           sqrt = math.sqrt(value)
           if sqrt != int(sqrt):
               msg = '{} is not a perfect square'.format(string)
               raise argparse.ArgumentError(msg)
           return value

       parser = argparse.ArgumentParser()
       parser.add_argument('foo', type=perfect_square)
       parser.parse_args(['9'])
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> ... ... ... ... ... ... ... >>> >>> _StoreAction(option_strings=[], dest='foo', nargs=None, const=None, default=None, type=<function perfect_square at 0x7ff2678e3158>, choices=None, help=None, metavar=None)
     - Namespace(foo=9)
     #+END_SRC

**** choices
     使用CHOICES参数可限定命令行参数为只为其中的元素。当解析命令行参数
     时，如果不在其中则抛出错误：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('move', choices=['rock', 'paper', 'scissors'])
       parser.parse_args(['rock'])
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=[], dest='move', nargs=None, const=None, default=None, type=None, choices=['rock', 'paper', 'scissors'], help=None, metavar=None)
     - Namespace(move='rock')
     #+END_SRC

     *注意* ：包含测试在类型type指定转换后进行，所有CHOICES中的元素类
     型需与type指定的一致：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('door', type=int, choices=range(1, 4))
       parser.parse_args(['3'])
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=[], dest='door', nargs=None, const=None, default=None, type=<class 'int'>, choices=range(1, 4), help=None, metavar=None)
     - Namespace(door=3)
     #+END_SRC

     任何支持“in”操作的对象都可所谓CHOICES参数的值，即dict、set等都可。

**** required
     一般情况下，name或flags为“-f”或“-bar”形式时表示命令行可选选择，可
     缺省。如需将可选选项设置为必须选项，可设置参数REQUIRED为True：

     *注意* ：最好不要将可选选项转换为必选选项。
     
**** help
     用于简要表示描述命令行选项的字符串，用于使用“-h/--help”时打印：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo', action='store_true', help='foo选项用法')
       parser.add_argument('bar', nargs='+', help='bar选项用法')
       parser.print_help()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreTrueAction(option_strings=['--foo'], dest='foo', nargs=0, const=True, default=False, type=None, choices=None, help='foo选项用法', metavar=None)
     - _StoreAction(option_strings=[], dest='bar', nargs='+', const=None, default=None, type=None, choices=None, help='bar选项用法', metavar=None)
     - usage: [-h] [--foo] bar [bar ...]
     - positional arguments:
     -   bar         bar选项用法
     - optional arguments:
     -   -h, --help  show this help message and exit
     -   --foo       foo选项用法
     #+END_SRC
     
     在字符串中，可使用绝大多数add_argument()方法的参数：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser(prog='PROG')
       parser.add_argument('bar', nargs='?', type=int, default=24,
                           help='程序%(prog)s的选项bar，类型%(type)s， 默认值为%(default)s')
       parser.print_help()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> ... _StoreAction(option_strings=[], dest='bar', nargs='?', const=None, default=24, type=<class 'int'>, choices=None, help='程序%(prog)s的选项bar，类型%(type)s， 默认值为%(default)s', metavar=None)
     - usage: PROG [-h] [bar]
     - positional arguments:
     -   bar         程序PROG的选项bar，类型int， 默认值为24
     - optional arguments:
     -   -h, --help  show this help message and exit
     #+END_SRC

     如需不在“usage”和“help”信息中显示帮助信息，可使用
     argparse.SUPPRESS：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo', help=argparse.SUPPRESS)
       parser.print_help()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help='==SUPPRESS==', metavar=None)
     - usage: [-h]
     - optional arguments:
     -   -h, --help  show this help message and exit
     #+END_SRC

**** metavar
     默认情况下，在显示帮助信息时，使用DEST参数值作为选项参数提示。如
     果为必选选项，直接使用该值；可选选项则使用大写形式：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo')
       parser.add_argument('bar')
       parser.print_help()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - _StoreAction(option_strings=[], dest='bar', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - usage: [-h] [--foo FOO] bar
     - positional arguments:
     -   bar
     - optional arguments:
     -   -h, --help  show this help message and exit
     -   --foo FOO
     #+END_SRC
     
     使用metavar可修改此打印值：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo', metavar='XXX')
       parser.add_argument('bar', metavar='YYY')
       parser.print_help()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar='XXX')
     - _StoreAction(option_strings=[], dest='bar', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar='YYY')
     - usage: [-h] [--foo XXX] YYY
     - positional arguments:
     -   YYY
     - optional arguments:
     -   -h, --help  show this help message and exit
     -   --foo XXX
     #+END_SRC

     修改METAVAR只是改变了打印值，而非DEST的值。

     对于不同的NARGS值，会多次打印METAVAR值，此时可使用元组设置多个打
     印值：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo', nargs=2)
       parser.add_argument('--bar', nargs=2, metavar=('bar', 'baz'))
       parser.print_help()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=2, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - _StoreAction(option_strings=['--bar'], dest='bar', nargs=2, const=None, default=None, type=None, choices=None, help=None, metavar=('bar', 'baz'))
     - usage: [-h] [--foo FOO FOO] [--bar bar baz]
     - optional arguments:
     -   -h, --help     show this help message and exit
     -   --foo FOO FOO
     -   --bar bar baz
     #+END_SRC
     
**** dest
     定制parse_args()方法返回对象的属性名。默认情况下，对于可选选项，
     如果有“--foo”形式，则使用第一个该形式，“foo”作为默认属性名，如果
     没有，则使用第一个“-f”的“f”作为属性名，其中的任何短横线“-”都自动
     转换为“下划线”，以得到合法的属性名；如果为必选选项“bar”形式，则为
     add_argument()方法的第一个参数：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('-f', '--foo-bar', '--foo')
       parser.add_argument('-x', '-y')
       parser.parse_args('-f 1 -x 2'.split())
       parser.parse_args('--foo 1 -y 2'.split())
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['-f', '--foo-bar', '--foo'], dest='foo_bar', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - _StoreAction(option_strings=['-x', '-y'], dest='x', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - Namespace(foo_bar='1', x='2')
     - Namespace(foo_bar='1', x='2')
     #+END_SRC

     使用DEST参数则是定制此属性名：

     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo', dest='bar')
       parser.parse_args('--foo 1'.split())
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='bar', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - Namespace(bar='1')
     #+END_SRC

*** Action - 定制add_argument方法的action参数？？？

** parse_args()方法
*** ArgumentParser. *parse_args* (args=None,namespace=None)
    将命令行参数转换为namespace对象属性，返回namespace对象。
    
    由add_argument()方法决定如何转换命令行参数。
    
    默认情况下，通过sys.argv获取命令行参数，创建全新Namespace对象赋值
    属性。
    
*** 可选语法
    对于可选选项，parse_args()方法支持多种命令行参数形式，最简单的方式
    为选项和参数为各自独立：
    
    #+BEGIN_SRC python :session
      import argparse
      parser = argparse.ArgumentParser()
      parser.add_argument('-x')
      parser.add_argument('--foo')
      parser.parse_args('-x X'.split())
      parser.parse_args('--foo FOO'.split())
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> _StoreAction(option_strings=['-x'], dest='x', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
    - _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
    - Namespace(foo=None, x='X')
    - Namespace(foo='FOO', x=None)
    #+END_SRC
    
    如果为全写形式选项，与参数间可用“=”连接：
    
    #+BEGIN_SRC python :session
      parser.parse_args('--foo=FOO'.split())
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - Namespace(foo='FOO', x=None)
    #+END_SRC

    如果为简写形式的选项，可与参数连写：

    #+BEGIN_SRC python :session
      parser.parse_args(['-xX'])
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - Namespace(foo=None, x='X')
    #+END_SRC

    多个简写形式的选项有默认值，则可连写，只有最后一个必须提供参数值：

    #+BEGIN_SRC python :session
      import argparse
      parser = argparse.ArgumentParser()
      parser.add_argument('-x', action='store_true')
      parser.add_argument('-y', action='store_true')
      parser.add_argument('-z')
      parser.parse_args(['-xyzZ'])
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> _StoreTrueAction(option_strings=['-x'], dest='x', nargs=0, const=True, default=False, type=None, choices=None, help=None, metavar=None)
    - _StoreTrueAction(option_strings=['-y'], dest='y', nargs=0, const=True, default=False, type=None, choices=None, help=None, metavar=None)
    - _StoreAction(option_strings=['-z'], dest='z', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
    - Namespace(x=True, y=True, z='Z')
    #+END_SRC

*** 无效参数
    当parse_args()方法解析命令行时，如果遇到选项不明确、参数类型不正确、
    必选选项参数个数不正确等会抛出错误，打印错误及使用方法：

    #+BEGIN_SRC python :eval never
      import argparse
      parser = argparse.ArgumentParser()
      parser.add_argument('--foo', type=int)
      parser.add_argument('bar', nargs='?')

      # 参数类型不正确
      parser.parse_args('--foo spam'.split())
      # 选项错误
      parser.parse_args(['--bar'])
      # 参数个数不正确
      parser.parse_args('spam badger'.split())
    #+END_SRC

*** 参数包含 - 短横线（“-”）？？？
*** 参数缩写（前缀匹配）
    如果缩写明确，parse_args()解析命令行选项时允许缩写。可将
    ArgumentParser的参数allow_abbrev设置成False取消此功能：

    #+BEGIN_SRC python :session
      import argparse
      parser = argparse.ArgumentParser()
      parser.add_argument('--bacon')
      parser.add_argument('--badger')
      parser.parse_args('--bac MMM'.split())
      parser.parse_args('--bad WOOD'.split())

      # 缩写不明确，不能正确解析
      # parser.parse_args('--ba BA'.split())
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> _StoreAction(option_strings=['--bacon'], dest='bacon', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
    - _StoreAction(option_strings=['--badger'], dest='badger', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
    - Namespace(bacon='MMM', badger=None)
    - Namespace(bacon=None, badger='WOOD')
    #+END_SRC

*** sys.argv之外
    普通用法中，一般parse_args()方法都不带参数，直接解析命令行，即
    sys.argv。上面所有例子中为演示方便，都是直接提供链表模仿命令行。此
    方法在测试时很有用：

    #+BEGIN_SRC python :session
      import argparse
      parser = argparse.ArgumentParser()
      parser.add_argument(
          'integers', nargs='+', metavar='int', type=int,
          choices=range(10), help='0-9间的整数'
      )
      parser.add_argument(
          '--sum', dest='accumulate', action='store_const', const=sum,
          default=max, help='将整数相加（默认：找到最大值）'
      )
      parser.parse_args('1 2 3 4'.split())
      parser.parse_args('1 2 3 4 --sum'.split())
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> ... ... ... _StoreAction(option_strings=[], dest='integers', nargs='+', const=None, default=None, type=<class 'int'>, choices=range(0, 10), help='0-9间的整数', metavar='int')
    - ... ... ... _StoreConstAction(option_strings=['--sum'], dest='accumulate', nargs=0, const=<built-in function sum>, default=<built-in function max>, type=None, choices=None, help='将整数相加（默认：找到最大值）', metavar=None)
    - Namespace(accumulate=<built-in function max>, integers=[1, 2, 3, 4])
    - Namespace(accumulate=<built-in function sum>, integers=[1, 2, 3, 4])
    #+END_SRC

*** Namespace对象
**** class argparse. *Namespace*
     parse_args()方法使用的一个简单的类，创建来保存属性并返回。
     
     此类仅是object的一个子类。如需将其转换为字典，可使用内置函数
     vars()：
     
     #+BEGIN_SRC python :session
       import argparse
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo')
       args = parser.parse_args('--foo BAR'.split())
       vars(args)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - >>> {'foo': 'BAR'}
     #+END_SRC

     如需将解析结果添加到已有对象上，可使用NAMESPACE参数：

     #+BEGIN_SRC python :session
       import argparse

       class C:
           pass

       c = C()
       parser = argparse.ArgumentParser()
       parser.add_argument('--foo')
       parser.parse_args(args='--foo BAR'.split(), namespace=c)
       vars(c)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> ... ... >>> >>> >>> >>> _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - <__main__.C object at 0x7fdbe6213780>
     - {'foo': 'BAR'}
     #+END_SRC

** 其他用法 （待续）
*** 子命令
*** FileType对象
*** 参数分组
*** 共有排除（Mutual exclusion）
*** Parser defaults
*** Printing help
*** Partial parsing
*** Customizing file parsing
*** Exiting methods
** 更新argparse （待续）
* getopt
  
  #+BEGIN_QUOTE
  *注意* ：此模块的功能也是解析命令行，只是使用了与C的getopt()函数相同
  的API。如果不属性C的getopt()函数，或不想多写代码，可使用argparse模块。
  #+END_QUOTE
  
* logging
* logging.config
* logging.handlers
* getpass
* curses
* curses.textpad
* curses.ascii
* curses.panel
* platform
* errno
* ctypes
