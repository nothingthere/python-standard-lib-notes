#+TITLE: 内置类型

* 真假判断
  除下面情况外都为True：
  - None
  - False
  - 任何形式的数值0，如0、0.0、0j。
  - 空的sequence，如''、()、[]。
  - 空的map，如{}。
  - 自定义类中有__bool__和__len()__方法，且实例的此方法返回0或布尔值
    False。

  #+BEGIN_SRC python :session
    class Foo:
        def __init__(self, num):
            self.num = num
        def __bool__(self):
            return bool(self.num)

    f0 = Foo(0)
    f1 = Foo(1)

    any([None, False, 0, 0.0, 0j, '', [], (), {}, f0, f2])
    any([f1])
  #+END_SRC

  #+RESULTS[0137abfc43ce548b5c7c5a908abfd134c19ec952]:
  :
  : ... ... ... ... >>> >>> >>> >>> >>> >>> False
  : True

  操作符（Operations）和内置函数如果返回布尔型，要么返回1或True作为
  “真”，要么返回0或False作为“假”。

  *注意* ：or和and操作符总是将其一个operands作为返回值。

* 布尔值操作-and、or、not
  下表按有限级排序：

  | Operation | 结果                                    | 注意 |
  |-----------+-----------------------------------------+------|
  | x or y    | 如果x为false，则返回y，否则返回x        | (1)  |
  | x an y    | 如果x为false，则返回x，否则返回y        | (2)  |
  | not x     | 如果x为false，则返回True，否则返回False | (3)  |

  注意点：

   1. 只有x为假，才计算y。
   2. 只有x为真，才计算y。
   3. 三者中not的优先级最低，所以not a == b相当于not (a == b)，而a ==
      not b为语法错误。

* 比较
  Python有8个比较操作符，优先级相同，不过都比布尔值操作符高。比较操作
  可任意组合，如x < y <= z等价于x < y and y <= z（与C不同），不过y只
  计算一次，且如果x < y 为假，不计算z，直接返回False。

  | 操作符 | 含义         |
  |--------+--------------|
  | <      | 小于         |
  | <=     | 小于等于     |
  | >      | 大于         |
  | >=     | 大于等于     |
  | ==     | 等于         |
  | !=     | 不等于       |
  | is     | 对象完全相同 |
  | is not | 不为相同对象 |

  除不同类型的数字外，所有不同对象之间的比较都返回False。

  除非声明__eq__()方法，相同类的不同实例不相等。

  相同类的不同实例不能排序，除非有定
  义__lt__()、__le__()、__gt__()和__ge__()方法。（如需只进行比较，定
  义__lt__()和__gt__()方法就足够。）

  is和is not不能定制，可接受任意2个对象，从不返回错误。

  in 和 not in两个操作符具有比较操作符的相同优先级，仅支持sequence类
  型。

* 数字类型-int、float、complex
  一共有3种数字类型：整型、浮点型和复数。此外，布尔型是整型的子类型。
  整型大小无限，浮点型通常与C中的double型精度相同（可使用
  sys.float_info变量查看）。复数分实部和虚部（都为浮点型），如果z为复
  数，则可使用z.real和z.image分别获取实部和虚部。数字后添加j或J可转变
  为虚数。

  #+BEGIN_SRC python :session
    import sys
    sys.float_info
  #+END_SRC

  #+RESULTS[a67a42ba1e272f9459d008ec6d22f6d99c5e35e2]:
  :
  : sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)

  Python支持不同的数字类型一起计算。多个类型一起计算时，“窄类型”转换
  为“宽类型”，整型比浮点型窄，浮点型比复数窄。数字之间的比较也使用相
  同方法。

  下表为除复数，所有数字类型都可使用的操作符，按优先级从低到高排序
  （所有数字操作符的优先级都比比较操作符低）。

  | 操作符          | 结果                         | 注意点 | 完整文档  |
  |-----------------+------------------------------+--------+-----------|
  | x + y           | 和                           |        |           |
  | x - y           | 差                           |        |           |
  | x * y           | 积                           |        |           |
  | x / y           | 商                           |        |           |
  | x // y          | x整除y的结果                 | (1)    |           |
  | x % y           | x / y的余值                  | (2)    |           |
  | -x              | 相反数                       |        |           |
  | +x              | 保持不变                     |        |           |
  | abs(x)          | x的绝对值或虚部              |        | abs()     |
  | int(x)          | 将x转换为整型                | (3)(6) | int()     |
  | float(x)        | 将x转换为浮点型              | (4)(6) | float()   |
  | complex(re, im) | 生成复数，img虚数部分默认为0 | (6)    | complex() |
  | c.conjugate()   | 复数c的共轭？                |        |           |
  | divmode(x, y)   | 相当于tuple(x // y, x % y)   | (2)    | divmode() |
  | pow(x, y)       | x的y次方                     | (5)    | pow()     |
  | x ** y          | x的y次方                     | (5)    |           |

   1. 结果无小数，不一定为整型。结果总是向负的最小值靠近：

	  #+BEGIN_EXAMPLE python
        >>> 1 // 2
        0
        >>> (-1) // 2
        -1
        >>> 1 // (-2)
        -1
        >>> (-1) // (-2)
        0
	  #+END_EXAMPLE

   2. 不适用于复数，而是使用abs()复数转换为浮点型。？？？

   3. 将浮点型转换为整数时，同C一样会“舍入”。参考math.floor()和
      math.ceil()函数。

   4. 浮点型可接受字符串“nan”和"inf"作为非数字和无限数，前面可带正负号。

   5. 如其他语言一样，Python规定pow(0,0)和0**0的值都为1。

   6. 可使用0-9和任何Unicode等价的字符。？？

   所有numbers.Real类型（即int和float类型）还可接受如下操作：

   | 操作          | 结果                                                  |
   |---------------+-------------------------------------------------------|
   | math.trunc(x) | 去除小数点后面内容                                    |
   | round(x[,n])  | 小数点后n个数，如果无第二个参数，相当于正真的四舍五入 |
   | math.floor(x) | <=x 的最大整数                                        |
   | math.ceil(x)  | >=x 的最小整数                                        |

** 整数位运算
   位运算只适用于整数。负数进行位运算时取反补码（以保证足够的bit防止
   计算时溢出）。

   位运算操作符优先级高于比较运算符，低于算术运算符；~运算符与加减运
   算符有相同优先级。

   下表为优先级从低到高的的位运算符：

   | 操作     | 结果 | 注意点 |
   |----------+------+--------|
   | x 竖线 y | 或   |        |
   | x ^ y    | XOR  |        |
   | x & y    | 和   |        |
   | x << n   | 左移 | (1)(2) |
   | x >> n   | 右移 | (1)(3) |
   | ~x       | 取反 |        |

	1. n为负数时返回ValueError错误
	2. 位左移相当于没有溢出检查的乘以pow(2,n)
	3. 位右移相当于没有溢出检查的除以pow(2,n)
       
** 整型的额外方法
*** int. *bit_length* ()
	返回以二进制表示整数的位数：

    #+BEGIN_SRC python :session
       n = -37
       bin(n)
       n.bit_length()
    #+END_SRC

    #+RESULTS[8810302f5722bb340d6945ff9942a8590dbc799f]:
     :
     : '-0b100101'
     : 6

	等价于：

	#+BEGIN_SRC python
       def bit_length(self):
           s = bin(self)
           s = s.lstrip('-0b')
           return len(s)
	#+END_SRC

*** int. *to_bytes* (length,byteorder,*,signed=False)
    返回用bytes类型表示的整数。

    LENGTH为byte数量，应足够表示该整数，否则返回OverFlowError错误。

    BYTEODER的取值可为littele或big，前者表示重要byte位于后面，后者表示
    重要byte位于前面。可通过sys.byteorder获取本机相应值：

    #+BEGIN_SRC python :session
      import sys
      sys.byteorder
    #+END_SRC

    #+RESULTS[3d5fd94153b3a2263424e14fd58558248a9ae9ca]:
    :
    : 'little'

    SIGNED参数的含义为是否采用补码（two's complement）方式表示负数。如
    果为False，且整数为负数，则返回OverflowError。所以表示负数时SIGNED
    应为True。SIGNED默认为False。

    #+BEGIN_SRC python :session
      (255).to_bytes(1, byteorder='big', signed=False)
      (-1).to_bytes(2, byteorder='big', signed=True)
      (-1).to_bytes(2, byteorder='big', signed=False)
    #+END_SRC

    #+RESULTS[f8e57b85a7bd068e03b704747c88c41d79387e1a]:
    : b'\xff'
    : b'\xff\xff'
    : Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : OverflowError: can't convert negative int to unsigned

    #+BEGIN_SRC python :session
      (1024).to_bytes(2, byteorder='little')
      (1024).to_bytes(2, byteorder='big')
      (1024).to_bytes(8, byteorder='big')
      (1024).to_bytes(10, byteorder='big')
      (1024).to_bytes(16, byteorder='big')
      (255).to_bytes(1, byteorder='big')
      (256).to_bytes(1, byteorder='big')
    #+END_SRC

    #+RESULTS[3480bdad73607250c656f9be770a4630bcacd447]:
    : b'\x00\x04'
    : b'\x04\x00'
    : b'\x00\x00\x00\x00\x00\x00\x04\x00'
    : b'\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00'
    : b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00'
    : b'\xff'
    : Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : OverflowError: int too big to convert

*** clasmethod int *from_bytes* (bytes,byteorder,*,signed=False)
    BYTES参数须为“类bytes对象”，或生成bytes对象的可迭代对象。

    BYTEORDER和SIGNED参数与to_bytes方法的用法相同。

    #+BEGIN_SRC python :session
      b = b'\x00\x10'

      int.from_bytes(b, byteorder='big')
      int.from_bytes(b, byteorder='little'), pow(2, 12)

      b = b'\xfc\x00'
      int.from_bytes(b, byteorder='big', signed=True)
      int.from_bytes(b, byteorder='big', signed=False)
    #+END_SRC

    #+RESULTS[3fff88f467c24f0fb6eae00705d87950ba57e95a]:
    :
    : >>> 16
    : (4096, 4096)
    : >>> >>> -1024
    : 64512

** 浮点型的额外方法
*** float. *as_integer_ratio* ()
    返回两个整数组成的元素，这两个整数的比率与原浮点数完全相同。

    #+BEGIN_SRC python :session
      (-0.2).as_integer_ratio()
      (1.0).as_integer_ratio()
    #+END_SRC

    #+RESULTS[f517333064b3617d1033e12581eab9467fed88f8]:
    : (-3602879701896397, 18014398509481984)
    : (1, 1)

*** float. *is_integer* ()
    “看起来像整数”则返回True。
    #+BEGIN_SRC python :session
      (-2.0).is_integer()
      (3.2).is_integer()
    #+END_SRC

    #+RESULTS[18894a74b9b2eb36d7fe9951b2c9a4e0ebec73f5]:
    : True
    : False

*** float. *hex* ()
    
    #+BEGIN_SRC python :session
      (1.2).hex()
    #+END_SRC
    
    #+RESULTS[e7a3ff14a7741db43734b976b8425a9dabc240a5]:
    : '0x1.3333333333333p+0'

*** classmethod float. *fromhex* (s)
** numeric类型哈希计算（Hashing）
* Iterator类型
  Python支持在容器（container）外面嵌套一个迭代层。此实现使用了2个不
  同的方法，帮助用户自定义类支持迭代。后面讨论的Sequence总是支持下面
  的迭代方法。

  容器对象需支持container. *__iter__* ()方法提供迭代支持，此方法： 返
  回一个迭代对象。

  迭代对象本身需支持iterator. *__iter__* ()和iterator. *__next__* ()
  方法。

** Generator类型
	如果容器对象有__iter__()方法，且为generator实现，则自动返回迭代对
	象，且支持__iter__()和__next__()方法。

* Sequence类型-list、tuple、range
  3个基本的Sequence类型为：链表、元组和范围。另外两个专门用于处理二进
  制数据（binary date）和文本字符串（text string）Sequence类型在专门
  章节讨论。
** 常用的Sequence操作符
   下表的操作对mutable和immutable都有效。其中s和t都是类型相同的
   Sequence，n、i和j都是整数索引，x？
   
   整个表中的优先级递增。in和not in具有相同的优先级，+和*的优先级同用
   于数字运算一样。
   
   | 操作符               | 结果                               | 注意点 |
   |----------------------+------------------------------------+--------|
   | x in s               | 如果x与s中某个元素equal，返回True  | (1)    |
   | x not in s           | 如果x与s中某个元素equal，返回False | (1)    |
   | s + t                | 将s和t连接                         | (6)(7) |
   | s * n 或 n * s       | 将s复制n次                         | (2)(7) |
   | s[i]                 | s中的第i个元素，第一个元素为s[0]   | (3)    |
   | s[i:j]               | 截取s中第i到j的元素                | (3)(4) |
   | s[i:j:k]             | 截取s中第i到j的元素，跨度为k       | (3)(5) |
   | len(s)               | s的元素个数                        |        |
   | min(s)               | s中最小的元素                      |        |
   | max(s)               | s中最大的元素                      |        |
   | s.index[x[, i[, j]]] | s中第一个x的索引（索引i后，j前）   | (8)    |
   | s.count(x)           | s中x的个数                         |        |
   
   同类型的sequence可做比较。比如链表和元组，为逐个比较其中的元素。即
   两个Sequence相等，则需对应位置的元素相等，且类型相同，长度相等：
   
   #+BEGIN_SRC python :session
     [1, 2, 3] == [1, 2, 3]
     [1, 2, 3] == (1, 2, 3)
   #+END_SRC
   
   #+RESULTS[53ca1bdf37af220736955e12a718c6509d8f0c06]:
   : True
   : False
   
   注意点：
   
	1. in和not in通常用来判断是否包含某元素，不过一些特殊的Sequence，
       如str、bytes和bytearray也可同样使用：
       
    #+BEGIN_SRC python :session
      'gg' in 'egg'
      b'a' in b'abc'
      'a' in b'abc'
    #+END_SRC
    
    #+RESULTS[14b5f1634155ec3e15feeb4aebda2079e4a135fb]:
    : True
    : True
    : Traceback (most recent call last): 
    :   File "<stdin>", line 1, in <module>
    : TypeError: a bytes-like object is required, not 'str'
    
	2. n如果小于0，则作为0对待，即返回相同类型的Sequence，但其中无元素。
       
       #+BEGIN_SRC python :session
          l = [1, 2, 3]
          l * 0
          l * -1
       #+END_SRC
       
       #+RESULTS[a7f3ebdeb4c93a76e0799a5c836d2cb5619ed431]:
       :
       : []
       : []
       
    *注意* ：复制s本身并不是正真复制，而是多次引用原来的元素：
    
    #+BEGIN_SRC python :session
      lists = [[]] * 3
      print(lists)
      lists[0].append(3)
      print(lists)
    #+END_SRC

    #+RESULTS[d58102302c25ac67990798dc71a99e9ec03ae85e]:
     :
     : [[], [], []]
     : >>> [[3], [3], [3]]
    
	3. 如果i或j为负数，则相当于les(s)+i和len(s)+j。

	4. 截取s时，如果没有i，则i相当于0；如果没有j，则j相当于len(s)。如
       果i或j大于len(s)，则默认为len(s)；如果i >= j，则结果中没有任何
       元素。

	5. 使用步数k参数：相当于截取元素i、i+k、i+2k...，直到大于或等于
       j（不包含j）。k值不能为0，如果为None则默认为1。

	6. 拼接immutable类型的Sequence时，会生成新对象。意味着复制自身拼接
       时耗时按次方增加，如需使耗时线性等价可：

	   1. 如果是拼接str对象，可先链表再使用str.join()函数合成字符串；
          或者将其写入一个io.StringIO实例，最后再获取。

	   2. 如果拼接bytes对象，可同字符串一样使用bytes.join()函数或
          io.BytesIO；或者使用bytearray，bytearray对象为mutable类型，
          效率更高。

	   3. 如果拼接元组，可转换为链表再操作。

	   4. 对于其他类型，参考相应文档。

	7. 如range这样的对象，不支持拼接和复制。

	8. 如果s中无元素x，则返回ValueError错误。如果有i和j参数，则相当于
       s[i:j].index(x)，只是没有数据复制，且返回索引值相对于sequence的
       起始位置，而非截断的起始位置。

** Immutable Sequence类型
   immutable类型中有，而mutable类型中没有实现的唯一操作是hash()。
   
   此特性可使immutable类型，如元组，可作为字典(dict)的key值，或作为
   set或frozenset的元素。
   
   #+BEGIN_SRC python :session
     hash((1, 2, 3))
   #+END_SRC
   
   如果尝试hash含unhashable元素的immutable类型，则返回TypeError错误。
   如：
   
   #+BEGIN_SRC python :session
     hash(([1, 2], 3))
   #+END_SRC
   
   #+RESULTS[6a128c1614b208c615c076ac9b4fdc89231aa315]:
   : Traceback (most recent call last): 
   :   File "<stdin>", line 1, in <module>
   : TypeError: unhashable type: 'list'
   
** Mutable Sequence类型
   下表为只有mutable类型才有的操作。其中s为mutable类型的实例，t为任何
   可迭代的对象，x?
   
   | 操作              | 结果                                                 | 注意点 |
   |-------------------+------------------------------------------------------+--------|
   | s[i]=x            | 使用x替换s中索引为i的元素                            |        |
   | s[i:j]=t          | 将s中i->j截断替换为可迭代对象t中的内容               |        |
   | del s[i:j]        | 与s[i:j]=[]同                                        |        |
   | s[i:j:k]=t        | 将截断对应位置上的元素逐个替换为t中的元素            | (1)    |
   | del s[i:j:k]      | 将截断s[i:j:k]从s中删除                              |        |
   | s.append(x)       | 将x添加到s末尾，相当于s[len(s):len(s)]=[x]           |        |
   | s.clear()         | 清除s中所有元素，相当于del s[:]                      | (5)    |
   | s.copy            | 复制s，相当于s[:]                                    | (5)    |
   | s.extend(t)或s+=t | 将t中的元素拼接到s后，基本上等价于s[len(s):len(s)]=t |        |
   | s *= n            | s自身复制n次                                         | (6)    |
   | s.insert(i, x)    | 将s中第i个元素变为x，等价于s[i:i]=x                  |        |
   | s.pop([i])        | 返回s中第i个元素，并将其删除                         | (2)    |
   | s.remove(x)       | 将s中出现的第一个x删除                               | (3)    |
   | s.reverse()       | 将s自身逆序。                                        | (4)    |
   
   注意点：
   
	1. t需与截断的长度相等。
       
       #+BEGIN_SRC python :session
          s = [1, 2, 3, 4]
          print(s[0::2])
          s[0::2] = ['a', 'b']
          print(s)
          s[0::2] = ['a', 'b', 'c']
       #+END_SRC
       
       #+RESULTS[1e58544f13894e154d7091d122d872093f579d6d]:
        :
        : [1, 3]
        : >>> ['a', 2, 'b', 4]
        : Traceback (most recent call last): 
        :   File "<stdin>", line 1, in <module>
        : ValueError: attempt to assign sequence of size 3 to extended slice of size 2

	2. 可选参数i默认值为-1，即默认删除最后一个元素。
	3. 如果s中不存在元素x，则返回ValueError错误。
	4. 为逆序大型sequence时的效率考虑，reverse()方法直接将该sequence逆
       序。为提醒使用者，故意不返回逆序后的sequence。
	5. clear()和copy()方法是为了兼容不支持截断的mutable序列类型接口，
       如set和dict。
	6. n为整数，或有__index__()方法的对象。当n<=0时，清空。同上，复制
       自身并不是真正复制，而是复制reference：

       #+BEGIN_SRC python :session
          t = [[1], [2]]
          t *= 2
          print(t)
          t[0].append(1000)
          print(t)
       #+END_SRC

       #+RESULTS[ef737dbf67d1269a29a39f6bc2426bd90792ec54]:
       :
       : >>> [[1], [2], [1], [2]]
       : >>> [[1, 1000], [2], [1, 1000], [2]]

** 链表（List）
   链表为mutable类型的sequence，一般用来存储相同类型的元素。
   
*** class *list* ([iterable])
	构建链表有下面方法：
    
	 - 使用方括号构建空链表。
	 - 使用方括号，指定其中元素4用逗号隔开。如[a]、[a,b,c]。
	 - 或者为[x for x in iterable]的形式。
	 - 或者使用类型构造器：list()或list(iterable)。
       
	 使用最后一种方法，list构造链表时，新生成的链表中元素顺序同原来的
	 iterable相同。iterable可以是sequence、支持迭代的容器、或者是
	 iterator对象。 如果iterable本身就是链表，则是复制其指针，即“浅层
	 复制”。如果没有参数，则返回空链表：
     
     #+BEGIN_SRC python :session
       a = [[1], [2]]
       b = list(a)
       print(a)
       print(b)

       a[0].append(1000)
       print(a)
       print(b)
     #+END_SRC
     
     #+RESULTS[17f994bc42b7147fa28aa69158de0314e9f754a3]:
     :
     : >>> [[1], [2]]
     : [[1], [2]]
     : >>> >>> [[1, 1000], [2]]
     : [[1, 1000], [2]]
     
	 有许多其他操作符可生成链表，如sorted()。
     
	 除上面第一节Sequence通用和第二节mutable类型支持的操作符外，链表还
	 支持sort方法：
     
**** *sort* (*, key=None,reverse=None)
	  元素见比较时，仅能使用“<”比较。如果比较过程中出现语义错误，如“1
	  < 'a'”，则整个排序过程终止（可能将原链表部分排序）。

	  key和reverse参数仅能以关键字参数的形式出现。

	  key参数为接受一个参数的函数，用来指定各元素比较内容，如
	  "key=str.lower"。此函数只在每个元素调用一次。默认值为None，表示
	  不计算每个元素中的key值。

	  如果reverse参数为True，则逆序排序。

	  同reverse函数一样，为保证操作大型sequence时的效率，排序直接改变
	  原来链表，也不返回排序后的链表。（可使用sorted()函数创建一个排序
	  后的新链表实例。）
** 元组（Tuple）
   元组是immutable类型的Sequence；常用来将类型不同的数据存储在一起，
   如内置函数enumarate()的返回的2元素元组；有时也用于存储immutable类
   型的Sequence，如作为set或dict的元素。？

   #+BEGIN_SRC python :session
     e = enumerate([1, 2, 3])
     for i in range(4):
         print(next(e, 'end'))
   #+END_SRC

   #+RESULTS[a2bde2e71d838787de06a4c6aa1d60a37029e796]:
   :
   : ... ... (0, 1)
   : (1, 2)
   : (2, 3)
   : end
   
*** class *tuple* ([iterable])
	构造元组有下面方法：
    
	 - 一对小括号表示空元组：()。
	 - 在原始后面加逗号表示一元素元组，可无小括号：a,或(a,)。
	 - 多个元素间用逗号隔开，可无小括号：a,b,c或(a,b,c)。
	 - 使用内置tuple构造器函数：tuple或tuple(iterable)。
       
	 最后一种方法构造的元组，其元素的顺序与参数iterable中的顺序相同。
	 iterable可为Sequence、支持迭代的容器或iterator对象。如果iterable
	 本来就是元组，则同链表一样，也是复制其reference，如果无参数则生成
	 空元组：
     
     #+BEGIN_SRC python :session
       l = [[1], [2], [3]]
       t = tuple(l)
       print(l)
       print(t)

       l[0].append(100)
       print(l)
       print(t)
     #+END_SRC
     
     #+RESULTS[24c4e8175a011b7d25226ccf417569e120f5af04]:
     :
     : >>> [[1], [2], [3]]
     : ([1], [2], [3])
     : >>> >>> [[1, 100], [2], [3]]
     : ([1, 100], [2], [3])
     
	 *注意* ：实际上是逗号，而非小括号构成的元组。小括号基本可省略，但
	 在造成语义混淆的地方不可少，如f(a,b,c)为函数调用3个参数，二
	 f((a,b,c))则是调用了一个3元素元组参数。
     
	 元组支持前面第一节中，所有Sequence通用操作符。
     
	 对于不同类型元素组成的元组，可使用collections.namedtuple()类型实
	 现通过字符串名称获取索引，比纯数字索引更合适。
     
** 范围（Range）
   range类型为immutable的数字Sequence，常与for语句搭配表示循环次数。
*** class *range* (stop)
*** class *range* (start,stop[,step])
	所有参数都须为整数（内置int类型或有__index__方法的对象）。如果
	无step参数，默认为1；如果无start参数，默认为0；如果step参数为0，
	则返回ValueError错误。下面为range的用法举例：

    #+BEGIN_SRC python :session
       list(range(10))
       list(range(1, 11))
       list(range(0, 30, 5))
       list(range(0, 10, 3))
       list(range(0, -10, -1))
       list(range(0, -10, 1))
       list(range(0))
       list(range(1, 0))
    #+END_SRC

    #+RESULTS[b8870d8540cdec15e1316a334965df02944ffc11]:
     : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
     : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     : [0, 5, 10, 15, 20, 25]
     : [0, 3, 6, 9]
     : [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
     : []
     : []
     : []

	除拼接和复制外，range支持上面第一小节中所有Sequence支持的操作。原
	因为range对象只能表示严格模式的Sequence，拼接和复制会损坏此模式。

	range对象有start、stop和step3属性，分别对应创建时的三个值：

    #+BEGIN_SRC python :session
      r = range(1, 1000, 10)
      print(r.start)
      print(r.stop)
      print(r.step)
    #+END_SRC
    
    #+RESULTS[f9fc1c5f14e3ac7337647f34fb759a95de1b6673]:
    :
    : 1
    : 1000
    : 10
    
	较之链表和元组，range占用内存更小。无论表示序列个数多少，所占内存
	固定：只存储start、stop和step3个值，各元素需要时才计算。
    
	range实现了collections.abc.Sequence ABC，支持元素包含测试，索引查
	找，截断和负截断：
    
    #+BEGIN_SRC python :session
      r = range(1, 10)
      2 in r
      20 in r
      r.index(5)
      r[5]
      r[:5]
      r[-1]
    #+END_SRC

    #+RESULTS[4b45307c89036dddea5d4fb032b6b58603e9644d]:
    :
    : True
    : False
    : 4
    : 6
    : range(1, 6)
    : 9

	使用==和!=判断range是否相等时，同一般Sequence一样，即两者中元素是
	否逐个相等。两个相等的range可有不同的start、stop和step值，如
	range(0) == range(2, 1, 3)。

    #+BEGIN_SRC python :session
      range(0) == range(2, 1, 3)
    #+END_SRC

    #+RESULTS[df3bed9f7e4ec99cbe485b71ad1306ebd36a9b35]:
    : True

* 文本Sequence类型-str
  Python中文本数据使用字符串(str/strings)对象存储。字符串对象为
  immutable类型的Sequence，其中元素为"Unicode code point"。字符串对象
  可用下面方式表示：
  
   - 单引号：'里面可用"双引号"'。
   - 双引号："里面可有'单引号'"。
   - 三引号：'''可以是三个单引号'''，"""也可以是三个双引号"""。
     
   三引号表示的字符串可跨行书写，且保留换行符。
   
   在同一个表达式中，如果字符串间只有空格，则自动拼接：("spam "
   "eggs") == "spam eggs"。
   
   #+BEGIN_SRC python :session
     'eggs ' 'spam' == 'eggs spam'
   #+END_SRC
   
   #+RESULTS[c9d1e6b60697d25e6d5e76a889515f3cb8acaa1e]:
   : True
   
   由于Python并没有字符类型，所以使用索引获得字符串的某个元素时，返回
   值为长度为1的字符串。所以，对于非空字符s，有s[0] == s[0:1]。
   
   由于字符串本身为immutable，为保证效率，可拼接字符串时可使用
   str.join()和io.StringIO方法。
   
   - class *str* (object='')
   - class *str* (object='', encoding='utf-8',errors='strict')
	 返回object的字符串形式。如果无object参数，返回空字符串；否则，返
     回值由下面规则决定：
     
	 如果encoding和errors参数都没有，返回值实际上是object.__str__()方
     法的返回值。对于字符串对象，则是返回该字符串本身；如果
     object无__str__()方法，则是返回调用repr(object)函数的返回值。
     
	 如果encoding和errors中只要出现任意一个，object就须为类bytes对象
     （bytes或bytearray）。此时，str(bytes, encoding, errors)相当于
     bytes.decode(encoding, errors)。
     
   #+BEGIN_SRC python :session
     str(b'abc', 'utf-8') == b'abc'.decode('utf-8')
   #+END_SRC
   
   #+RESULTS[32d4659c20465d044aab338a803a844a420378fc]:
   : True
   
   将bytes对象传递给str()函数，且不带encoding和errors参数时，返回"非
   正式"字符串：
   
   #+BEGIN_SRC python :session
     str(b'Zoot')
     str(b'Zoot', encoding='utf-8')
   #+END_SRC
   
   #+RESULTS[32fd73df225dae34bf6399b38f6dc51ac3e9a583]:
   : "b'Zoot'"
   : 'Zoot'
   
** 字符串方法
   字符串类型支持所有Sequence通用的操作，此外还支持下面列举的操作。

   字符串支持两种格式化方法：str.format()方法，和与C中printf类似的方
   法。
*** str. *capitalize* ()
	返回复制后的字符串，第一个字母大写，其余字母小写。

    #+BEGIN_SRC python :session
      'claudio'.capitalize()
    #+END_SRC

    #+RESULTS[d5f95c7fff1851f22a9d61bf878206b0b5f4ca80]:
    : 'Claudio'

*** str. *casefold* ()
	相当于str.lower()方法。[[http://www.cnblogs.com/zhanmeiliang/p/5988207.html][@爱尔兰时空]]：

	lower()只对'A-Z'有效，不能处理其他语言中小写的问题，如德语中'ß'的
	小写为'ss'：

    #+BEGIN_SRC python :session
      s = 'ß'
      s.lower()
      s.casefold()
    #+END_SRC

    #+RESULTS[0697c4ef3a8e1439fb26555eec81d54e4f776435]:
    :
    : 'ß'
    : 'ss'

*** str. *center* (width[,fillchar])
	将字符串扩展为长度width，原字符串至于中间，空白处使用fillchar字符
	填充（默认为ASCII空格字符），如果width小于或等于len(s)，则返回原
	来字符串：

    #+BEGIN_SRC python :session
      s = 'claudio'
      s.center(10)
      s.center(10, '|')
      s.center(1)
    #+END_SRC

    #+RESULTS[b34234826f548cd7dc3ae6e917ea372e112a11ea]:
    :
    : ' claudio  '
    : '|claudio||'
    : 'claudio'

*** str. *count* (sub[,start[,end]])
	返回字符串sub出现的次数，可指定在截断[start:end]间计算：

    #+BEGIN_SRC python :session
      s = 'banana'
      s.count('an')
      s.count('an', -3)
      s.count('an', 3)
    #+END_SRC

    #+RESULTS[c6e9c6f7614c91601f8268bce67cb034ccde5ff6]:
    :
    : 2
    : 1
    : 1

*** str. *encode* (encoding='utf-8',errors='strict')
	以bytes对象的形式返回字符串编码后的结果。默认编码为utf-8；默认
	errors值为strict，即当出现编码错误时返回UnicodeError错误，其他可
	取值为ignore、replace、xmlcharrefreplace和backslashreplace，以及
	其他通过codecs.register_error()方法寄存的名称。

    #+BEGIN_SRC python :session
      'claudio'.encode()
      '学习'.encode()
    #+END_SRC

    #+RESULTS[90b9e4e1f2822bcabab7dffa1fe415529f2845b9]:
    : b'claudio'
    : b'\xe5\xad\xa6\xe4\xb9\xa0'

*** str. *endswith* (suffix,[,start[,end]])
	如果字符串以suffix结尾返回True，否则返回False。可指定在截断
	[start:end]中计算：

    #+BEGIN_SRC python :session
      'banana'.endswith('na')
      'banana'.endswith('na', 5)
      '香蕉'.endswith('蕉')
    #+END_SRC

    #+RESULTS[fdedc626806beab522f616fa23bce60945428848]:
    : True
    : False
    : True

*** str. *expandtabs* (tabsize=8)
	返回复制后的字符串，其中tab字符使用一个或多个空格替代，可指定一个
	tab字符所占列数：

    #+BEGIN_SRC python :session
      '01\t012\t0123\t01234'.expandtabs()
      '01\t012\t0123\t01234'.expandtabs(4)
    #+END_SRC

    #+RESULTS[5c811a8cf738b66e5eb6517da4244e1c7ca2f24f]:
    : '01      012     0123    01234'
    : '01  012 0123    01234'

*** str. *find* (sub[,start[,end]])
	返回从左到右起，sub出现在字符串中的索引，可指定在截断[start:end]
	中计算，如果无sub字符串出现，则返回-1。

    #+BEGIN_SRC python :session
      'banana'.find('a')
      'banana'.find('a', 4)
      'banana'.find('a', 19)
    #+END_SRC

    #+RESULTS[d9397cf5feceb92c9230f86b913e32c0fc27863a]:
    : 1
    : 5
    : -1

	为效率考虑，只有需知道sub在字符串中的索引时才使用find()方法，如果
	只是判断是否出现sub，使用in操作符即可：

    #+BEGIN_SRC python :session
      'Py' in 'Python'
      'py' in 'Python'
    #+END_SRC

    #+RESULTS[f0de536f15e64dbeacaf66261e8059886f0fb0da]:
    : True
    : False

*** str. *format* (*args,**kwargs)
	对字符串进行格式化。字符串中可含普通字符，也可含需被替换的place
	holder，用{}表示。{}中可为数字或关键字参数，分别对应format中的
	args和kwargs：

	如需打印大括号本身，使用双层大括号：

    #+BEGIN_SRC python :session
      'the sum of 1 + 2 is {0}'.format(1 + 2)
      'the sum of {a} + {b} is {0}'.format(1 + 2, a=1, b=2)
      'format中使用{{{{}}}}表示{{}}本身.'.format()
    #+END_SRC

    #+RESULTS[b5afbc7c13efc2e8d2869e68a97d0b0879f36beb]:
    : 'the sum of 1 + 2 is 3'
    : 'the sum of 1 + 2 is 3'
    : 'format中使用{{}}表示{}本身.'

*** str. *format_map* (mapping)
	与str.format(***mapping)相同，不过是直接使用mapping，而不是复制到
	dict中。如果mapping本身就是dict的一个子类，则非常方便。？？？：

    #+BEGIN_SRC python :session
      d = {'name': 'Claudio'}
      '{name} was born in ?'.format(**d)
      '{name} was born in ?'.format_map(d)

      class Default(dict):
          def __missing(self, key):
              return key

      '{name} was born in ?'.format(**Default(name='Claudio'))
      '{name} was born in ?'.format_map(Default(name='Claudio'))
    #+END_SRC

    #+RESULTS[5660bc8c376ff0e2df9a65871e66b07b291471ea]:
    :
    : 'Claudio was born in ?'
    : 'Claudio was born in ?'
    : >>> >>> ... ... ... >>> >>> 'Claudio was born in ?'
    : 'Claudio was born in ?'

*** str. *index* (sub[,start[,end]])
	同find()方法类似，不过当不能在字符串中找到sub时返回ValueError错误，
	而非-1：

    #+BEGIN_SRC python :session
      'banana'.index('a')
      'banana'.index('A')
    #+END_SRC

    #+RESULTS[d1f99aec023cad1e2df83201b6c18bb4b9be277e]:
    : 1
    : Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : ValueError: substring not found

*** str. *isalnum* ()
	如果字符串不为空，且其中所有字符非数字即"字母"，则返回True：

    #+BEGIN_SRC python :session
      '111'.isalnum()
      '1abc'.isalnum()
      ''.isalnum()
      '11#'.isalnum()
    #+END_SRC

    #+RESULTS[64c759e1c39d76d3bf059fa4eae875f0dc58e9ba]:
    : True
    : True
    : False
    : False

	只要c.isalpha()、c.isdecimal()、c.isdigit()或c.isnumeric()中一个
	返回True，则c.isalnum()就返回True。

*** str. *isalpha* ()
	如果字符串中不为空，且所有字符都为“字母”则返回True。只要Unicode字
	符数据库中认为是"字母"都可。

	*注意* ：不同于Unicode Standard中定义的"Alphabetic"。

    #+BEGIN_SRC python :session
      'a'.isalpha()
      '一'.isalpha()
    #+END_SRC

    #+RESULTS[a642291f6b8b9de18b3c7270c3edee58f4829289]:
    : True
    : True

*** str. *isdecimal* ()
	字符串不为空，且所有字符都是十进制数字符，即所有能用于表示十进制
	数的字符。

    #+BEGIN_SRC python :session
      '1212'.isdecimal()
      '12.2'.isdecimal()
    #+END_SRC

    #+RESULTS[43583aa61fbd503d3184e8ee9697cc11352fcbce]:
    : True
    : False

*** str. *isdigit* ()
	除isdecimal字符外，还包含“compatibility superscript digits”。？？？
*** str. *isidentifier* ()
	如果是Python中合法的identifier（变量名、函数名和类名），则返回
	True：

    #+BEGIN_SRC python :session
      'isidentifier'.isidentifier()
      'is_identifier'.isidentifier()
      'is-identifier'.isidentifier()
      'is2identifier'.isidentifier()
      '_is_idendify'.isidentifier()
      'is_identifier?'.isidentifier()
    #+END_SRC

    #+RESULTS[47ec6e8c215cd5da97416a61af5045e47c381b40]:
    : True
    : True
    : False
    : True
    : True
    : False

	如需判断是否是“保留字”，使用keuword.iskeyword()方法：

	#+BEGIN_EXAMPLE python
       >>> import keyword
       >>> keyword.iskeyword('def')
       True
       >>> keyword.iskeyword('class')
       True
       >>> keyword.iskeyword('name')
       False
       >>> keyword.iskeyword('__init__')
       False
	#+END_EXAMPLE

    #+BEGIN_SRC python :session
      import keyword
      keyword.iskeyword('def')
      keyword.iskeyword('class')
      keyword.iskeyword('__init__')
    #+END_SRC

    #+RESULTS[41997db43a0fe4c570c41715ad478f071347bd36]:
    :
    : True
    : True
    : False

*** str. *islower* ()
	含至少一个有大小写区分的字符，且所有有大小写区别的字符都为小写：

    #+BEGIN_SRC python :session
      'abc'.islower()
      ''.islower()
      'ab三'.islower()
      '三'.islower()
      'ab3'.islower()
    #+END_SRC

    #+RESULTS[b9478b3115cb34d7665feff76ec18f68d49a7c2e]:
    : True
    : False
    : True
    : False
    : True

*** str. *isnumeric* ()？？？
	字符串不为空，且所有字符都为数字字符：

    #+BEGIN_SRC python :session
      '012'.isdigit()
      '0x12'.isdigit()
      '0X12'.isdigit()
    #+END_SRC

    #+RESULTS[59a1298bfa65b97c02eba9800d8d6cb7bdefcd21]:
    : True
    : False
    : False

	*？* ：和isdigit的区别。

*** str. *isprintable* ()
	只含所有可见字符+空格字符，以及空字符串返回True：

    #+BEGIN_SRC python :session
      'a'.isprintable()
      ' '.isprintable()
      ''.isprintable()
      '\n\t'.isprintable()
    #+END_SRC

    #+RESULTS[bb1ef90eea86f098a2d903594e3096f10108cc38]:
    : True
    : True
    : True
    : False

*** str. *isspace* ()
	所有空白字符。

    #+BEGIN_SRC python :session
      ''.isspace()
      ' '.isspace()
      '\n\t'.isspace()
      '\b\v'.isspace()
    #+END_SRC

    #+RESULTS[9699c54afdb2f683e2a23a886401e3966bfc80aa]:
    : False
    : True
    : True
    : False

*** str. *istitle* ()
	含至少一个字符，为标题形式的字符串返回True。

    #+BEGIN_SRC python :session
      ''.istitle()
      'A'.istitle()
      'I Have a Dream!'.istitle()
      'I Have A Dream!'.istitle()
      '我是标题'.istitle()
    #+END_SRC

    #+RESULTS[eb48c8706d34a6b053e0eae5b5c72c6c0b133fe5]:
    : False
    : True
    : False
    : True
    : False

*** str. *isupper* ()
	含至少一个有大小写区分的字符，且所有区分大小写的字符都为大写。
*** str. *join* (iterable)
	使用字符串将iterable中的所有元素拼接，如果任何一个元素不为字符串
	（含bytes类型），则返回Valueerror错误。

    #+BEGIN_SRC python :session
      '|'.join(['a', 'b', 'c'])
      '|'.join([])
      '|'.join(['a', 'b', 3])
    #+END_SRC

    #+RESULTS[c075e66eb2c17aeda663059c9b16d4a34b15ca31]:
    : 'a|b|c'
    : ''
    : Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : TypeError: sequence item 2: expected str instance, int found

*** str. *ljust* (width[,fillchar=' ''])
	返回指定宽带为width，左对齐后的字符串，使用fillchar填充空白字符。
	如果width<=len(s)则返回原来字符串。

    #+BEGIN_SRC python :session
      'claudio'.ljust(10)
      'claudio'.ljust(10, '|')
      'claudio'.ljust(1, '|')
    #+END_SRC

    #+RESULTS[dcb9657934abdb6a91649b27b950df16f0730db4]:
    : 'claudio   '
    : 'claudio|||'
    : 'claudio'

*** str. *lower* ()
	返回复制后的字符串，并将所有有大小写区别的字符转换为小写。
*** str. *lstrip* ([chars])
	返回复制后的字符串，将左边的含chars中字符的所有字符删除，如果参数
	为None，则char默认为' '。

	*注意* ：chars不是前缀，而是单个字符的组合：

    #+BEGIN_SRC python :session
      '   i have a dream   '.lstrip()
      'www.google.com'.lstrip('w.com')
    #+END_SRC

    #+RESULTS[a8e1dc00f6da29a29748f54e695f3b1dc4aa4642]:
    : 'i have a dream   '
    : 'google.com'

*** static str. *maketrans* (x[,y[,z]])
	此方法为静态方法。作用是返回一个用于str.translate()方法翻译字符串
	的字典类型。

	如果只有一个参数，则须为字典型，key值可为单个字符字符串或Unocide
	值，value值可为单个字符字符串、Unicode值，任意长度字符串或None。

	如果是两个参数，则须为长度相等的字符串，对应位置的字符分别成为生
	成字典的key值和value值。

	如果是三个参数，最后一个参数需为字符串，其中的字符为会成为生成字
	典的key值，对应的value值则为None，即使用str.translate()方法时将删
	除的字符：

    #+BEGIN_SRC python :session
      str.maketrans({'1': '一'})
      str.maketrans("123456789", '一二三四五六七八九')
      str.maketrans("123456789", '一二三四五六七八九', '0')
    #+END_SRC

    #+RESULTS[75c947fec4f31fd9ba3d5798910f73edebc9a61e]:
    : {49:     '一'}
    : {49:     19968, 50: 20108, 51: 19977, 52: 22235, 53: 20116, 54: 20845, 55: 19971, 56: 20843, 57: 20061}
    : {48:     None, 49: 19968, 50: 20108, 51: 19977, 52: 22235, 53: 20116, 54: 20845, 55: 19971, 56: 20843, 57: 20061}

*** str. *partition* (sep)
	将字符串在第一次出现sep时分割，返回一个3元素元组，其中第一个元素
	为sep前面的字符串，第二个元素为sep本身，第三个元素为后面的字符串。
	如果字符串中不含sep，则第一个元素为字符串本身，后面两个元素为空字
	符串：

    #+BEGIN_SRC python :session
      s = 'banana'
      s.partition('a')
      s.partition('an')
      s.partition('X')
    #+END_SRC

    #+RESULTS[167d06c51b698a164715738c32e400adbc15d635]:
    :
    : ('b', 'a', 'nana')
    : ('b', 'an', 'ana')
    : ('banana', '', '')

*** str. *replace* (old,new[,count])
	将字符串中所有的old都替换为new。如果有count参数，则只替换左起
	count个：

    #+BEGIN_SRC python :session
       s = 'banana'
       s.replace('an', 'AN')
       s.replace('an', 'AN', 1)
       s.replace('an', 'AN', 100)
       s.replace('an', 'AN', 0)
    #+END_SRC

    #+RESULTS[638d9f173428bafc184b40e255e33fde7cf72077]:
     :
     : 'bANANa'
     : 'bANana'
     : 'bANANa'
     : 'banana'

*** str. *rfind* (sub[,start[,end]])
	返回从右其字符串中第一次出现sub的索引，可指定在截断[start:end]中
	计算。如果无sub字符串出现，则返回-1：

    #+BEGIN_SRC python :session
      s = 'banana'
      s.rfind('a')
      s.rfind('A')
      s.rfind('a', -4, -2)
    #+END_SRC

    #+RESULTS[244605f9cd087cc3b50276e9fd7b0e389a508043]:
    :
    : 5
    : -1
    : 3

*** str. *rindex* (sub[,start[,end]])
	同rfind，不过如果无sub字符串出现返回ValueError错误：

    #+BEGIN_SRC python :session
      s = 'banana'
      s.rindex('a')
      s.rindex('A')
    #+END_SRC

    #+RESULTS[3146c25983573041bac9396b8d16a24c7c4cae69]:
    :
    : 5
    : Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : ValueError: substring not found

*** str. *rjust* (width[,fillchar])
	返回右对齐后的字符串，使用fillchar填充空白字符，默认为空格字符。
	如果width小于或等于len(s)，则返回字符串本身：

    #+BEGIN_SRC python :session
      'claudio'.rjust(10)
      'claudio'.rjust(10, '|')
      'claudio'.rjust(1, '|')
    #+END_SRC

    #+RESULTS[f74fdefa345dac22326797229bc1683b3b9045bd]:
    : '   claudio'
    : '|||claudio'
    : 'claudio'

*** str. *rpartition* (sep)
	同str.partition，不过是从右起分割；且如果sep不出现在字符串中，返
	回的3元素元组前两个元素为空字符串，最后一个为字符串本身：

    #+BEGIN_SRC python :session
      s = 'banana'
      s.rpartition('a')
      s.rpartition('an')
      s.rpartition('X')
    #+END_SRC

    #+RESULTS[081c08918c8c300c6a508ed2e25de9758e5599a9]:
    :
    : ('banan', 'a', '')
    : ('ban', 'an', 'a')
    : ('', '', 'banana')

*** str. *rsplit* (sep=None,maxsplit=-1)
	与split函数相同，只是从右边分割。

*** str. *rstrip* ([chars])
	返回字符串的副本，末尾中的字符只要出现在chars则被移除。如果无
	chars参数，或为None，则默认移除末尾的空白字符。

	*注意* ：chars不是后缀，而是所有需移除字符的集合。

    #+BEGIN_SRC python :session
      'www.google.com'.rstrip('w.com')
    #+END_SRC

    #+RESULTS[e67751d5c79e1b962dd63d291734c8fd606097e6]:
    : 'www.google'

*** str. *split* (sep=None,maxsplit=-1)
	返回字符串中所有“单词”组成的链表，使用sep作为单词间的分隔符。如果
	指定maxsplit参数，则进行maxsplit次分割（即结果最多可有maxsplit+1
	个元素）；如果未指定maxsplit参数，或其值为-1，则最大限度分割。

    #+BEGIN_SRC python :session
      s = 'banana'
      s.split('a')
      s.split('a', 1)
    #+END_SRC

    #+RESULTS[eda13b345172dbe1d5b067936e4df63fb00f45c9]:
    :
    : ['b', 'n', 'n', '']
    : ['b', 'nana']

	如果有sep参数，连续的分割字符串间会生成空白字符：

    #+BEGIN_SRC python :session
      'a,,b'.split(',')
    #+END_SRC

    #+RESULTS[b6d18eea0ed928ab07637d86a78168b7b73cae9d]:
    : ['a', '', 'b']

	分割字符串可为多个字符：

    #+BEGIN_SRC python :session
      'a<>b<>c'.split('<>')
    #+END_SRC

    #+RESULTS[33b33bada493f7de1ed6647d21ee3c836d9e798a]:
    : ['a', 'b', 'c']

	如果指定sep参数，且字符串为空，则生成的链表只含一个空字符串；如果
	不指定sep参数，且原字符串为空，或只含空白字符，则返回空链表：

    #+BEGIN_SRC python :session
      ''.split(',')
      ''.split()
      '  '.split()
    #+END_SRC

    #+RESULTS[b85162feb08832b6c28a97bf67574d339a3ee9d8]:
    : ['']
    : []
    : []

	如果无sep参数，或为None，则使用不同的算法：使用空白字符作为分割字
	符，且删除相邻的空字符，即使首末有空格，返回的链表中也不会含空字
	符串：

    #+BEGIN_SRC python :session
      '1 2 3'.split()
      '1\t2\t3'.split()
      '1 2 3'.split(maxsplit=1)
      '1    2     3'.split()
      '   1 2     3    '.split()
    #+END_SRC

    #+RESULTS[d65caf767d58fa5c6226de706eca5a30559a7337]:
    : ['1', '2', '3']
    : ['1', '2', '3']
    : ['1', '2 3']
    : ['1', '2', '3']
    : ['1', '2', '3']

*** str. *splitlines* ([keepends])
	在字符串中换行符处分割，返回链表。下表中的字符都会被当做换行符：

    | 字符     | 含义 |
    |----------+------|
    | \n       |      |
    | \r       |      |
    | \r\n     |      |
    | \v或\x0b |      |
    | \f或\x0c |      |
    | \x1c     |      |
    | \x1d     |      |
    | \x1e     |      |
    | \x85     |      |
    | \u2028   |      |
    | \u2029   |      |

    #+BEGIN_SRC python :session
      'ab c\n\rde fd\rkl\r\n'.splitlines()
    #+END_SRC

    #+RESULTS[1c42d82d7f2c0863a3bfeb487066a2c2a0903cf4]:
    : ['ab c', '', 'de fd', 'kl']

	结果中如需包含各种换行符，可指定keppends：

    #+BEGIN_SRC python :session
      'ab c\n\rde fd\rkl\r\n'.splitlines(keepends=True)
    #+END_SRC

    #+RESULTS[2d930a038874c7e68af164c122f10b1486d4341c]:
    : ['ab c\n', '\r', 'de fd\r', 'kl\r\n']

	不同于split()函数，如果指定sep参数，且原字符串为空，此函数返回空
	链表，末尾的换行符后并不生成一个空字符串：

	#+BEGIN_EXAMPLE python
       >>> ''.splitlines()
       []
       >>> 'One line\n'.splitlines()
       ['One line']
	#+END_EXAMPLE

    #+BEGIN_SRC python :session
      ''.splitlines()
      'One line\n'.splitlines()
    #+END_SRC

    #+RESULTS[0fd7f2dcd3174d0153de510519a398d0e8bb1957]:
    : []
    : ['One line']

	而split('\n')的对应结果为：

    #+BEGIN_SRC python :session
      ''.split('\n')
      'One line\n'.split('\n')
    #+END_SRC

    #+RESULTS[6acf371cf5b13cd57288971494c8aa7ec2578147]:
    : ['']
    : ['One line', '']

*** str. *startswith* (prefix[,start[,end]])
	如果字符串有前缀prefix，则返回True，可指定在截断[start:end]中计算：

	#+BEGIN_EXAMPLE python
       >>> 'banana'.startswith('b')
       True
       >>> 'banana'.startswith('a')
       False
       >>> 'banana'.startswith('')
       True
       >>> 'banana'.startswith('n', 2)
       True
	#+END_EXAMPLE

*** str. *strip* ([chars])
	返回原字符串副本，移除收尾中在chars中出现的字符。如果无chars参数，
	或为None，则默认删除首尾的空白字符。

	*注意* ：chars不是前缀或后缀，而是所有需移除字符的集合。

    #+BEGIN_SRC python :session
      'www.google.com'.strip('w.com')
    #+END_SRC

    #+RESULTS[b3c40593f07df6cabd71d2d402b00fe15408a6db]:
    : 'google'

*** str. *swapcase* ()

	返回大小写交换后的字符串副本。

	*注意* ：s.swapcase().swapcase() 可能并不等于s。

    #+BEGIN_SRC python :session
      s = 'Banana'
      s.swapcase()
      s.swapcase().swapcase()

      s = '一二三'
      s.swapcase()
      s.swapcase().swapcase()

      s = 'ß'
      s.swapcase()
      s.swapcase().swapcase()
    #+END_SRC

    #+RESULTS[9ef42a90cca670dcf9c3a8cc8bde065df5272eef]:
    :
    : 'bANANA'
    : 'Banana'
    : >>> >>> '一二三'
    : '一二三'
    : >>> >>> 'SS'
    : 'ss'

*** str. *title* ()
	将原字符串中每个单词首字母大写，其他字母小写作为返回值：

    #+BEGIN_SRC python :session
      'i have a dream'.title()
      '我有一个梦想'.title()
    #+END_SRC

    #+RESULTS[7d7209d1da419540555d154a16ff9b599355fb7c]:
    : 'I Have A Dream'
    : '我有一个梦想'

	*注意* ：此函数只将连续字母看做"单词"，所以可能结果不能如愿：

    #+BEGIN_SRC python :session
      "they'are bill's friends from the UK".title()
    #+END_SRC

    #+RESULTS[753ae2da13d282b4be40c7994280c574508a5b86]:
    : "They'Are Bill'S Friends From The Uk"

	可使用正则勉强解决：

    #+BEGIN_SRC python :session
      import re

      def titlecase(s):
          return re.sub(r"[A-Za-z]+('[A-Za-z]+)?",
                        lambda mo: mo.group(0)[0].upper() + mo.group(0)[1:].lower(),
                        s)

      titlecase("they're bill's friends from UK")
    #+END_SRC

    #+RESULTS[43e1ab81788234d1ee6c74f232252744b80b458d]:
    :
    : >>> ... ... ... ... >>> "They're Bill's Friends From Uk"

*** str. *translate* (table)
	将字符串中的字符逐个与参数table中的元素对应，如果相同，则转换，返
	回转换后的结果。可使用静态方法str.maketrans(in, out)创建字典：

	[[http://www.runoob.com/python/att-string-translate.html][@runoob]]：

    #+BEGIN_SRC python :session
      str = 'a a'
      intab = 'aeiou'
      outtab = '12345'
      tabtab = str.maketrans(intab, outtab)
      print(tabtab)
      'this is a string example...wow!!!'.translate(tabtab)
    #+END_SRC

    #+RESULTS[30a74361585819b3a712fbad0367d850c2f1723f]:
    :
    : >>> >>> >>> {97: 49, 111: 52, 117: 53, 101: 50, 105: 51}
    : 'th3s 3s 1 str3ng 2x1mpl2...w4w!!!'

	table参数须为通过__getitem__()方法实现索引的对象，即mapping或
	sequence对象。当字典key值为整数时，可翻译为：单个字符、Unicode值；
	如果为None则删除原来字符。

    #+BEGIN_SRC python :session
      s = 'a a'
      s.translate({97: 'A'})
      s.translate({'a': 'A'})
      s.translate({97: 'ABC'})
      s.translate({97: None})
      s.translate({97: 1234})
    #+END_SRC

    #+RESULTS[a3422bd0f199a8a6f2d5c42f92efeb5fc77d9f7f]:
    :
    : 'A A'
    : 'a a'
    : 'ABC ABC'
    : ' '
    : 'Ӓ Ӓ'

*** str. *upper* ()
	返回字符串副本，将有大小写区别的字符转换为大写。

	*注意* ：如果str中只含无大小写区分字符，str.upper().isupper()可能
	返回False：

    #+BEGIN_SRC python :session
      '测试'.isupper()
      'abc测试'.upper().isupper()
      '测试'.upper().isupper()
    #+END_SRC

    #+RESULTS[22cba8cf8d5aaa810d1aa66a8fc466f989b73b80]:
    : False
    : True
    : False

*** str. *zfill* (width)
	返回字符串副本，使用ASCII'0'填充扩张到width长度后的左边的空白。如果有正
	负号，则先添加。如果width小于或等于len(s)则返回字符串本身：

    #+BEGIN_SRC python :session
      '42'.zfill(5)
      '-42'.zfill(5)
      'claudio'.zfill(10)
    #+END_SRC

    #+RESULTS[fdb203cebd9fb9bde71be632a5bc43a4d1fc46bb]:
    : '00042'
    : '-0042'
    : '000claudio'

** printf风格的格式化输出
   *注意* ：最好使用str.format()接口格式化字符串。

* 二进制Sequence类型-bytes、bytearray、memoryview
  bytes和bytearray是Python核心内置处理二进制数据的类。由memoryview类支
  持，此类使用"缓存协议（buffer protocol）"，不用复制就可获得其他对象
  的内存地址。？

  array模块支持高效率存储基本数据类型，如32位整数和IEEE754双精度浮点
  数。

** 写在前面
*** 用处举例 [[http://blog.csdn.net/hanhuili/article/details/9069507][@李寒辉的技术日记]]
	比如对字符串进行加密处理，通常是逐个处理字符串中的单个字节。如果
	只含ASCII字符，直接遍历就可；单如果有非ASCII字符，这些字符可能占
	多个字节，就不能通过遍历每个字符来实现遍历每个字节。
*** 进一步说明 [[https://segmentfault.com/a/1190000004450876][@xu_zhoufeng]]
	Bytes类似字符串，不过是由单个字节（8位，取值范围为0-255）作为基本
	元素的Sequence类型，也为Immutable。

	Bytes对象的形式为b'xxxx'，其中x为单个字节。单个字节的表示方式为
	\xHH，其中\x为16进制转义符，HH为16进制数（取值范围为10进制的
	0-255）。对于同一字符串，使用不同编码形式生成的Bytes对象，就会有
	不同的值：

    符串s分别使用utf-8和gb2312编码转换为了Bytes对象a和c。由于
	编码不同，长度也不同：
    
    #+BEGIN_SRC python :session
       s = 'a1一'
       a = bytes(s, 'utf-8')
       b = bytearray(s, 'utf-8')
       c = bytes(s, 'gb2312')
       print(a, b, c)
       print(len(a), len(b), len(c))
    #+END_SRC
    
    #+RESULTS[848498726a295116d76664340e1ed999657f16dc]:
    :
    : >>> >>> >>> b'a1\xe4\xb8\x80' bytearray(b'a1\xe4\xb8\x80') b'a1\xd2\xbb'
    : 5 5 4
    
	使用Bytes对象的decode方法就可实现解码，如果编码参数与编码时相同，
	就会与原来相同的字符，否则就可能返回UnicodeDecodeError错误：
    
    #+BEGIN_SRC python :session
      bytes('a1一', 'utf-8').decode('utf-8')
      bytes('a1一', 'gb2312').decode('gb2312')

      bytes('a1一', 'gb2312').decode('utf-8')
      bytes('a1一', 'utf-8').decode('gb2312')
    #+END_SRC
    
    #+RESULTS[9753a73ca632282e558aa0120784aff49e2df5e0]:
    : 'a1一'
    : 'a1一'
    : >>> 'a1һ'
    : Traceback (most recent call last): 
    :   File "<stdin>", line 1, in <module>
    : UnicodeDecodeError: 'gb2312' codec can't decode byte 0x80 in position 4: incomplete multibyte sequence
    
	可通过字面量形式创建Bytes对象，不过仅限于ASCII范围内的字符：
    
    #+BEGIN_SRC python :session
      b'1abc'
      b'1a一'
    #+END_SRC
    
    #+RESULTS[baab11aded68f79c518a30e0adb803a53c2928d3]:
    : b'1abc'
    : File "<stdin>", line 1
    : SyntaxError: bytes can only contain ASCII literal characters.
    
** Bytes对象
   bytes对象是由单个bytes元素组成的immutable类型的Sequence。由于主要
   的二进制协议都基于ASCII文本编码，bytes对象中有几个方法只在处理
   ASCII兼容数据时有效，且与字符串的一些方法用法相似。

   bytes对象字面量与字符串字面量唯一区别是在前面有b字母：

	- 单引号：b'still allows embedded "double" quotes'
	- 双引号：b"still allows embedded 'single' quotes"
	- 三引号：'''3 single quotes'''，b"""3 double quotes"""

	不管源代码编码声明如何，字面量中只允许存在ASCII字符，任何Unicode值
	大于127的字符都需转义表示。

	同字符串字面量相同，可在添加前缀r，指定不处理转义序列？：

    #+BEGIN_SRC python :session
      s = r'a\nb'
      print(s)

      s = 'a\nb'
      print(s)
    #+END_SRC

    #+RESULTS[d946bf1d3966287b06650151aadb692a02453eec]:
    :
    : a\nb
    : >>> >>> a
    : b

    #+BEGIN_SRC python :session
      b = br'a\nb'
      print(b)

      b = b'a\nb'
      print(b)
    #+END_SRC

    #+RESULTS[ce0d74ddc6eb34f89a941c2e7297926c3c7a3f09]:
    :
    : b'a\\nb'
    : >>> >>> b'a\nb'

	尽管bytes字面量的表示基于ASCII文本，但bytes对象实际上更像immutable
	类型的整数序列，其中元素的取值范围为0<=x<256。

	除字面量外，还可使用一下方法创建bytes对象：

	- 指定长度，所有元素用0初始化：bytes(0)。
	- 转换至只含整数的iterable：bytes(rang(20))。
	- 通过buffer协议复制二进制数据：bytes(obj)。
	- 参考bytes函数

	由于2位的16进制数就可表示一个字节，所以常使用16进制数表示二进制数。
	因此，bytes对象可使用fromhex类方法将字符串转换为bytes对象。

	classmethod bytes. *fromhex* (string)：解码字符串，忽视空格，返回
	bytes对象：

    #+BEGIN_SRC python :session
      bytes.fromhex('')
      bytes.fromhex('ff 2ef0 F1   F1')
      chr(2 * 16 + 14)                # 16进制2e代表的字符
    #+END_SRC

    #+RESULTS[f0a6caace8150a90d746b011cbf87001a3293549]:
    : b''
    : b'\xff.\xf0\xf1\xf1'
    : '.'

	bytes. *hex* ()：将bytes对象转换为16进制形式的字符串：

    #+BEGIN_SRC python :session
      b'\x2e\xff'.hex()
    #+END_SRC

    #+RESULTS[b887eb86a961598c396ed5555de416ada934079d]:
    : '2eff'

	与字符串对象不同的是，如果b为bytes对象，b[0]会返回整数，b[0:1]会返
	回长度为1的bytes对象。

    #+BEGIN_SRC python :session
      b'abc1'[0]
      b'abc1'[0:1]
    #+END_SRC

    #+RESULTS[e456ea1a3e4a4b020f60f330f1ed5028529be3a0]:
    : 97
    : b'a'

	b'...'形式表示比bytes([46, 46, 46])更有用，不过还是可使用list函数
	将bytes对象转换为整数链表。

    #+BEGIN_SRC python :session
      list(b'abc')
    #+END_SRC
    
    #+RESULTS[18d791e2473a4717b786bc3ec7c9ab399fbd556d]:
    : [97, 98, 99]
    
** Bytearray对象
   bytearray对象相当于immutable形式的bytes对象。不过没有相应的字面量
   表示方法，只可用构造器函数构造：
   
	- 创建空实例：bytearray()
	- 指定长度，使用0填充每个元素：bytearray(10)
	- 使用只含整型iterable类型：bytearray(range(20))
	- 通过buffer protocol复制二进制数据：bytearray(b'Hi!')
      
	bytearray支持所有前面中所有mutable类型Sequence支持的操作，以
	及后面将介绍的bytes和bytearray常见的操作。
    
	与bytes一样，bytearray也有类方法fromhex()和方法hex()：
    
    #+BEGIN_SRC python :session
      bytearray.fromhex('FF2E F0 F1F1')
      bytearray(b'abc').hex()
    #+END_SRC
    
    #+RESULTS[f25622bd6cc957b56ae34802575eb18049982278]:
    : bytearray(b'\xff.\xf0\xf1\xf1')
    : '616263'
    
	同样也可使用list函数转换为整数链表：
    
    #+BEGIN_SRC python :session
      list(bytearray(b'abc'))
    #+END_SRC
    
    #+RESULTS[17a60f9a3af17d02d885f04e2644ef32bf104a98]:
    : [97, 98, 99]
    
** Bytes和bytearray操作符
   bytes和bytearray对象都具备上面提到的Sequence通用的操作符。此外，二
   者使用上面的通用操作符号时，可混合使用，还可同“类bytes对
   象”（bytes-like object，bytes、bytearray和许多常见的memoryview对象）
   一起使用，返回结果由出现顺序而定（为先出现类型）：
   
   #+BEGIN_SRC python :session
     b = b'abc'
     ba = bytearray(b'123')

     b + ba
     ba + a
   #+END_SRC
   
   #+RESULTS[8c1fb8db2985fe0e751c7c9bfb11c2025f1c9f24]:
   :
   : >>> >>> b'abc123'
   : bytearray(b'1231abc')
   
   但bytes和bytearray的方法不接受字符串作为参数，反之亦然：
   
   #+BEGIN_SRC python :session
     s = 'abc'
     b = b'abc'

     s.replace('a', 'A')
     b.replace(b'a', b'A')

     b.replace(b'a', 'A')
   #+END_SRC
   
   #+RESULTS[ffe67e7436899e0ccfed8472285792bdb49df2bf]:
   :
   : >>> >>> 'Abc'
   : b'Abc'
   : >>> Traceback (most recent call last): 
   :   File "<stdin>", line 1, in <module>
   : TypeError: a bytes-like object is required, not 'str'
   
*** bytes. *count* (sub[,start[,end]])
*** bytearray. *count* (sub[,start[,end]])
    返回SUB的出现次数，可通过START和END参数指定截断。

    SUB可为所有“类bytes对象”，以及0-255的整数。

    #+BEGIN_SRC python :session
      b = bytes('a1a一a', 'utf-8')

      b.count(b'a')
      b.count(b'a', 1)
      b.count(b'a', 1, 3)
      b.count(97)
      b.count(bytearray(b'a'))
    #+END_SRC

    #+RESULTS[0c38d602277518715a68da77ce9edd4d1e05b338]:
    :
    : >>> 3
    : 2
    : 1
    : 3
    : 3

*** bytes. *decode* (encoding='utf-8',errors='strict')
*** bytearray. *decode* (encoding='utf-8',errors='strict')

    返回解码结果，默认编码为“utf-8”，默认错误处理方式为"strict"。

    #+BEGIN_SRC python :session
      b = bytes('我是claudio', 'utf-8')
      b
      b.decode('utf-8')
      b.decode('gb2312', 'ignore')
      b.decode('gb2312', 'replace')
      b.decode('gb2312', 'strict')
    #+END_SRC

    #+RESULTS[5da449004438bd4e775c5a74683cb697176aec86]:
    :
    : b'\xe6\x88\x91\xe6\x98\xafclaudio'
    : '我是claudio'
    : 'claudio'
    : '������claudio'
    : Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : UnicodeDecodeError: 'gb2312' codec can't decode byte 0xe6 in position 0: illegal multibyte sequence

*** bytes. *endswith* (suffix[,stat[,end]])
*** bytearray. *endswith* (suffix[,stat[,end]])

    是否以SUFFIX结尾，可使用START和END指定搜索截断。
    #+BEGIN_SRC python :session
      b = b'abc'
      b.endswith(b'c')
      b.endswith(b'c', 0, 2)
      b.endswith(bytearray(b'c'))
      b.endswith((b'a', b'c', bytearray(b'1')))
    #+END_SRC

    #+RESULTS[be33bec035e4781038ecf1fbbb02cba3ffe14602]:
    :
    : True
    : False
    : True
    : True

*** bytes. *find* (sub[,start[,end]])
*** bytearray. *find* (sub[,start[,end]])

    返回SUB的索引，如果没有，则返回-1，可使用start和end作为截断。

    SUB参数可为“类bytes对象”，或0-255的整数。

    #+BEGIN_SRC python :session
      b = b'banana'
      b.find(b'a')
      b.find(97)
      b.find(b'a', 2)
      b.find(b'z')
    #+END_SRC

    #+RESULTS[fd1b81f517aec1b80d4ae1024839cff1950bb0f8]:
    :
    : 1
    : 1
    : 3
    : -1

*** bytes. *index* (sub[,start[,end]])
*** bytearray. *index* (sub[,start[,end]])
    参数和返回值同find方法，只是在没有找到的情况下返回错误，而不是-1。

    #+BEGIN_SRC python :session
      b = b'banana'
      b.index(b'a')
      b.index(97)
      b.index(b'a', 2)
      b.index(b'z')
    #+END_SRC

    #+RESULTS[f46b03ac06bdb29074c197ab78d142cde261d91b]:
    :
    : 1
    : 1
    : 3
    : Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : ValueError: substring not found

*** bytes. *join* (iterable)
*** bytearray. *join* (iterable)

    返回使用byte/bytearray连接ITERABLE中元素的结果，ITERABLE中的元素须
    都为“类bytes对象”。

    #+BEGIN_SRC python :session
      b'a'.join([b'1', b'2'])
      bytearray(b'a').join([b'1', b'2'])
      b'a'.join([b'1', bytearray(b'2')])
    #+END_SRC

    #+RESULTS[ce770386874acea807e03cd827b71dc2977f8c00]:
    : b'1a2'
    : bytearray(b'1a2')
    : b'1a2'

*** static bytes.maketrans(from, to)
*** static bytearray.maketrans(from, to)

    此为静态方法，返回用于bytes.translate()方法的翻译表。FROM和TO须为
    “类bytes对象”。

    #+BEGIN_SRC python :session
      intab = bytes(b'123')
      # outtab = bytes('一二三', 'gb2312')
      # bytes.maketrans(intab, outtab)
      outtab = bytes(b'abc')
      bytes.maketrans(intab, outtab)
      # print(outtab)
    #+END_SRC

    #+RESULTS[52d5d800d6e22bbcc88f3454132132f8a4c9f568]:
    :
    : ... ... >>> b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !"#$%&\'()*+,-./0abc456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff'

*** bytes. *partition* (sep)
*** bytearray. *partition* (sep)
    在出现SEP分割，生成3元素元组，第一个元素为SEP前的内容，第二个元素
    为SEP，第三个元素为SEP后的内容。如果不含SEP，则第一个元素为原
    bytes/bytearray的副本，后两个元素为空bytes/bytearray。

    SEP须为“类bytes对象”。

    #+BEGIN_SRC python :session
      b = b'banana'
      b.partition(b'n')
      b.partition(b'Z')
      b.partition('n')
    #+END_SRC

    #+RESULTS[f66c939f804e036b68c4b452ef96b9ac075f6419]:
    :
    : (b'ba', b'n', b'ana')
    : (b'banana', b'', b'')
    : Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : TypeError: a bytes-like object is required, not 'str'

*** bytes. *replace* (old, new, [count])
*** bytearray. *replace* (old, new, [count])
    返回bytes/bytearray的副本，其中出现OLD的地方用NEW替换。默认替换所
    有，如果有COUNT参数，在从左到右替换COUNT个。

    OLD和NEW需为“类bytes对象”。

    #+BEGIN_SRC python :session
      b = b'banana'
      ba = b'banana'

      b.replace(b'a', b'A')
      b.replace(b'a', b'A', 2)
    #+END_SRC

    #+RESULTS[631503ec53cc6ddcd1ae2e2287c509b568bdc372]:
    :
    : >>> >>> b'bAnAnA'
    : b'bAnAna'

    *注意* ：如果用于bytearray，则不是操作其副本，而是返回一个新的对象。

*** bytes. *rfind* (subp[,start[,end]])
*** bytearray. *rfind* (subp[,start[,end]])
    同find方法，只是从右边计算。

    #+BEGIN_SRC python :session
      b'banana'.rfind(b'a')
    #+END_SRC

    #+RESULTS[ab1d9b092390515e042f96800fbffd3b12acae48]:
    : 5

*** bytes. *rindex* (sub[,start[,end]])
*** bytearray. *rindex* (sub[,start[,end]])
    同index方法，只是从右边开始计算：

    #+BEGIN_SRC python :session
      b'banana'.rindex(b'a')
    #+END_SRC

    #+RESULTS[8981fe48ac5ebbf00c56e92434a754d28b93554f]:
    : 5

*** bytes. *rpartition* (sep)
*** bytearray. *rpartition* (sep)
    同partition方法，只是从最右边出现SEP处分割。且如果无SEP出现，也是将
    元bytes/bytearray作为最后一个元素。

    #+BEGIN_SRC python :session
      b'banana'.rpartition(b'n')
      b'banana'.rpartition(b'z')
    #+END_SRC

    #+RESULTS[64620ca198eebd551388a74cdef95aec1f9cca73]:
    : (b'bana', b'n', b'a')
    : (b'', b'', b'banana')

*** bytes. *startswith* (prefix,[start[,end]])
*** bytearray. *startswith* (prefix,[start[,end]])
    是否一PREFIX开始，可指定截断START和END。PREFIX可为包含多个前缀的元
    组，只要一个满足条件就返回True。

    PREFIX或其中的元素须为“类bytes对象”。

    #+BEGIN_SRC python :session
      b'banana'.startswith(b'ba')
      b'banana'.startswith((b'ba', b'baz'))
    #+END_SRC

    #+RESULTS[eb8cc1fa898041d657807a4eeecc86375054bb5a]:
    : True
    : True

*** bytes. *translate* (table[,delete])
*** bytearray. *translate* (table[,delete])
    返回bytes/bytearray的副本。根据TABLE替换内容，如果有DELETE参数，则
    删除其中的内容。

    可使用bytes.maketrans()方法生成TABLE。DELETE需为“类bytes对象”。

    #+BEGIN_SRC python :session
      b'i have a dream!'.translate(bytes.maketrans(b'aeiou', b'AEIOU'))
    #+END_SRC

    #+RESULTS[147409ce4bdc449e383c36dd4ab4e01d6f938891]:
    : b'I hAvE A drEAm!'

    如果TABLE为None，则是仅删除元素：

    #+BEGIN_SRC python :session
      b'i have a dream!'.translate(None, b'aeiou')
    #+END_SRC

    #+RESULTS[8b9ab85c12c61eded385c6461e3c55e2d34ac6e7]:
    : b' hv  drm!'

*** bytes. *center* (width[,fillbyte])
*** bytearray. *center* (width[,fillbyte])

    *bytes返回副本，bytearray返回新对象。下同。*

    如果WIDTH小于或等于原来长度，bytes会返回原来对象。

    将原对象扩展到WIDTH宽度，默认使用空白字符填充，可使用FILLBYTE指定
    填充字符。

    #+BEGIN_SRC python :session
      b'banana'.center(10)
      b'banana'.center(10, b'|')
      b'banana'.center(0)
    #+END_SRC

    #+RESULTS[bae3733368575798d333e733f8252d73e02ffc41]:
    : b'  banana  '
    : b'||banana||'
    : b'banana'

*** bytes. *ljust* (width[,fillbyte])
*** bytearray. *ljust* (width[,fillbyte])
    按WIDTH左对齐，填充字符FILLBYTE为空格（ASCII Space）。

    如果WITH小于或等于原来宽度，返回bytes本身。

    #+BEGIN_SRC python :session
      b'banana'.ljust(10)
      b'banana'.ljust(10, b'|')
      b'banana'.ljust(1)
    #+END_SRC

    #+RESULTS[c200c11d607fcc058d5dc751551914d2c9edc6c6]:
    : b'banana    '
    : b'banana||||'
    : b'banana'

*** bytes. *lstrip* ([chars])
*** bytearray. *lstrip* ([chars])
    CHARS不是前缀，而是byte的结合。如果为None或缺省，默认删除空格
    （ASCII Space）。

    CHARS须为“类bytes对象”。

    #+BEGIN_SRC python :session
      b'   banana   '.lstrip()
      b'www.google.com'.lstrip(b'.wcom')
    #+END_SRC

    #+RESULTS[5e9957d13da552d9e6351c4b81cbcb892654d374]:
    : b'banana   '
    : b'google.com'

*** bytes. *rjust* (width[,fillbyte])
*** bytearray. *rjust* (width[,fillbyte])
    同ljust方法，只是右对齐：

    #+BEGIN_SRC python :session
       b'banana'.rjust(10)
       b'banana'.rjust(10, b'|')
       b'banana'.rjust(1)
    #+END_SRC

    #+RESULTS[a15af7d169fedb54b8067eb14f2067da25621e4f]:
    : b'    banana'
    : b'||||banana'
    : b'banana'

*** bytes. *rsplit* (sep=None,maxsplit=-1)
*** bytearray. *rsplit* (sep=None,maxsplit=-1)
    见下面split方法。
*** bytes. *rstrip* ([chars])
*** bytearray. *rstrip* ([chars])
    同lstrpe，只是删除右边的CHARS。

    #+BEGIN_SRC python :session
      b'   banana   '.rstrip()
      b'www.google.com'.rstrip(b'.wcom')
    #+END_SRC

    #+RESULTS[a7f653d1aa116ea26971d32c6643cf95541aab72]:
    : b'   banana'
    : b'www.google'

*** bytes. *split* (sep=None,maxsplit=-1)
*** bytearray. *split* (sep=None,maxsplit=-1)
    同字符串的split方法，只是SEP参数须为“类bytes对象”。
*** bytes. *strip* ([chars])
*** bytearray. *strip* ([chars])
    相当于lstrip和rstrip的结合：

    #+BEGIN_SRC python :session
      b'   banana   '.strip()
      b'www.google.com'.strip(b'.wcom')
    #+END_SRC

    #+RESULTS[e323b44045a00507996b484308651ac380c01adf]:
    : b'banana'
    : b'google'

    下面的bytes和bytearray方法默认使用ASCII兼容的二进制形式，不过也可
    使用任意二进制数据作为参数。

    对于bytearray对象，下面的方法并不是返回副本（in-place操作），而是生成新的对象。

*** bytes. *capitalize* ()
*** bytearray. *capitalize* ()
    第一个byte大写，后面所有bytes小写。非ASCII bytes保持不变。

    #+BEGIN_SRC python :session
      b'i have a dream!'.capitalize()
    #+END_SRC

    #+RESULTS[067de7929dd22c6c491c51c02fb8dc21e8617fff]:
    : b'I have a dream!'

*** bytes. *expandtabs* (tabsize=8)
*** bytearray. *expandtabs* (tabsize=8)
    将b'\t'替换为1个或多个空格

    #+BEGIN_SRC python :session
      b'01\t012\t0123\t01234'.expandtabs()
      b'01\t012\t0123\t01234'.expandtabs(4)
    #+END_SRC

    #+RESULTS[1f9699cff994f739841006814d08f3243d007d7d]:
    : b'01      012     0123    01234'
    : b'01  012 0123    01234'

*** bytes. *isalnum* ()
*** bytearray. *isalnum* ()
    是否为只含ASCII字母和数字，且至少有一个元素：

    ASCII字母：

    #+BEGIN_EXAMPLE
      abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
    #+END_EXAMPLE

    ASCII数字：

    #+BEGIN_EXAMPLE
      0123456789
    #+END_EXAMPLE

    #+BEGIN_SRC python :session
      b'ABCabc1'.isalnum()
      b'ABC abc1'.isalnum()
      b''.isalnum()
    #+END_SRC

    #+RESULTS[03d4840e58522c3ff9c5d618a9c8dd96ecd013e2]:
    : True
    : False
    : False

*** bytes. *isalpha* ()
*** bytearray. *isalpha* ()
    只含ASCII字母，且不为空：

    #+BEGIN_SRC python :session
      b'ABCabc'.isalpha()
      b'ABCabc1'.isalpha()
    #+END_SRC

    #+RESULTS[63e061228b23e4fdf96024183a58b7892ddb6345]:
    : True
    : False

*** bytes. *isdigit* ()
*** bytearray. *isdigit* ()
    只含ASCII数字，且不为空：

    #+BEGIN_SRC python :session
      b'1234'.isdigit()
      b'12.3'.isdigit()
    #+END_SRC

    #+RESULTS[7f2b3ee224a4c398aeaa268cd96b8107b5b630e6]:
    : True
    : False

*** bytes. *islower* ()
*** bytearray. *islower* ()
    至少含一个ASCII字母，且所有字母都为小写：

    #+BEGIN_SRC python :session
      b'hello,world'.islower()
      b''.islower()
      b'.'.islower()
    #+END_SRC

    #+RESULTS[68627e842332f7c742bb5c6d8b4b8064dbb45bc1]:
    : True
    : False
    : False

*** bytes. *isspace* ()
*** bytearray. *isspace* ()
    是否只含b' \t\n\r\x0b\f'（空格、tab、换行符、carriage return、
    vertical tab和form feed）中的字符，且不为空。

*** bytes. *istitle* ()
*** bytearray. *istitle* ()
    为ASCII形式的标题，且不为空。

    #+BEGIN_SRC python :session
      b'Hello World'.istitle()
      b'Hello world'.istitle()
    #+END_SRC

    #+RESULTS[92e0462ad3e3a897497c25b30eecc2563405ac9d]:
    : True
    : False

*** bytes. *isupper* ()
*** bytearray. *isupper* ()
    至少含一个ASCII字符，且所有ASCII字符都为大写：

    #+BEGIN_SRC python :session
      b'HELLO WORLD'.isupper()
      b'Hello World'.isupper()
      b''.isupper()
      b'.'.isupper()
    #+END_SRC

    #+RESULTS[e458e84ca2055831ef7d45b9f7edd805e53a30d2]:
    : True
    : False
    : False
    : False

*** bytes. *lower* ()
*** bytearray. *lower* ()
    将所有ASCII字母转换为小写：

    #+BEGIN_SRC python :session
      b'Hello World'.lower()
    #+END_SRC

    #+RESULTS[4c6f6c591b99ce338524ccd6a30b80244ce99cf5]:
    : b'hello world'

*** bytes. *splitlines* (keepends=False)
*** bytearray. *splitlines* (keepends=False)
    在换行符处分割，Unix换行符'\n'，Windows换行符'\r\n'和Macintosh换行
    符'\r'都可识别：

    #+BEGIN_SRC python :session
      b'ab c\n\nde fg\rkl\r\nmn'.splitlines()
    #+END_SRC

    #+RESULTS[7e0f5845314c3277d769ecd0e71369821e467715]:
    : [b'ab c', b'', b'de fg', b'kl', b'mn']

    如果要保留换行符，可指定KEEPENDS参数为True：

    #+BEGIN_SRC python :session
      b'ab c\n\nde fg\rkl\r\nmn'.splitlines(keepends=True)
    #+END_SRC

    #+RESULTS[702b6db16629067811004483252cf49ff98e4c80]:
    : [b'ab c\n', b'\n', b'de fg\r', b'kl\r\n', b'mn']

    与split方法不同，对于空字符串此方法返回空链表：

    #+BEGIN_SRC python :session
      b''.split(b'\n'), b'Two lines\n'.split(b'\n')
      b''.splitlines(), b'One line\n'.splitlines()
    #+END_SRC

    #+RESULTS[2bf40baae7050e181ee5681642a516314ae440eb]:
    : ([b''], [b'Two lines', b''])
    : ([], [b'One line'])

*** bytes. *swapcase* ()
*** bytearray. *swapcase* ()
    交换大小写：

    #+BEGIN_SRC python :session
      b'Hello World'.swapcase()
    #+END_SRC

    #+RESULTS[1a6dd25caeb08f03c9a65704892ebce94a9e31c7]:
    : b'hELLO wORLD'

    *注意* ：不同于str.swapcase()：

    #+BEGIN_SRC python :session
      bin.swapcase().swapcase() == bin
    #+END_SRC

*** bytes. *title* ()
*** bytearray. *title* ()
    将所有“单词”中第一个字母转换为大写，其余转换为小写，非ASCII字母保
    持不变。

    #+BEGIN_SRC python :session
      b'hello world'.title()
    #+END_SRC

    #+RESULTS[bdafb952ad15cceb90d15bc96703872af5b1f15c]:
    : b'Hello World'

    此方法的算法仅是将连续字母作为单词，不能通用，如：

    #+BEGIN_SRC python :session
      b"they're bill's firends from the UK".title()
    #+END_SRC

    #+RESULTS[1e881816ebb27eedcac3e49c467698de5fa2d6b5]:
    : b"They'Re Bill'S Firends From The Uk"

    可使用正则大致修复：

    #+BEGIN_SRC python :session
      import re

      def titlecase(s):
          return re.sub(rb"[A-Za-z]+('[A-Za-z]+)?",
                        lambda mo: mo.group(0)[0:1].upper() +
                        mo.group(0)[1:].lower(),
                        s)

      titlecase(b"they'are bill's friends from UK.")
    #+END_SRC

    #+RESULTS[853b00c6a51a260ebf749297803170f9d503bb8b]:
    :
    : >>> >>> ... ... ... ... ... >>> >>> b"They'are Bill's Friends From Uk."

*** bytes. *upper* ()
*** bytearray. *upper* ()
    将所有ASCII字母转换为大写：
    
    #+BEGIN_SRC python :session
      b'Hello, World'.upper()
    #+END_SRC

    #+RESULTS[ea1adac72e687af6f2bf119cf97fdcd0c240d0b3]:
    : b'HELLO, WORLD'

*** bytes. *zfill* (width)
*** bytearray. *zfill* (width)
    扩展到WIDTH宽度，左边使用b'0'填充。
    
    如果WIDTH小于或等于原来宽度，bytes返回自己本身，bytearray仍然返回
    新对象。

    #+BEGIN_SRC python :session
      b'42'.zfill(6)
      b'-42'.zfill(6)
    #+END_SRC

    #+RESULTS[b172afe84921d69bd78fad3e8fdc26e6c7d9f52b]:
    : b'000042'
    : b'-00042'

** 使用printf风格格式化Bytes

   #+BEGIN_SRC python :session
     print(b'%(language)s hash %(number)03d quete types.' %
           {b'language': b'Python', b'number': 2})
   #+END_SRC

   #+RESULTS[6a760f6a28f9065b3d9105090c3f3acc3e6358b1]:
   :
   : b'Python hash 002 quete types.'

** Memory Views
   memoryview对象的作用是：不复制就可获取支持buffer protocol对象的内存
   地址。
   
*** 写在前面 [[https://segmentfault.com/q/1010000007137721][@segmentfault]] （还是没懂）
    str和bytearray切片时会复制数据，生成新的数据；bytes和memoryview切
    片时不会：
    
    不使用memoryview：
    
    #+BEGIN_SRC python :session
      a = 'abcdefg'
      b = a[:2]                       # 会生成新的字符串

      a = bytearray('abcdefg', 'utf-8')  # 会生成新的bytearray
      b = a[:2]
      b[:2] = b'bb'                   # 对b的改动不影响a
      a
      b
    #+END_SRC
    
    #+RESULTS[c1c892b196daf3801846c0ca2fd6da47f3e7131b]:
    :
    : >>> >>> >>> >>> >>> bytearray(b'abcdefg')
    : bytearray(b'bb')
    
    使用memoryview：
    
    #+BEGIN_SRC python :session
      a = b'abcdefg'
      ma = memoryview(a)
      ma.readonly                     # 只读
      mb = ma[:2]                     # 不会生成新的bytes

      a = bytearray(b'abcdefg')
      ma = memoryview(a)
      ma.readonly                     # 不为只读
      mb = ma[:2]
      mb[:2] = b'AA'                  # 对mb的改动会影响a
      ma.tobytes()
      mb.tobytes()
    #+END_SRC
    
    #+RESULTS[ca75b35e9866dc79fe404515b992d4ef4e83b03f]:
    :
    : >>> True
    : >>> >>> >>> >>> >>> False
    : >>> >>> b'AAcdefg'
    : b'AA'
    
    使用struct进行unpack解析时可直接接受memoryview对象，避免解析大字符
    串时大量切片：（没懂！！！）
    
    #+BEGIN_SRC python :session
      import struct

      mv = memoryview(bytes(b'123456'))
      struct.unpack('!BB', mv[:2])
    #+END_SRC
    
    #+RESULTS[371c79b6ad01428e2c5e7985bd6945a93cc30230]:
    :
    : >>> >>> (49, 50)
    
*** class *memoryview* (obj)
    创建指向OBJ的memoryview对象。OBJ须支持buffer protocol，包含bytes和
    bytearray对象，及array.array对象。

    memoryview元素的内存大小由OBJ决定，如果OBJ为bytes或bytearray对象，
    则为1bytes，如果为array.array对象，则可能更大。

    len(view)的值等于tolist方法返回的值。如果view.ndim==0，则长度为1；
    如果view.ndim==1，则长度为view中元素的个数。如果维度更大，则为第一
    层嵌套元素的个数。itemsize属性可返回单个元素所在byte个数。

    #+BEGIN_SRC python :session
      from array import array

      a = array('l')
      m = memoryview(a)

      m.ndim
      m.tolist()
      len(m), m.itemsize
    #+END_SRC

    #+RESULTS[5082e229bae9ad245ec196b3f40f7fc12f9b713d]:
    :
    : >>> >>> >>> >>> 1
    : []
    : (0, 8)

    memoryview支持切片和索引获取元素，一维切片返回内存子集：

    #+BEGIN_SRC python :session
      v = memoryview(b'abcdefg')
      v[1]
      v[-1]
      v[1:4]
      bytes(v[1:4])
    #+END_SRC

    #+RESULTS[a9028679c859d0e4f647abc666e156e9e2e5eef0]:
    :
    : 98
    : 103
    : <memory at 0x7fe514205408>
    : b'bcd'

    如果OBJ为mutable类型，则memoryview对象也mutable，但不能改变元素个
    数：

    #+BEGIN_SRC python :session
      data = bytearray(b'abcdefg')
      v = memoryview(data)

      v.readonly
      v[0] = ord('z')
      data, v.tobytes()

      data[1:4] = b'123'
      data, v.tobytes()
    #+END_SRC

    #+RESULTS[81d60fdf8bdaedfc8122daf23dc1516f8ef43bfc]:
    :
    : >>> >>> False
    : >>> (bytearray(b'zbcdefg'), b'zbcdefg')
    : >>> >>> (bytearray(b'z123efg'), b'z123efg')

*** 方法
**** *__eq__* (exproter) ？？？
     只要ma.tolist() == mb.tolist，则ma == mb。

     #+BEGIN_SRC python :session
       from array import array

       a = array('I', [1, 2, 3])
       b = array('d', [1.0, 2.0, 3.0])
       x = a.tolist()
       y = b.tolist()

       x == y
     #+END_SRC

     #+RESULTS[2313e696f45e3e734b389337ef559f77d3e13595]:
     :
     : >>> >>> >>> >>> >>> >>> True

     如果元素的数据类型不在struct模块中的格式字符串中，则永远不相等（含
     自身）。

     #+BEGIN_SRC python :session
       from ctypes import BigEndianStructure, c_long

       class BEPoint(BigEndianStructure):
           _fields_ = [('x', c_long), ('y', c_long)]

       point = BEPoint(100, 200)
       a = memoryview(point)
       b = memoryview(point)
       a == point
       a == b
       a == a
     #+END_SRC

     #+RESULTS[5ae769c5841bbfc419f8612abf6b2dd8abe3311c]:
     :
     : >>> >>> ... ... >>> >>> >>> >>> >>> False
     : False
     : False

     *注意* ：对于浮点数，即时ma is mb，ma == mb也会返回false。？？？

**** *tobytes* ()
     转换为bytes对象：
     
     #+BEGIN_SRC python :session
       m = memoryview(b'abc')
       m.tobytes()
       bytes(m)
     #+END_SRC
     
     #+RESULTS[3418f9e79a7f31e2c0f4c168ac4d4e0daf664fba]:
     :
     : b'abc'
     : b'abc'
     
**** *hex* ()
     返回字符串，用16进制数表示每个byte：
     
     #+BEGIN_SRC python :session
       m = memoryview(b'abc')
       m.hex()
       bytes.fromhex(m.hex())
     #+END_SRC
     
     #+RESULTS[20295c723328fd3f5c60059475ba93b4e505c964]:
     :
     : '616263'
     : b'abc'
     
**** *tolist* ()
     返回每个元素组成的数组，相当于调用list函数：
     
     #+BEGIN_SRC python :session
       from array import array

       memoryview(b'abc').tolist()

       a = array('d', [1.1, 2.2, 3.3])
       m = memoryview(a)
       m.tolist()
     #+END_SRC
     
     #+RESULTS[56e4a91855c5afff65fb1cfb0cd6d71ae7f63bd4]:
     :
     : >>> [97, 98, 99]
     : >>> >>> >>> [1.1, 2.2, 3.3]
     
**** *release* ()
     释放view，被传入memoryview的对象在释放前不能进行mute操作（如
     bytearray不能改变元素个数），所以需使用此方法取消限制：
     
     #+BEGIN_SRC python :session
       b = bytearray(b'abc')

       # 传入memoryview对象后
       m = memoryview(b)
       b.append(ord('e'))

       # 释放
       m.release()
       b.append(ord('e'))
       print(b)
     #+END_SRC
     
     #+RESULTS[b893fab646a87a1269b4555431d20c3a06b27694]:
     :
     : >>> ... >>> Traceback (most recent call last): 
     :   File "<stdin>", line 1, in <module>
     : BufferError: Existing exports of data: object cannot be re-sized
     : >>> ... >>> >>> bytearray(b'abce')
     
     memoryview对象被释放后，不能进一步操作：
     
     #+BEGIN_SRC python :session
       m = memoryview(b'abc')
       m[0]

       m.release()
       m[0]
     #+END_SRC
     
     #+RESULTS[7c4a8ae52af4353ab2b74c136ff665998c69cc84]:
     :
     : 97
     : >>> >>> Traceback (most recent call last): 
     :   File "<stdin>", line 1, in <module>
     : ValueError: operation forbidden on released memoryview object
     
     使用context management protocol可得到相同效果，即操作完成后自动冻
     结：
     
     #+BEGIN_SRC python :session
       with memoryview(b'abc') as m:
           m[0]

       m[0]
     #+END_SRC
     
     #+RESULTS[6ae2b69926c4549141d0dd69f4eb917f046b7445]:
     :
     : ... 97
     : Traceback (most recent call last): 
     :   File "<stdin>", line 1, in <module>
     : ValueError: operation forbidden on released memoryview object
     
**** *cast* (fromat[,shape]) ？？？
     改变memoryview的单个元素内存大小，或形状（维度），返回新的
     memoryview对象，但仍指原来的对象。

     SHAPE的默认值为"[byte_length // new_itemsize]"，即默认转换为一维。

     FORMAT参数需为struct模块中指定的格式字符。 原来的格式字符和新的格
     式字符需至少有一个为byte形式（即'B'、'b'或'c'）。

     返回值的byte数须与原byte数相同。

     一维long -> 一维unsigned char：

     #+BEGIN_SRC python :session
      from array import array

      a = array('l', [1, 2, 3])
      m = memoryview(a)
      print(m.tobytes())
      m.format, m.itemsize, len(m), m.nbytes

      m1 = m.cast('B')
      print(m1.tobytes())
      m1.format, m1.itemsize, len(m1), m1.nbytes
     #+END_SRC

     #+RESULTS[113bede3effa1e93792a64dc9da6056cf7eced99]:
    :
    : >>> >>> >>> b'\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00'
    : ('l', 8, 3, 24)
    : >>> >>> b'\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00'
    : ('B', 1, 24, 24)

     一维unsigned char -> 一维char：

     #+BEGIN_SRC python :session
       b = bytearray(b'abc')
       m = memoryview(b)
       m[0] = b'X'

       m1 = m.cast('c')
       m1[0] = b'X'
       print(b)
     #+END_SRC
     
     #+RESULTS[0ce2002c9c7e4fa8a31f24a1ee2b8986f1c96034]:
     :
     : >>> ... >>> >>> >>> bytearray(b'Xbc')
     
     一维byte -> 三维int -> 一维signed char
     #+BEGIN_SRC python :session
      import struct

      buf = struct.pack('i' * 12, *list(range(12)))
      m = memoryview(buf)
      m = m.cast('i', shape=[2, 2, 3])
      m.tolist()
      m.format, m.itemsize, m.ndim, len(m), m.nbytes

      m = m.cast('b')
      m.tolist()
      m.format, m.itemsize, m.ndim, len(m), m.nbytes
     #+END_SRC
     
     #+RESULTS[801de728b7c0b43f5c7dd7636579f21eebd8e9ac]:
    :
    : >>> >>> >>> >>> [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]
    : ('i', 4, 3, 2, 48)
    : >>> >>> [0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 6, 0, 0, 0, 7, 0, 0, 0, 8, 0, 0, 0, 9, 0, 0, 0, 10, 0, 0, 0, 11, 0, 0, 0]
    : ('b', 1, 1, 48, 48)
     
     一维byte -> 二维unsigned long：
     
     #+BEGIN_SRC python :session
       import struct
       buf = struct.pack('i' * 6, *list(range(6)))
       m = memoryview(buf)
       m.tolist()
       m.ndim, m.nbytes

       m = m.cast('i', shape=[2, 3])
       m.tolist()
       m.ndim, m.nbytes
     #+END_SRC
     
     #+RESULTS[7ef5493f0b91c7a0a24e88065645686aa9804589]:
     :
     : >>> >>> [0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0]
     : (1, 24)
     : >>> >>> [[0, 1, 2], [3, 4, 5]]
     : (2, 24)
     
*** 属性
**** *obj*
     返回被memoryview获取的对象：

     #+BEGIN_SRC python :session
       b = bytearray(b'zbc')
       m = memoryview(b)
       m.obj is b

       memoryview(b'xyz').obj
     #+END_SRC

     #+RESULTS[e8e145a1eb99573865f7dcca4614b94265dbfb3a]:
     :
     : >>> True
     : >>> b'xyz'

**** *nbytes*
     在内存中连续表示memoryview的byte数，不一定等于len(m)。

     #+BEGIN_SRC python :session
       from array import array

       a = array('i', [1, 2, 3, 4, 5])
       m = memoryview(a)

       len(m), m.nbytes

       y = m[::2]
       len(y), y.nbytes

       y.tobytes()
     #+END_SRC

     #+RESULTS[dcf44f7928f8ff2f83b659d50546e86360dc0cb6]:
     :
     : >>> >>> >>> >>> (5, 20)
     : >>> >>> (3, 12)
     : >>> b'\x01\x00\x00\x00\x03\x00\x00\x00\x05\x00\x00\x00'

     多维：

     #+BEGIN_SRC python :session
       import struct

       buf = struct.pack('b' * 12, *[x for x in range(97, 109)])
       print(buf)

       x = memoryview(buf)
       y = x.cast('b', shape=[3, 4])
       print(y.tolist())
       print(y.ndim)
       len(y), y.nbytes
     #+END_SRC

     #+RESULTS[fda5df420e910818a3e668615bf721ef294c26d7]:
     :
     : >>> >>> b'abcdefghijkl'
     : >>> >>> >>> [[97, 98, 99, 100], [101, 102, 103, 104], [105, 106, 107, 108]]
     : 2
     : (3, 12)

**** *readonly*
     是否只读。即创建momeryview时的OBJ是否为immutable类型。

     #+BEGIN_SRC python :session
       from array import array

       a = memoryview(b'abc')
       b = memoryview(bytearray(b'abc'))
       c = memoryview(array('B', [97, 98, 99]))

       a.readonly, b.readonly, c.readonly
     #+END_SRC
     
     #+RESULTS[752b0e677dec3793eb7a3352b0f483d29a6f8454]:
     :
     : >>> >>> >>> >>> >>> (True, False, False)

**** *format*
     返回元素类型（对应struct模块中的格式字符）。

     #+BEGIN_SRC python :session
       import struct
       from array import array

       m = memoryview(b'abc')
       m.format

       m = memoryview(struct.pack('2s1i', b'ab', 1))
       m.format

       m = memoryview(array('i', [1, 2, 3]))
       m.format
     #+END_SRC

     #+RESULTS[35cae04c64fec21b827ea057a0483ff5346fd42e]:
     :
     : >>> >>> >>> 'B'
     : >>> >>> 'B'
     : >>> >>> 'i'

**** *itemsize*
     单个元素所在内存大小（不管是否为多维）。
     
     #+BEGIN_SRC python :session
       import array
       import struct
       m = memoryview(array.array('H', [1000, 2000, 3000]))
       m.itemsize, m[0]
       struct.calcsize('H') == m.itemsize

       # 多维
       m = memoryview(struct.pack('H' * 6, *range(6)))
       m = m.cast('H', shape=[2, 3])
       m.itemsize
     #+END_SRC
     
     #+RESULTS[404c722aa9a5df86c9e2e10611586818aba3f465]:
     :
     : >>> >>> (2, 1000)
     : True
     : >>> ... >>> >>> 2
     
**** *ndim*
     返回整数，表示内存表示多维数组的维度。

     #+BEGIN_SRC python :session
       from array import array
       import struct

       m = memoryview(array('i'))
       m.ndim

       m = memoryview(b'abc')
       m.ndim

       m = m.cast('b', shape=[1, 1, 3])
       print(m.tolist())
       m.ndim
     #+END_SRC

     #+RESULTS[ebd0e1ca3e2f93f1274acebb5c00e03a413fc89d]:
     :
     : >>> >>> >>> 1
     : >>> >>> 1
     : >>> >>> [[[97, 98, 99]]]
     : 3

**** *shape*
     返回元组，第一个元素为第一层元素个数，第二个元素为维度（如果>=2）。

     #+BEGIN_SRC python :session
       from array import array
       import struct

       m = memoryview(b'abc')
       m.shape

       m = memoryview(b'')
       m.shape

       buf = struct.pack('i' * 10, *[x for x in range(10)])

       m = memoryview(buf)
       m = m.cast('i', [5, 2])
       print(m.tolist())
       m.shape
     #+END_SRC

     #+RESULTS[c033c0c23dc254ebcc51e2002a25c82a4622bd05]:
     :
     : >>> >>> >>> (3,)
     : >>> >>> (0,)
     : >>> >>> >>> >>> >>> [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]
     : (5, 2)

**** *strides* ？？？
     返回元组，第一个元素为第一层元素所有byte数，第二个元素为单个元素所
     在byte数（当维度>=2时）。

     #+BEGIN_SRC python :session
       import struct
       from array import array

       m = memoryview(array('i', [1, 2, 3]))
       m.strides

       m = memoryview(struct.pack('i' * 6, *[x for x in range(6)]))

       m = m.cast('i', shape=[2, 3])
       print(m.tolist())
       m.strides
     #+END_SRC

     #+RESULTS[ffd9ac7405caddf578da59410de45268d6155b97]:
     :
     : >>> >>> >>> (4,)
     : >>> >>> >>> >>> [[0, 1, 2], [3, 4, 5]]
     : (12, 4)

**** *suboffets* ？？？

     #+BEGIN_SRC python :session
       import struct
       import array

       m = memoryview(b'abc')
       m.suboffsets

       m = memoryview(struct.pack('i' * 10, *list(range(10))))
       m = m.cast('i', [5, 2])
       m.suboffsets
     #+END_SRC

     #+RESULTS[39e91b8f6c0aded9dbc4ed2cab8f323e2d8a42fd]:
     :
     : >>> >>> >>> ()
     : >>> >>> >>> ()

**** *contiguous*

     只要是“C形式连续”或“Fortran形式连续”则“连续”。维度为0的对象，即是C
     形式连续，也是Fortran形式连续。一维数组中，每个元素需连续存储。在
     多维数组中如果要访问单个元素，C形式连续的对象最后一个元素最快，
     Fortran形式中，则是第一个元素最快。？？？

     #+BEGIN_SRC python :session
       import struct

       m = memoryview(b'abc')
       m.contiguous

       # 多维
       buf = struct.pack('b' * 12, *[x for x in range(12)])
       m = memoryview(buf).cast('b', shape=[3, 4])
       m.contiguous
     #+END_SRC

     #+RESULTS[94c1df69a64fe2d11466a46f29ecee366e449d30]:
     :
     : >>> >>> True
     : >>> >>> ... >>> >>> True

**** *c_contiguous*
     是否是C形式连续。

     #+BEGIN_SRC python :session
       memoryview(b'abc').c_contiguous
     #+END_SRC

     #+RESULTS[d79b6ffa0d3f6e8fe1693e045559bc51e725c5c2]:
     : True

**** *f_contiguous*
     是否是Fortran形式连续。

     *？* ：为何相同数据，两种情况都为True。

     #+BEGIN_SRC python :session
       import struct

       memoryview(b'abc').f_contiguous

       s = struct.pack('lh0ll', 1, 2, 3)
       memoryview(s).f_contiguous
     #+END_SRC

     #+RESULTS[ffddbd152879d78363c97c65f769b866a8fe5dab]:
     :
     : >>> True
     : >>> >>> True

* Set类型-set、frozenset
  set对象为无序，没有重复的，“可哈希（hashable）对象”的集合。

  set对象的主要作用包括：元素包含测试，序列去重，数学集合操作，如交集、
  并集、差集和对称差集。

  同其他集合一样，set支持'x in set'、'len(set)'和'for x in set'操作。
  由于是无序序列，set不会记录元素插入时的位置和顺序。因此，也不支持索
  引求值，截断和其他“类序列”操作。

  有两种内置set类型：set和frozenset。set类型为mutable，其中元素可通过
  add()和remove()方法改变，由于为mutable，没有哈希值，不能作为字典的
  key值和其他set的元素。frozenset类型为immutable，可求哈希值，创建后元
  素不可改变；单可用于字典key值和其他set的元素。

  除set构造器外，非空set(不含frozenset)可通过字面量形式创建，
  如'{'jack', 'sjoerd'}'。

  set和frozenset的用法完全相同。

** class *set* ([iterable])
** class *frozenset* ([iterable])
   返回新的set/frozenset，元素为ITERABLE中的元素（自动去重）。ITERABLE
   中的元素须为“可哈希对象”。如果需将set作为元素，须为frozenset。如果
   缺省ITERABLE，则返回新的空对象。

   #+BEGIN_SRC python :session
     l = [1, 2, 1, 2, 1, 2, 1, 2]
     set(l), frozenset(l)
     set(), frozenset()
   #+END_SRC

   #+RESULTS[63de2b9bfd88afbfff1170d3cb9f2aa4308cfaa8]:
   :
   : ({1, 2}, frozenset({1, 2}))
   : (set(), frozenset())

** set和frozenset通用操作
*** *len(s)*
    返回S中元素的个数。

    #+BEGIN_SRC python :session
      len(set([1, 2, 3, 1, 2]))
    #+END_SRC

    #+RESULTS[9613d60a78f5e5028ae3966f175a3ab4b8d231bd]:
    : 3

*** *x in s*
    S中是否不含X。

    #+BEGIN_SRC python :session
      1 in set([1, 2, 1, 2])
      10 in set([1, 2, 1, 2])
    #+END_SRC

    #+RESULTS[b9f55b0f64d4f744b27372a48ad374dd2f90d489]:
    : True
    : False

*** *x not in s*
    S中是否不含X。

    #+BEGIN_SRC python :session
      1 not in set([1, 2, 1, 2])
      10 not in set([1, 2, 1, 2])
    #+END_SRC

    #+RESULTS[4fc9fa3c0766cb1ae25cb33b06e48e2c04171d83]:
    : False
    : True

*** *isdisjoint* (other)
    如果元素没有一个与OTHER中的元素相等，则返回True。即两者交集为空set
    时返回True。

    #+BEGIN_SRC python :session
      s = set([1, 2, 3])
      s.isdisjoint([4, 5, 6])
      s.isdisjoint(range(3, 10))
    #+END_SRC

    #+RESULTS[42a977d90f9d7485cdaaba926734b0b5d5d3f995]:
    :
    : True
    : False

*** *issubset* (other)
*** *set <= other*
    如果所有元素都在OTHER中，则返回True。

    #+BEGIN_SRC python :session
      s = set([1, 2, 3])
      s.issubset(range(4))
      s <= set(range(4))

      s.issubset(range(2))
      s <= set(range(2))
    #+END_SRC

    #+RESULTS[c5412fb90efe18e7f10db9b4f09e32ec3f6dcea7]:
    :
    : True
    : True
    : >>> False
    : False
*** *set < other*
    是否为OTHER的子集，且差集为空。等价于set <= other and set != other。

    #+BEGIN_SRC python :session
      set(range(2)) < set(range(3))
      set(range(2)) < set(range(2))
    #+END_SRC

    #+RESULTS[8d773d302f84fe8e78a9d3e8e6e3a2ee6adac4bd]:
    : True
    : False

*** *issuperset* (other)
*** *set >= other*
    如果OTHER中的所有元素都有，则返回True。

    #+BEGIN_SRC python :session
      s = set([1, 2, 3])
      s.issuperset(range(1, 3))
      s >= set(range(1, 3))

      s.issuperset(range(3))
      s >= set(range(3))
    #+END_SRC

    #+RESULTS[97353492929c65f232551911b3c6a5dec72082dc]:
    :
    : True
    : True
    : >>> False
    : False

*** *set > other*
    等价于's >= other and s != other'

    #+BEGIN_SRC python :session
      set([1, 2, 3]) > set([1, 2, 3])
      set([1, 2, 3]) > set([1, 2])
    #+END_SRC

    #+RESULTS[e01dcbef4f65620914ccf3c7252bddbc66534c7f]:
    : False
    : True

*** *union* (*others)
*** *set | other | ...*
    返回新set，其中包含set和OTHERS中所有元素。

    #+BEGIN_SRC python :session
      s = set([1, 2, 3])
      s1 = set(range(3))
      s2 = set(range(3, 10))
      s.union(s1, s2)
      s | s1 | s2
    #+END_SRC

    #+RESULTS[1b782b943963bc7111700919974022dccbd63327]:
    :
    : >>> >>> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    : {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

*** *intersection* (*others)
*** *set & other & ...*
    返回新set，只含set和OTHERS中都有的元素。

    #+BEGIN_SRC python :session
      s = set(range(3))
      s1 = set(range(2, 5))
      s2 = set(range(2, 10))
      s.intersection(s1, s2)
      s & s1 & s2
    #+END_SRC

    #+RESULTS[49ae4ce78b4cbf10dc184cd20bab4b5037e19ed6]:
    :
    : >>> >>> {2}
    : {2}

*** *difference* (*others)
*** *set - other - ...*
    返回新set，只含set中有而OTHERS中没有的元素。

    #+BEGIN_SRC python :session
      s = set(range(3))
      s1 = set(range(2, 5))
      s2 = set(range(1, 5))

      s.difference(s1, s2)
      s - s1 - s2
    #+END_SRC

    #+RESULTS[c65fb9e62f01e71da0050bc1b84203c021d1bdb4]:
    :
    : >>> >>> >>> {0}
    : {0}

*** *symmetric_difference* (other)
*** *set ^ other*
    返回新set，去除两者都包含的元素。

    #+BEGIN_SRC python :session
      s1 = set(range(1, 5))
      s2 = set(range(1, 10))

      s1.symmetric_difference(s2)
      s1 ^ s2
    #+END_SRC

    #+RESULTS[c3b212af11caa3361aa98501f02ceaed52bb3b4b]:
    :
    : >>> >>> {5, 6, 7, 8, 9}
    : {5, 6, 7, 8, 9}

*** *copy* ()
    
    #+BEGIN_SRC python :session
      s = set([1, 2, 3, (4, 5, 6)])
      s1 = s.copy()

      s1, s1 is s
    #+END_SRC
    
    #+RESULTS[4e5a92d18bebd6d69460a738698ae96f238884aa]:
    :
    : >>> >>> ({1, 2, 3, (4, 5, 6)}, False)
    
*** *注意*
    
    - union、intersection、difference、symmetric_difference、issubset
      和issupperset方法的参数只要是iterable类型即可。但对应的简写形式
      则需也为set类型。尽量避免使用简写形式，如set('abc') & 'abc'；使
      用更易读的全写形式，set('abc').intersection('abc')。
    - set/frozenset支持相互比较。两个set互为子集则相等，A为B的超集则
      A>B，A为B的子集则A<B。
      
      #+BEGIN_SRC python :session
        set([1, 2, 3]) == set([3, 2, 1])
        set([1, 2, 3]) > set([1, 2])
      #+END_SRC
      
      #+RESULTS[b404bbafe937d8a38e47bdbef40fec0f32ec3790]:
      : True
      : True
      
    - set与frozenset间的比较只考虑各自的元素。
      
      #+BEGIN_SRC python :session
         set('abc') == frozenset('abc')
         set('abc') in set([frozenset('abc')])
      #+END_SRC
      
      #+RESULTS[89677d60a682dc2b1aa99bc0ef7d803459e38172]:
      : True
      : True
      
    - 如果两个非空set交集为空集，则a<b、a==b、a>b都会返回False。
      
      #+BEGIN_SRC python :session
         s1 = set([1, 2, 3])
         s2 = set([4, 5, 6])
         s1 < s2, s1 == s2, s1 > s2
      #+END_SRC
      
    - 由于set只定义了集合关系，不能使用list.sort()方法操作set链表获得
      正确值。
      
      #+BEGIN_SRC python :session
        l = [3, 2, 1]
        l.sort()
        print(l)

        l = [set([1, 2]), set([3, 4]), set([4, 5])]
        l.sort(reverse=True)
        print(l)
      #+END_SRC

      #+RESULTS[a49c1f4784f0e33df5da49ac5645f14471d91358]:
      :
      : >>> [1, 2, 3]
      : >>> >>> >>> [{1, 2}, {3, 4}, {4, 5}]

    - 当二元操作符的操作对象一个为set，一个为frozenset时，返回结果与第
      一个相同。

      #+BEGIN_SRC python :session
        set('ab') | frozenset('bc')
        frozenset('ab') | set('bc')
      #+END_SRC

      #+RESULTS[2a165e4c07c3b514b14519f53e203de0296f27ab]:
      : {'a', 'b', 'c'}
      : frozenset({'a', 'b', 'c'})

** 只有set有frozenset没有的操作
*** *update* (*others)
*** *set |= other | ...*
    将OTHERS中的所有元素添加。

    #+BEGIN_SRC python :session
      s = set(range(3))
      s1 = set(range(3, 6))
      s2 = set(range(6, 10))

      s.update(s1, s2)
      # s |= s1 | s2
      print(s)
    #+END_SRC

    #+RESULTS[f2edb8a066b7e961c8638a70c4cc9d0f7963e40d]:
    :
    : >>> >>> >>> >>> ... {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

*** *intersection_update* (*others)
*** *set &= other & ...*
    将SET中的元素过滤为自身和OTHERS中都含有的元素。

    #+BEGIN_SRC python :session
      s = set(range(3))
      s1 = set(range(2, 10))
      s.intersection_update(s1)
      # s &= s1
      print(s)
    #+END_SRC

    #+RESULTS[0108a6063f146cd253e6fbd143e80ac87bcb82da]:
    :
    : >>> >>> ... {2}

*** *difference_update* (*others)
*** *set -= other | ...*
    去除自身不在OTHERS中的元素。

    #+BEGIN_SRC python :session
      s = set(range(3))
      s1 = set(range(2, 10))
      s.difference_update(s1)
      # s -= s1
      print(s)
    #+END_SRC

    #+RESULTS[254712a38f7ae21a3530e68b8f1972a869840d3f]:
    :
    : >>> >>> ... {0, 1}

*** *symmetric_difference_update* (other)
*** *set ^= other*
    仅保留不同时在自身和OTHERS中的元素。

    #+BEGIN_SRC python :session
      s = set([1, 2, 3])
      s1 = set([1, 2])
      # s ^= s1
      s.symmetric_difference_update(s1)
      print(s)
    #+END_SRC

    #+RESULTS[ebeff3199e76d1e178cf1be9cf008ebb8037df5d]:
    :
    : >>> ... >>> {3}

*** *add* (elem)
    在set中添加元素ELEM。

    #+BEGIN_SRC python :session
      s = set([1, 2, 3])
      s.add(4)
      print(s)
    #+END_SRC

    #+RESULTS[164d55787c9b6c38edeed4f9c86079add8772c2e]:
    :
    : >>> {1, 2, 3, 4}

*** *remove* (elem)
    删除set中的ELEM元素，如果ELEM不存在，则返回KeyError错误。
    #+BEGIN_SRC python :session
      s = set([1, 2, 3])
      s.remove(1)
      print(s)
      s.remove(100)
      print(s)
    #+END_SRC

    #+RESULTS[6c3012fb765127ce811241d0e9b21aa040430c08]:
    :
    : >>> {2, 3}
    : Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : KeyError: 100
    : {2, 3}

*** *discard* (elem)
    当set中有ELEM元素时才移除。

    #+BEGIN_SRC python :session
      s = set([1, 2, 3])
      s.discard(1)
      print(s)
      s.discard(100)
      print(s)
    #+END_SRC

    #+RESULTS[84cd8f9a6f002576bb1e6f6adebe66c814c46c7c]:
    :
    : >>> {2, 3}
    : >>> {2, 3}

*** *pop* ()
    删除set中任意一个元素，返回删除元素。如果set为空，则返回KeyError错
    误。

    #+BEGIN_SRC python :session
      s = set([1, 2, 3])
      for i in range(4):
          print(s.pop(), s)
    #+END_SRC

    #+RESULTS[5163984fb033f12492031e8f59c87773ac113ed9]:
    :
    : ... ... 1 {2, 3}
    : 2 {3}
    : 3 set()
    : Traceback (most recent call last):
    :   File "<stdin>", line 2, in <module>
    : KeyError: 'pop from an empty set'
    
*** *clear* ()
    清空set。
    
    #+BEGIN_SRC python :session
      s = set([1, 2, 3])
      s.clear()
      print(s)
    #+END_SRC
    
    #+RESULTS[adfb057e204c950a4bc0c63dab9c0d41ef46dd7c]:
    :
    : >>> set()
    
    *注意* ：
    
    - update、intersection_update、difference_update和
      symmetric_difference_update方法可接受任意iterable类型作为参数。
      
    - __contains__()、remove()和discard()的参数可以是frozenset对象。为
      做比较，在搜索和重置过程中ELEM为mutable形式。在搜索过程中不要读
      取或改变此元素。
      
* 映射类型（Mapping）-dict
  映射对象可将“可哈希值”映射到任意对象上。映射对象为mutable类型。目前
  为止，Python只有一个标准的映射类型-字典（dict）。
  
  除“不可哈希”类型，即含链表，字典或其他mutable类型（比较时使用值比较，
  而不是内存比较）外，都可用作字典的key值。当使用数数字作为key值时，使
  用值比较，如1和1.0都可映射到同一值。（由于计算机存储浮点数实际上是存
  储的近似值，所以最好不要用浮点数作为key值。）
  
  除dict构造器外，可使用使用字面量形式创建字典：
  
  #+BEGIN_SRC python :session
    d = {'name': 'claudio', 'age': 18, 'gender': 'male'}
  #+END_SRC
  
** class *dict* (**kwarg)
** class *dict* (mapping,**kwarg)
** class *dict* (iterable,**kwarg)
   根据可选参数和关键字参数返回新的字典对象。
   
   - 如果没有参数，返回空字典。
   - 如果只有一个参数：
     - 如果为映射对象，则新生成字典与其有相同的键值对。
     - 否则须为iterable类型，其每个元素须为有2个元素的iterable类型，第
       一个元素成为key值，第二个元素成为value值。如果key值重复，则后面
       出现的value值为最终值。
   - 如果有关键字参数，则各个关键字参数成为字典的键值对。如果不只第一
     个参数，则添加到第一个参数生成的字典后；如果key值有重复。则关键字
     参数的值成为最终值。
     
   为演示不同构建方法，下面每种方法都会生成相同的字典：
   
   #+BEGIN_SRC python :session
     a = dict(one=1, two=2, three=3)
     b = {'one': 1, 'two': 2, 'three': 3}
     c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
     d = dict([('two', 2), ('one', 1), ['three', 3]])
     e = dict({'three': 3, 'two': 2, 'one': 1})

     a == b == c == d == e
   #+END_SRC
   
   #+RESULTS[6e9e0b8dd1d9e321b87fc3c7593b320b1bf16d46]:
   :
   : >>> >>> >>> >>> >>> True
   
** Dict类型支持的操作
   下面为Dict类型支持的操作。（自定义映射类型也用该支持下面的操作）。

*** *len(d)*
    返回键值对个数。

    #+BEGIN_SRC python :session
      d = {'a': 1, 'b': 2, 'c': 3}
      len(d)
    #+END_SRC

    #+RESULTS[2dd6e204a93d6a4c18875d24a72496b1993f0b53]:
    :
    : 3

*** *d[key]*
    返回KEY对应的值。如果KEY不存在，则返回KeyError错误。

    #+BEGIN_SRC python :session
      d = {'a': 1, 'b': 2, 'c': 3}

      d['a']
      d['A']
    #+END_SRC

    #+RESULTS[45733b4152773b1781074b5e8ee2879873763b2d]:
    :
    : >>> 1
    : Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : KeyError: 'A'

    如果dict类型的子类定义了__missing__()方法，则调用d[key]时，如果key
    不存在，则返回该方法的返回值，或返回该方法抛出的错误。

    #+BEGIN_SRC python :session
      class Counter(dict):
          def __missing__(self, key):
              return 0

      c = Counter()
      c['blue']

      c['blue'] += 1
      c['blue']
    #+END_SRC

    #+RESULTS[c032d9a3f092881b927acf8f4059538bae2dd136]:
    :
    : ... ... >>> >>> >>> 0
    : >>> >>> 1

*** *d[key] = value*
    将KEY对应的值设置为VALUE。如果KEY不存在，则创建。

    #+BEGIN_SRC python :session
      d = {'a': 1, 'b': 2, 'c': 3}

      d['a'] = 10
      print(d)

      d['d'] = 4
      print(d)
    #+END_SRC

    #+RESULTS[44b9c50878a2e79a1caa96b4789ef906f885fb4f]:
    :
    : >>> >>> {'a': 10, 'b': 2, 'c': 3}
    : >>> >>> {'a': 10, 'd': 4, 'b': 2, 'c': 3}

*** *del d[key]*
    将KEY对应的键值对删除，如果KEY不存在，则返回KeyError错误。

    #+BEGIN_SRC python :session
      d = {'a': 1, 'b': 2, 'c': 3}
      del d['a']
      print(d)

      del d['A']
      print(d)
    #+END_SRC

    #+RESULTS[4a45e5f23fbd8a16de7b0cf40a4344995a3df46b]:
    :
    : >>> {'b': 2, 'c': 3}
    : >>> Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : KeyError: 'A'
    : {'b':    2, 'c': 3}

*** *key in d*
    KEY是否为D的key值。

    #+BEGIN_SRC python :session
      d = {'a': 1, 'b': 2, 'c': 3}
      'a' in d, 'A' in d
    #+END_SRC

    #+RESULTS[25b6e0424eaf0dadeb034be74b0fe99793b3b262]:
    :
    : (True, False)

*** *key not in d*
    相当于not key in d。
*** *iter(d)*
    返回D的所有key值组成的iterator对象。实际上为iter(d.keys())的简写。

    #+BEGIN_SRC python :session
      d = {'a': 1, 'b': 2, 'c': 3}

      i1 = iter(d)
      i2 = iter(d.keys())
      print(i1)
      print(i2)

      list(i1), list(i2)
    #+END_SRC

    #+RESULTS[d6188383cf7c13b8d003ace4ba2911f37c751ebd]:
    :
    : >>> >>> >>> <dict_keyiterator object at 0x7f22c154b818>
    : <dict_keyiterator object at 0x7f22c1544098>
    : >>> (['a', 'b', 'c'], ['a', 'b', 'c'])

*** *clear* ()
    清空所有内容。

    #+BEGIN_SRC python :session
      d = {'a': 1, 'b': 2, 'c': 3}

      d.clear()
      print(d)
    #+END_SRC

    #+RESULTS[a3a855600237f696408dde8bdde97452266395c3]:
    :
    : >>> >>> {}

*** *copy* ()
    返回“浅层复制”的字典。

    #+BEGIN_SRC python :session
      d = {'a': [1, 2, 3], 'b': (4, 5, 6)}
      d1 = d.copy()
      print(d1)

      d1['a'].append(4)
      print(d)
      print(d1)
    #+END_SRC

    #+RESULTS[9ae101171c8349407999491bea80a1453e3641a4]:
    :
    : >>> {'a': [1, 2, 3], 'b': (4, 5, 6)}
    : >>> >>> {'a': [1, 2, 3, 4], 'b': (4, 5, 6)}
    : {'a': [1, 2, 3, 4], 'b': (4, 5, 6)}

*** classmethod *fromkeys* (seq[,value])
    类方法，返回字典，SEQ中的各个元素成为key值，对应的值都为VALUE。

    如果VALUE缺省，则所有值都为None。

    #+BEGIN_SRC python :session
      dict.fromkeys('abc')
      dict.fromkeys('abc', [1, 2])
    #+END_SRC

    #+RESULTS[588fce7b98136278796dcb8a785a7460f8ae95b5]:
    : {'a':    None, 'b': None, 'c': None}
    : {'a':    [1, 2], 'b': [1, 2], 'c': [1, 2]}

*** *get* (key[,default])
    返回KEY对应的值，如果KEY不存在则返回DEFAULT对应的值。DEFAULT的默认
    值为None，所以方法不会返回KeyError错误。

    #+BEGIN_SRC python :session
      d = {'a': 1, 'b': 2, 'c': 3}

      d.get('a')
      d.get('A', 100)
      print(d.get('A'))
    #+END_SRC

    #+RESULTS[a363d6b5554bbe048ab78a5eac4d82fddae856a4]:
    :
    : >>> 1
    : 100
    : None

*** *items* ()
    返回字典键值对组成的view对象。

    #+BEGIN_SRC python :session
      d = {'a': 1, 'b': 2, 'c': 3}

      x = d.items()
      print(x)
      type(x)
    #+END_SRC

    #+RESULTS[9791e75308de1b93862e8f11df090906cdde07ae]:
    :
    : >>> >>> dict_items([('a', 1), ('b', 2), ('c', 3)])
    : <class 'dict_items'>

*** *keys* ()
    返回字典所有key值组成的view对象。

    #+BEGIN_SRC python :session
      d = {'a': 1, 'b': 2, 'c': 3}
      x = d.keys()
      print(x)
      type(x)
    #+END_SRC

    #+RESULTS[b568db3a6e2e98d1cefbb8ef59e351d3cb697144]:
    :
    : >>> dict_keys(['a', 'b', 'c'])
    : <class 'dict_keys'>

*** *pop* (key[,default])
    将KEY对应的键值对从字典中移除，返回KEY对应的值。

    如果KEY不存在，则返回DEFAULT；如果DEFAULT参数也缺省，则返回
    KeyError错误。

    #+BEGIN_SRC python :session
      d = {'a': 1, 'b': 2, 'c': 3}

      d.pop('a')
      d.pop('A', 100)
      d.pop('A')
      print(d)
    #+END_SRC

    #+RESULTS[465a7cbdc4bde64f6c33e8e49a840c4a204f3746]:
    :
    : >>> 1
    : 100
    : Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : KeyError: 'A'
    : {'b':    2, 'c': 3}

*** *popitem* ()
    删除任意键值对，返回被删除键值对组成的元组。如果字典为空，则返回
    KeyError错误。

    #+BEGIN_SRC python :session
      d = {'a': 1, 'b': 2}
      d.popitem()
      d.popitem()
      d.popitem()
    #+END_SRC

    #+RESULTS[62eb195a939bab78d6c9e38f9730c3a8a3c24821]:
    :
    : ('a', 1)
    : ('b', 2)
    : Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : KeyError: 'popitem(): dictionary is empty'

    此方法在结构历遍字典时非常有用（常用于集合算法）。？？？

*** *setdefault* [key[,default]]
    如果字典中有KEY，则返回其对应的值。如果无KEY，则添加此键值对，并返
    回DEFAULT。DEFAULT的默认值为None。

    #+BEGIN_SRC python :session
      d = {'a': 1, 'b': 2, 'c': 3}

      d.setdefault('a', 100)
      print(d)

      d.setdefault('A', 100)
      print(d)

      d.setdefault('Z')
      print(d)
    #+END_SRC

    #+RESULTS[0b9d472cbcc5ca4b8ee81ecb674aae0ea3627983]:
    :
    : >>> 1
    : {'a': 1, 'b': 2, 'c': 3}
    : >>> 100
    : {'A': 100, 'a': 1, 'b': 2, 'c': 3}
    : >>> >>> {'A': 100, 'a': 1, 'b': 2, 'Z': None, 'c': 3}

*** *update* ([other])
    更新字典的键值对，覆盖已有键值对，返回值为None。

    参数可为：

    - 另一个字典
    - iterable对象，需每个元素都含2个元素。
    - 关键字参数。

    #+BEGIN_SRC python :session
      d = {'a': 1, 'b': 2, 'c': 3}

      # 覆盖原来键值对
      d.update(a=100)
      print(d)
      # 参数为字典
      d.update({'e': 4, 'f': 5})
      print(d)

      # 参数为其他iterable对象
      d.update([['g', 6], ('h', 7)])
      print(d)

      # 关键字参数
      d.update(i=8, j=9)
      print(d)
    #+END_SRC

    #+RESULTS[ab0db07d040c5d35425024ada5dfb2f01947d60f]:
    :
    : >>> ... >>> {'a': 100, 'b': 2, 'c': 3}
    : ... >>> {'e': 4, 'a': 100, 'f': 5, 'b': 2, 'c': 3}
    : >>> ... >>> {'g': 6, 'h': 7, 'a': 100, 'b': 2, 'e': 4, 'f': 5, 'c': 3}
    : >>> ... >>> {'i': 8, 'g': 6, 'h': 7, 'a': 100, 'b': 2, 'j': 9, 'e': 4, 'f': 5, 'c': 3}

*** *values* ()
    返回所有值组成的view对象。

    #+BEGIN_SRC python :session
      d = {'a': 1, 'b': 2, 'c': 3}

      d.values()
    #+END_SRC

    #+RESULTS[d819a119acea0fea8e041e5ef92f63edf875f5fe]:
    :
    : >>> dict_values([1, 2, 3])

** Dictionary View 对象
   dict.keys()、dict.values()和dict.items()返回的对象都为 /view/ 对象。
   当字典中的键值对发生变化时，他们的值也会随之变化。

   字典view对象支持历遍操作和包含测试：

*** *len(dictview)*
    返回字典键值对个数，相当于len(d)。

    #+BEGIN_SRC python :session
      d = {'a': 1, 'b': 2, 'c': 3}
      len(d.keys()), len(d)
    #+END_SRC

    #+RESULTS[1c52c1299998cc326111eacbc9812cc38278d5c9]:
    :
    : (3, 3)

*** *iter(dictview)*
    将keys、values、items生成的view类型转换为迭代对象。其中items转换成
    的迭代对象中，各个键值对用元组表示。

    #+BEGIN_SRC python :session
      d = {'a': 1, 'b': 2, 'c': 3}
      ks = iter(d.keys())
      vs = iter(d.values())
      items = iter(d.items())

      type(ks), type(vs), type(items)

      for k in ks:
          print(k)

      for v in vs:
          print(v)

      for item in items:
          print(item)
    #+END_SRC

    #+RESULTS[0f20d8d0266efcb8e933b2dc9205c2802325ed76]:
    #+begin_example

    >>> >>> >>> >>> (<class 'dict_keyiterator'>, <class 'dict_valueiterator'>, <class 'dict_itemiterator'>)
    >>> ... ... a
    b
    c
    ... ... 1
    2
    3
    >>> ... ... ('a', 1)
    ('b', 2)
    ('c', 3)
    #+end_example

    键和值的顺序并不是随机的，由Python实现、字典删除和插入历史决定。在
    使用键和值组成的view时，如果字典本身没有改变，则两者每个元素一一对
    应。即：

    #+BEGIN_SRC python :session
      d = {'a': 1, 'c': 3, 'b': 2}
      pairs1 = zip(d.values(), d.keys())
      pairs2 = [(v, k) for (v, k) in d.items()]
      print(list(pairs1))
      print(pairs2)
    #+END_SRC

    #+RESULTS[2bb1c2257851e413af4bb218c48ad49af77b7657]:
    :
    : >>> >>> [(1, 'a'), (2, 'b'), (3, 'c')]
    : [('a', 1), ('b', 2), ('c', 3)]

    历遍键和值组成的view对象时，如果向字典中添加或删除键值对，可能返回
    RuntimeError错误，或不能历遍整个view。

*** *x in dictview*
    当X在字典的键、值或键值对组成的view中时返回True。最后一种情况X应为元组(key,
    value)。

    #+BEGIN_SRC python :session
      d = {'a': 1, 'b': 2, 'c': 3}

      'a' in d.keys()
      1 in d.values()
      ('a', 1) in d.items()
    #+END_SRC

    #+RESULTS[f88f0a059db876d9d14d7c767177772d4dcdf878]:
    :
    : >>> True
    : True
    : True

*** 类似集合（set）的操作
    由字典keys组成的view类似于set类型，因为每个元素的都不同，且“可哈希”。
    如果所有的值都“可哈希”，则键值对组成的元组(key, value)也“可哈希”，
    进一步则items组成的view可“可哈希”。对于“类set”形似的view对象，可使
    用collections.abc.Set定义的所有操作，如==、<和>。

    #+BEGIN_SRC python :session
     d1 = {'a': 1, 'b': 2, 'c': 3}
     d2 = {'b': 20, 'e': 30, 'f': 40}

     d1.keys() & d2.keys()
     d1.keys() | d2.keys()
     d1.items() | d2.items()
    #+END_SRC

    #+RESULTS[6a6001bf76540a0898f4747c1cc87430addf38db]:
   :
   : >>> >>> {'b'}
   : {'a', 'b', 'e', 'c', 'f'}
   : {('c', 3), ('b', 2), ('b', 20), ('e', 30), ('a', 1), ('f', 40)}

*** 举例

    #+BEGIN_SRC python :session
      dishes = {'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500}
      keys = dishes.keys()
      values = dishes.values()

      # 历遍
      n = 0
      for val in values:
          n += val

      print(n)

      # 键和值组成的view位置一一对应
      list(keys)
      list(values)

      # view会根据原字典动态变化
      del dishes['eggs']
      del dishes['sausage']
      list(keys)
      list(values)

      # 使用set的操作符
      keys & {'eggs', 'bacon', 'salad'}
      keys ^ {'sausage', 'juice'}
    #+END_SRC

    #+RESULTS[71beae3d361bc0a7947a9b2e6c22dd4274f544f8]:
    :
    : >>> >>> >>> ... >>> ... ... >>> 504
    : >>> ... ['sausage', 'eggs', 'bacon', 'spam']
    : [1, 2, 1, 500]
    : >>> >>> ... >>> >>> ['bacon', 'spam']
    : [1, 500]
    : >>> ... {'bacon'}
    : {'sausage', 'bacon', 'juice', 'spam'}

* 上下文管理器（Context Manager） 类型
  Python的 /with/ 声明支持上下文管理器定义的的运行时上下文。自定义类
  型可定义__enter__()和__exit__()方法，分别在with语句的代码执行前执行，
  和with语句结束后执行。

** contextmanager. *__enter__* ()：
   进入上下文时执行，返回自身对象或与运行时上下问相关的对象。返回值可
   用于赋值with语句as后面的变量：

   #+BEGIN_SRC python :session
     class Test:
         def __enter__(self):
             print('enter')
             return 100
         def __exit__(self, *exc):
             print('exit')

     with Test() as x:
         print('within with')
         print(x)
   #+END_SRC

   #+RESULTS[fd634b03f7cf2878cc80b10f83746dbb5f059e3c]:
   :
   : ... ... ... ... ... >>> >>> ... ... ... enter
   : within with
   : 100
   : exit
   
** contextmanager. *__exit__* (exc_type,exc_val,exc_tb)：
   离开运行时上下文执行，即在with语句结束后执行，返回Boolean值指定是否
   抑制错误抛出：
   
   #+BEGIN_SRC python :session
     class Test:
         def __init__(self, flag):
             self.flag = flag
         def __enter__(self):
             print('enter')
             return self
         def __exit__(self, *exc):
             print('exit')
             return self.flag

     with Test(True):
         print('within with')
         1 / 0

     with Test(False):
         print('within with')
         1 / 0
   #+END_SRC
   
   #+RESULTS[3102b035beb49a1d816cd396b3f479674785eed1]:
   #+begin_example
   
   ... ... ... ... ... ... ... ... >>> >>> ... ... ... enter
   within with
   exit
   >>> ... ... ... enter
   within with
   exit
   Traceback (most recent call last):
     File "<stdin>", line 3, in <module>
   ZeroDivisionError: division by zero
   #+end_example
   
   如果执行with内代码时有错误抛出，其参宿EXC_TYPE、EXC_VAL和EXC_TB分别
   对应该错误的exception类型、value和traceback信息，否则都为None：
   
   #+BEGIN_SRC python :session
     class Test:
         def __init__(self, flag):
             self.flag = flag
         def __enter__(self):
             return self
         def __exit__(self, exc_type, exc_val, exc_tb):
             print(exc_type)
             print(exc_val)
             print(exc_tb)
             return self.flag

     with Test(True):
         1 / 1

     print(('-' * 10))

     with Test(True):
         1 / 0

     print(('-' * 10))

     with Test(False):
         1 / 0
   #+END_SRC
   
   #+RESULTS[cb05f44472c83f8ac1e23b63b358bf357938efe7]:
   #+begin_example
   
   ... ... ... ... ... ... ... ... ... >>> >>> ... ... 1.0
   None
   None
   None
   ----------
   >>> ... ... <class 'ZeroDivisionError'>
   division by zero
   <traceback object at 0x7ffafde7f708>
   ----------
   >>> ... ... <class 'ZeroDivisionError'>
   division by zero
   <traceback object at 0x7ffafde7f708>
   Traceback (most recent call last):
     File "<stdin>", line 2, in <module>
   ZeroDivisionError: division by zero
   #+end_example
   
   如果此方法返回True，即使with语句中有错误抛出，也会执行后面的代码；
   如果有错误抛出且返回False，则抛出错误向上传播（propagation）：
   
   *注意* ：下面的例子只能在脚本中测试，org中测试会失败：
   
   #+BEGIN_SRC python :eval never
     class Test:
         def __init__(self, flag):
             self.flag = flag
         def __enter__(self):
             return self
         def __exit__(self, exc_type, exc_val, exc_tb):
             return self.flag

     msg = 'msg'
     with Test(True):
         msg = 'hello'
         1 / 0

     print(msg)

     with Test(False):
         1 / 0

     msg = 'i am here, help...'
     print(msg)
   #+END_SRC
   
   此方法中任何的错误抛出，会替换掉with语句中的错误抛出？？？：
   
   #+BEGIN_SRC python :session
     class Test:
         def __enter__(self):
             return self
         def __exit__(self, exc_type, exc_val, exc_tb):
             open('not-exists.txt', 'r')
             # raise Exception
             print(exc_type)
             print(exc_val)
             print(exc_tb)
             # return True

     with Test():
         1 / 0
   #+END_SRC
   
   #+RESULTS[46fd8c34e5daf36d3cce74cb1e4a6892df5643fa]:
   #+begin_example

   ... ... ... ... ... ... ... ... ... >>> >>> ... ... Traceback (most recent call last):
     File "<stdin>", line 2, in <module>
   ZeroDivisionError: division by zero

   During handling of the above exception, another exception occurred:

   Traceback (most recent call last):
     File "<stdin>", line 2, in <module>
     File "<stdin>", line 5, in __exit__
   FileNotFoundError: [Errno 2] No such file or directory: 'not-exists.txt'
   #+end_example

* 其他内置类型
  解释器还支持下面几类对象，他们大多数只支持一个或两个操作。
  
** 模块（Modules）
   能对模块进行的特殊操作仅有属性： /m.name/ 。其中M为模块，NAME为模块
   M中symbol table的内容。模块的属性可被赋值。

   #+BEGIN_SRC python :session
     import contextlib

     contextlib.x = 1
     print(contextlib.x)

     int.x = 1
     print(int.x)
   #+END_SRC

   #+RESULTS[0f50cb3dba0c21eef13efafbad49581600ebabb2]:
   :
   : >>> >>> 1
   : >>> Traceback (most recent call last):
   :   File "<stdin>", line 1, in <module>
   : TypeError: can't set attributes of built-in/extension type 'int'
   : Traceback (most recent call last):
   :   File "<stdin>", line 1, in <module>
   : AttributeError: type object 'int' has no attribute 'x'

   每个模块都有特殊属性__dict__。类型为字典，包含模块的symbol table。
   修改此字典就可修改模块的symbol table。不能直接赋值此字典，
   如'm.__dict__={}'，只能单个赋值，如'm.__dict__['x']=1'。

   *注意* ：不建议修改此值。

   #+BEGIN_SRC python :session
     print(int.__dict__)
     int.__dict__['a'] = 1
     print(int.__dict__['a'])
     int.__dict__ = {}
   #+END_SRC

   #+RESULTS[8d4c8d38b65e71c19368b98f09d1d28db694aef1]:
   #+begin_example
   {'__xor__': <slot wrapper '__xor__' of 'int' objects>, '__float__': <slot wrapper '__float__' of 'int' objects>, '__mul__': <slot wrapper '__mul__' of 'int' objects>, '__or__': <slot wrapper '__or__' of 'int' objects>, '__format__': <method '__format__' of 'int' objects>, '__index__': <slot wrapper '__index__' of 'int' objects>, '__bool__': <slot wrapper '__bool__' of 'int' objects>, 'real': <attribute 'real' of 'int' objects>, 'numerator': <attribute 'numerator' of 'int' objects>, '__pos__': <slot wrapper '__pos__' of 'int' objects>, 'bit_length': <method 'bit_length' of 'int' objects>, '__rxor__': <slot wrapper '__rxor__' of 'int' objects>, '__rsub__': <slot wrapper '__rsub__' of 'int' objects>, 'denominator': <attribute 'denominator' of 'int' objects>, '__lt__': <slot wrapper '__lt__' of 'int' objects>, '__int__': <slot wrapper '__int__' of 'int' objects>, 'conjugate': <method 'conjugate' of 'int' objects>, '__new__': <built-in method __new__ of type object at 0x5601af4729a0>, '__round__': <method '__round__' of 'int' objects>, '__rfloordiv__': <slot wrapper '__rfloordiv__' of 'int' objects>, '__rand__': <slot wrapper '__rand__' of 'int' objects>, '__eq__': <slot wrapper '__eq__' of 'int' objects>, '__rmod__': <slot wrapper '__rmod__' of 'int' objects>, '__hash__': <slot wrapper '__hash__' of 'int' objects>, '__rtruediv__': <slot wrapper '__rtruediv__' of 'int' objects>, '__le__': <slot wrapper '__le__' of 'int' objects>, '__floordiv__': <slot wrapper '__floordiv__' of 'int' objects>, '__and__': <slot wrapper '__and__' of 'int' objects>, '__abs__': <slot wrapper '__abs__' of 'int' objects>, '__rdivmod__': <slot wrapper '__rdivmod__' of 'int' objects>, '__divmod__': <slot wrapper '__divmod__' of 'int' objects>, '__radd__': <slot wrapper '__radd__' of 'int' objects>, '__floor__': <method '__floor__' of 'int' objects>, '__trunc__': <method '__trunc__' of 'int' objects>, '__ror__': <slot wrapper '__ror__' of 'int' objects>, '__repr__': <slot wrapper '__repr__' of 'int' objects>, '__mod__': <slot wrapper '__mod__' of 'int' objects>, '__ge__': <slot wrapper '__ge__' of 'int' objects>, '__add__': <slot wrapper '__add__' of 'int' objects>, '__rmul__': <slot wrapper '__rmul__' of 'int' objects>, '__getnewargs__': <method '__getnewargs__' of 'int' objects>, '__str__': <slot wrapper '__str__' of 'int' objects>, '__gt__': <slot wrapper '__gt__' of 'int' objects>, '__ne__': <slot wrapper '__ne__' of 'int' objects>, '__sub__': <slot wrapper '__sub__' of 'int' objects>, '__doc__': "int(x=0) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4", 'from_bytes': <method 'from_bytes' of 'int' objects>, '__truediv__': <slot wrapper '__truediv__' of 'int' objects>, '__pow__': <slot wrapper '__pow__' of 'int' objects>, '__ceil__': <method '__ceil__' of 'int' objects>, '__getattribute__': <slot wrapper '__getattribute__' of 'int' objects>, 'imag': <attribute 'imag' of 'int' objects>, '__invert__': <slot wrapper '__invert__' of 'int' objects>, '__lshift__': <slot wrapper '__lshift__' of 'int' objects>, 'to_bytes': <method 'to_bytes' of 'int' objects>, '__rrshift__': <slot wrapper '__rrshift__' of 'int' objects>, '__rpow__': <slot wrapper '__rpow__' of 'int' objects>, '__rshift__': <slot wrapper '__rshift__' of 'int' objects>, '__sizeof__': <method '__sizeof__' of 'int' objects>, '__rlshift__': <slot wrapper '__rlshift__' of 'int' objects>, '__neg__': <slot wrapper '__neg__' of 'int' objects>}
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   TypeError: 'mappingproxy' object does not support item assignment
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   KeyError: 'a'
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   TypeError: can't set attributes of built-in/extension type 'int'
   #+end_example

   解释器内部的模块和通过文件加载的模块会区别显示：
   
   #+BEGIN_SRC python :session
     import contextlib
     print(contextlib)
     print(int)
   #+END_SRC

   #+RESULTS[3facface457b44f2d19c1d2ea6884535081ff798]:
   :
   : <module 'contextlib' from '/usr/lib/python3.5/contextlib.py'>
   : <class 'int'>

** 类和类实例（Class and Class Instance）
   参考 /Python Language Reference/ 关于“对象、值和类型” 和 “类定义”。
** 函数（Functions）
   函数由函数定义创建。仅支持函数调用此唯一操作：func(argument-list)。

   有两种形式的函数对象：内置函数和用户自定义函数。两者都支持相同操作
   （即函数调用），但由于实现不同，所以为不同类型对象。

** 方法（Methods）
   方法为通过属性形式调用的函数。有两种形式的方法：内置方法（如链表的
   append()）和类实例方法。
   
   当通过类实例获取方法时，就会获得一个特殊对象： /绑定方法/ （或称为
   /实例方法/ ）对象。当调用时，会将“self”参数传入参数。实例方法有两个
   特殊的只读属性：
   
   - m.__self__。为此方法操作的对象：
     
     #+BEGIN_SRC python :session
     b = b'abc'

     b.upper.__self__ is b
     #+END_SRC
     
     #+RESULTS[884f4cc8fa51ebbaa531416d8e74d0c25eb919fe]:
     :
     : >>> True
     
   - m.__func__，实现此方法的函数。m(argumet-list)相当于
     m.__func__(m.__self__, argument-list)，仅限于非内置对象方法：
     
     #+BEGIN_SRC python :session
       b = b'abc'
       b.upper

       b.upper.__func__(b.upper.__self__)

       class Test:
           def __init__(self, name):
               self.name = name
           def hello(self):
               print('hello {}'.format(self.name))

       t = Test('me')
       t.hello.__func__
       t.hello
       t.hello()
       t.hello.__func__(t.hello.__self__)
     #+END_SRC

     #+RESULTS[ae42fecf6027c54b26beb98e4674a9c3a8263031]:
     :
     : <built-in method upper of bytes object at 0x7f0c785f9fd0>
     : >>> Traceback (most recent call last):
     :   File "<stdin>", line 1, in <module>
     : AttributeError: 'builtin_function_or_method' object has no attribute '__func__'
     : >>> >>> ... ... ... ... ... >>> >>> >>> <function Test.hello at 0x7f0c77ea57b8>
     : <bound method Test.hello of <__main__.Test object at 0x7f0c77ea6390>>
     : hello me
     : hello me

     同普通函数对象一样，实例方法对象也支持属性获取。不过，由于方法属性
     实际上存储在内部的函数对象内（method.__func__），所以不允许直接绑
     定方法属性：

   #+BEGIN_SRC python :session
     class C:
         def method(self):
             pass

     c = C()
     c.method.whoami = 'my name is method'
     c.method.__func__.whoami = 'my name is method'
     c.method.whoami
   #+END_SRC

   #+RESULTS[96ff08f13c7af393ba49671d0806aacaf63e4d17]:
   :
   : ... ... >>> >>> >>> Traceback (most recent call last):
   :   File "<stdin>", line 1, in <module>
   : AttributeError: 'method' object has no attribute 'whoami'
   : >>> 'my name is method'

** 代码对象（Code Objects） ？？？
** 类型对象（Type Objects）
   类型对象用于表示不同类型对象。对象的类型可通过内置函数type()获取。
   标准模块types定义了所有内置类型名：

   #+BEGIN_SRC python :session
     type(1)

     class C:
         pass

     c = C()
     type(c)
   #+END_SRC

   #+RESULTS[8276cd3ce13c3d82d2750e54c27d1797bee933f2]:
   : <class 'int'>
   : >>> ... ... >>> >>> <class '__main__.C'>

** Null 对象（The Null Object）
   无返回值的函数返回此类型。仅只有一个Null对象，即None。
   #+BEGIN_SRC python :session
     def foo():
         pass

     type(foo())
     None is foo()
     type(None)() is None
   #+END_SRC

   #+RESULTS[019e5cae46f5a9bb9482d4a186ffff7f3c7b5abc]:
   :
   : ... >>> >>> <class 'NoneType'>
   : True
   : True

** Ellipsis对象（The Ellipsis Object）
   
   #+BEGIN_SRC python :session
     type(Ellipsis)()
   #+END_SRC

   #+RESULTS[60a9cf5ed93f08a38d23eee82c39aec72082ca78]:
   : Ellipsis

** 未实现对象（The Nonimplemented Objects）
** 布尔值（Boolean Values）
   仅含False和True两个常量对象。如同数字看待，分别相当于0和1。可使用内
   置函数bool将任意值转换为布尔值。

   #+BEGIN_SRC python :session
     bool(b'')
     bool([1])
   #+END_SRC

   #+RESULTS[c94d2c95563cfa191280ff23ee12b079c0946f4a]:
   : False
   : True

** 内部对象（Internal Objects）
* 特殊属性（Special Attribute）
** object. *__dict__*
   字典或其他映射对象，用于存储对象的可写属性。

   #+BEGIN_SRC python :session
     class F:
         pass

     f = F()
     f.__dict__
   #+END_SRC

   #+RESULTS[f706444b5d68873f956182ac1ee8ae4dcc4fb4c8]:
   :
   : ... >>> >>> >>> {}

** instance. *__class__*
   返回对象所属类：

   #+BEGIN_SRC python :session
     a = 1
     a.__class__
   #+END_SRC

   #+RESULTS[c30406889a285d02b73ad0b37f5409f6925c00c1]:
   :
   : <class 'int'>

** class. *__bases__*
   返回类的父类组成的元组。

   #+BEGIN_SRC python :session
     from contextlib import ContextDecorator

     class F(ContextDecorator):
         pass

     F.__bases__
     bool.__base__
   #+END_SRC

   #+RESULTS[ecdbecdfe3e5c56e0adcd9d8e0ecbb1a89af0f2d]:
   :
   : >>> >>> ... ... >>> >>> (<class 'contextlib.ContextDecorator'>,)
   : <class 'int'>

** definition. *__name__*
   类、函数、方法、描述器和生成器实例的名称：

   #+BEGIN_SRC python :session
     def foo():
         pass

     foo.__name__
   #+END_SRC

   #+RESULTS[fcba2a23937d37d1654fb1f4d59ad8efed574537]:
   :
   : ... >>> >>> 'foo'

** definition. *__qualname__* ？？？

   #+BEGIN_SRC python :session
     def foo():
         pass

     foo.__qualname__
   #+END_SRC

   #+RESULTS[b6da4c73bb77582fdadf4a1c194f77b440d984ea]:
   :
   : ... >>> >>> 'foo'

** class. *__mro__*
** class. *mro* ()
** class. *__subclass__* ()
   
   #+BEGIN_SRC python :session
     int.__subclasses__()
   #+END_SRC
   
   #+RESULTS[a385bf1a3ff4b20d3fa58359f361a5b978f3a16d]:
   : [<class 'bool'>]
