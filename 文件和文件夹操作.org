# Author: Claudio <3261958605@qq.com>
# Created: 2017-05-19 11:23:35
# Commentary:
#+TITLE: 文件和文件夹操作

* pathlib - 面向对象的文件系统路径
  此模块提供不同系统表示文件系统的类。路径类分为两类，对I/O没有操作的
  纯路径计算操作Pure Path，和继承于Pure Path，对I/O有操作的Concrete
  Path。
  
  如果从来没使用过此模块，或不确定使用哪个类，最好选用Path类。它实例
  化了当前环境中的Concrete Path。
  
  Pure Path在一些特殊情况下有用。如：
  
   - 如需在Unix系统下操作Window路径（反之亦然），不能在Unix系统上实例
     化WindowsPath类，但可以实例化PureWindowsPath。
   - 如需保证代码操作路径同时，不与操作系统产生交互，可实例化纯路径类。
     
** 基本用法
   导入主类：
   
   #+BEGIN_EXAMPLE python
     >>> from pathlib import Path
   #+END_EXAMPLE
   
   列出当前子文件夹：
   
   #+BEGIN_EXAMPLE python
     >>> [x for x in p.iterdir() if x.is_dir()]
     [...]
   #+END_EXAMPLE
   
   列出当前文件夹中的所有Python源码文件：
   
   #+BEGIN_EXAMPLE python
     >>> list(p.glob('**/*.py'))
     [PosixPath('test.py')]
   #+END_EXAMPLE
   
   浏览在文件夹中：
   
   #+BEGIN_EXAMPLE python
     >>> p = Path('/etc')
     >>> q = p/'init.d'/'reboot'
     >>> q
     PosixPath('/etc/init.d/reboot')
     >>> q.resolve()
     PosixPath('/etc/init.d/reboot')
   #+END_EXAMPLE
   
   获取路径属性：
   
   #+BEGIN_EXAMPLE python
     >>> q.exists()
     True
     >>> q.is_dir()
     False
     >>> q.is_file()
     True
   #+END_EXAMPLE
   
   打开文件：
   
   #+BEGIN_EXAMPLE python
     >>> with q.open() as f: f.readline()
     ...
     '#! /bin/sh\n'
   #+END_EXAMPLE
   
** 纯路径（Pure Path）
*** 类
    纯路径对象可在不真正操作文件系统情况下处理路径。有下面3个类可选。

    因为没有真正操作文件系统，任何操作系统中都可实例化这些对象。

**** class pathlib. *PurePath* (*pathsegments)
     通用类，根据系统路径特点表示路径（通过调用PurePosixPath或
     PureWindowsPath实例化）。

     #+BEGIN_EXAMPLE python
       >>> PurePath('setup.py')
       PurePosixPath('setup.py')
     #+END_EXAMPLE

     PATHSEGMENTS参数可为单个字符串，也可为多个字符串或path对象：

     #+BEGIN_EXAMPLE python
       >>> PurePath('foo', 'some/path', 'bar')
       PurePosixPath('foo/some/path/bar')
       >>> PurePath(Path('foo'), 'bar')
       PurePosixPath('foo/bar')
     #+END_EXAMPLE

     如果无参数，则表示当前文件夹：

     #+BEGIN_EXAMPLE
       >>> PurePath()
       PurePosixPath('.')
     #+END_EXAMPLE

     如果有多个决定路径，则最后一个被作为起点：

     #+BEGIN_EXAMPLE python
       >>> PurePath('etc', '/usr', 'lib64')
       PurePosixPath('/usr/lib64')
       >>> PurePath('foo', '/etc', '/bar', 'usr', 'lib64')
       PurePosixPath('/bar/usr/lib64')
       >>> PureWindowsPath('c:/Windows', 'd:/bar')
       PureWindowsPath('d:/bar')
     #+END_EXAMPLE

     但在Windows形式中，设置根目录不会忽视驱动盘位置：

     #+BEGIN_EXAMPLE python
       >>> PureWindowsPath('c:/Windows', '/Program Files')
       PureWindowsPath('c:/Program Files')
     #+END_EXAMPLE

     多余的单点和斜杠会被自动去除，双点则不会：

     #+BEGIN_EXAMPLE python
       >>> PurePath('foo//bar')
       PurePosixPath('foo/bar')
       >>> PurePath('foo/./bar')
       PurePosixPath('foo/bar')
       >>> PurePath('foo/../bar')
       PurePosixPath('foo/../bar')
     #+END_EXAMPLE

**** class pathlib. *PurePosixPath* (*pathsegments)
     PurePath子类，表示非-Windows系统文件路径。

     PATHSEGMENTS参数用法同PurePath。

     #+BEGIN_EXAMPLE python
       >>> PurePath('/etc')
       PurePosixPath('/etc')
     #+END_EXAMPLE

**** class pathlib. *PureWindowsPath* (*pathsegments)
     PurePath子类，表示Windows系统文件路径。

     PATHSEGMENTS参数用法同PurePath。

     #+BEGIN_EXAMPLE
       >>> PureWindowsPath('c:/Proram Files')
       PureWindowsPath('c:/Proram Files')
     #+END_EXAMPLE

*** 一般属性
    Path对象为Immutable类型，可哈希。可同字符串一样进行排序和大小比较。
    大小写与对应的系统类别相同，即非-Windows类型区分大小写，Windows类
    型不区分大小写。

    #+BEGIN_EXAMPLE python
      >>> PurePosixPath('foo') == PurePosixPath('FOO')
      False
      >>> PureWindowsPath('foo') == PureWindowsPath('FOO')
      True
      >>> PureWindowsPath('foo') in  {PureWindowsPath('FOO')}
      True
      >>> PureWindowsPath('c:') < PureWindowsPath('d:')
      True
      >>> PureWindowsPath('c:') < PureWindowsPath('D:')
      True
    #+END_EXAMPLE

    不同类型的路径形式绝不相等，且不可比较大小：

    #+BEGIN_EXAMPLE
      >>> PureWindowsPath('foo') == PurePosixPath('foo')
      False
      >>> PureWindowsPath('foo') < PurePosixPath('foo')
      Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
        TypeError: unorderable types: PureWindowsPath() < PurePosixPath()
    #+END_EXAMPLE

*** 操作符
    使用斜杠可创建子路径：

    #+BEGIN_EXAMPLE python
      >>> p = PurePath('/etc')
      >>> p / 'init.d' / 'apache2'
      PurePosixPath('/etc/init.d/apache2')
      >>> q = PurePath('bin')
      >>> '/usr' / q
      PurePosixPath('/usr/bin')
    #+END_EXAMPLE

    将Path对象转换为字符串后，斜杠会根据不同系统类型转换：
    
    #+BEGIN_EXAMPLE python
      >>> p = PurePath('/etc')
      >>> str(p)
      '/etc'
      >>> p = PureWindowsPath('c:/Program Files')
      >>> p
      PureWindowsPath('c:/Program Files')
      >>> str(p)
      'c:\\Program Files'
    #+END_EXAMPLE

    使用bytes转换同理：

    #+BEGIN_EXAMPLE python
      >>> p = PurePath('/etc')
      >>> bytes(p)
      b'/etc'
      >>> p = PureWindowsPath('c:/Program Files')
      >>> bytes(p)
      b'c:\\Program Files'
    #+END_EXAMPLE

    #+BEGIN_QUOTE
    *注意* ：bytes仅在Unix系统上建议使用。
    #+END_QUOTE

*** 获取部分内容
**** PurePath. *parts*
     返回路径每个部分组成的元组：

     #+BEGIN_EXAMPLE python
       >>> p = PurePath('/usr/bin/python3')
       >>> p.parts
       ('/', 'usr', 'bin', 'python3')
       >>> p = PureWindowsPath('c:/Program Files')
       >>> p.parts
       ('c:\\', 'Program Files')
     #+END_EXAMPLE

*** 方法和属性
**** PurePath. *drive*
     如果路径中有驱动设备名，返回该字母：

     #+BEGIN_EXAMPLE python
       >>> PureWindowsPath('c:/Program Files').drive
       'c:'
       >>> PureWindowsPath('Program Files').drive
       ''
       >>> PurePath('c:/Program Files').drive
       ''
       >>> PureWindowsPath('//host/share/foo.txt').drive
       '\\\\host\\share'
     #+END_EXAMPLE

**** PurePath. *root*
     根目录：

     #+BEGIN_EXAMPLE python
       >>> PureWindowsPath('c:/Program Files').root
       '\\'
       >>> PureWindowsPath('c:Program Files').root
       ''
       >>> PurePosixPath('/etc').root
       '/'
       >>> PureWindowsPath('//host/share').root
       '\\'
     #+END_EXAMPLE
**** PurePath. *anchor*
     drive属性+root属性：

     #+BEGIN_EXAMPLE python
       >>> PureWindowsPath('c:/Program Files').anchor
       'c:\\'
       >>> PureWindowsPath('c:Program Files/').anchor
       'c:'
       >>> PurePosixPath('/etc').anchor
       '/'
       >>> PureWindowsPath('//host/share').anchor
       '\\\\host\\share\\'
     #+END_EXAMPLE

**** PurePath. *parents*
     immutable类类型序列，含所有上级路径。

     #+BEGIN_EXAMPLE python
       >>> p=PureWindowsPath('c:/foo/bar/setup.py')
       >>> p.parents
       <PureWindowsPath.parents>
       >>> list(p.parents)
       [PureWindowsPath('c:/foo/bar'), PureWindowsPath('c:/foo'), PureWindowsPath('c:/')]
     #+END_EXAMPLE

**** PurePath. *parent*
     字面上的父级路径。

     #+BEGIN_EXAMPLE python
       >>> p = PurePosixPath('/a/b/c/d')
       >>> p.parent
       PurePosixPath('/a/b/c')
     #+END_EXAMPLE

     如果没有父级，返回本身：

     #+BEGIN_EXAMPLE python
       >>> p = PurePosixPath('/')
       >>> p.parent
       PurePosixPath('/')
       >>> p = PurePosixPath('.')
       >>> p.parent
       PurePosixPath('.')
     #+END_EXAMPLE

     “字面上”的含义是只考虑参数字符串，如：

     #+BEGIN_EXAMPLE
       >>> p = PurePosixPath('foo/..')
       >>> p
       PurePosixPath('foo/..')
       >>> p.parent
       PurePosixPath('foo')
     #+END_EXAMPLE

     如需向上变量文件系统，建议先调用Path.resolve()方法，以确认软链接
     和“..”部分。

**** PurePath. *name*
     返回表示路径最末部分的字符串：

     #+BEGIN_EXAMPLE python
       >>> PurePosixPath('my/lib/setup.py').name
       'setup.py'
       >>> PureWindowsPath('//some/share/setup.py').name
       'setup.py'
       >>> PureWindowsPath('//some/share/').name
       ''
       >>> PureWindowsPath('//some/share').name
       ''
     #+END_EXAMPLE
**** PurePath. *suffix*
     返回字符串表示的文件后缀：

     #+BEGIN_EXAMPLE python
       >>> PurePosixPath('my/lib/setup.py').suffix
       '.py'
       >>> PurePosixPath('my/lib.tar.gz').suffix
       '.gz'
       >>> PurePosixPath('my/lib').suffix
       ''
     #+END_EXAMPLE

**** PurePath. *suffixes*
     所有文件后缀组成的链表：

     #+BEGIN_EXAMPLE python
       >>> PurePosixPath('my/lib/setup.py').suffixes
       ['.py']
       >>> PurePosixPath('my/lib.tar.gz').suffixes
       ['.tar', '.gz']
       >>> PurePosixPath('my/lib').suffixes
       []
     #+END_EXAMPLE

**** PurePath. *stem*
     除后缀外的路径最后部分：

     #+BEGIN_EXAMPLE python
       >>> PurePosixPath('my/lib/setup.py').stem
       'setup'
       >>> PurePosixPath('my/lib.tar.gz').stem
       'lib.tar'
       >>> PurePosixPath('my/lib').stem
       'lib'
     #+END_EXAMPLE
**** PurePath. *as_posix* ()
     返回以斜杠（/）形式表示的路径字符串：

     #+BEGIN_EXAMPLE python
       >>> p = PureWindowsPath('c://Windows')
       >>> str(p)
       'c:\\Windows'
       >>> p.as_posix()
       'c:/Windows'
     #+END_EXAMPLE

**** PurePath. *as_uri* ()
     将路径名转换为文件链接。如果不是绝对路径，抛出ValueError错误：

     #+BEGIN_EXAMPLE python
       >>> PurePosixPath('/etc/passwd').as_uri()
       'file:///etc/passwd'
       >>> PureWindowsPath('c:/Windows').as_uri()
       'file:///c:/Windows'
       >>> PurePosixPath('./passwd').as_uri()
       Traceback (most recent call last):
         File "<stdin>", line 1, in <module>
           File "/usr/lib/python3.5/pathlib.py", line 713, in as_uri
               raise ValueError("relative path can't be expressed as a file URI")
               ValueError: relative path can't be expressed as a file URI
     #+END_EXAMPLE
**** PurePath. *is_absolute* ()
     是否为绝对路径，即同时具备驱动路径（Windows）和根目录：
     
     #+BEGIN_EXAMPLE python
       >>> PurePosixPath('/a/b').is_absolute()
       True
       >>> PurePosixPath('a/b').is_absolute()
       False
       >>> PureWindowsPath('c:/a/b').is_absolute()
       True
       >>> PureWindowsPath('/a/b').is_absolute()
       False
       >>> PureWindowsPath('c:/').is_absolute()
       True
       >>> PureWindowsPath('c:').is_absolute()
       False
       >>> PureWindowsPath('//some/share').is_absolute()
       True
     #+END_EXAMPLE
**** PurePath. *is_reserved* ()
     是否为Windows系统下的保留路径名。对应PurePosixPath始终返回False。

     #+BEGIN_EXAMPLE python
       >>> PureWindowsPath('nul').is_reserved()
       True
       >>> PurePosixPath('nul').is_reserved()
       False
     #+END_EXAMPLE

**** PurePath. *joinpath* (*other)
     将当前路径与*OTHER结合：

     #+BEGIN_EXAMPLE python
       >>> PurePosixPath('/etc').joinpath('passwd')
       PurePosixPath('/etc/passwd')
       >>> PurePosixPath('/etc').joinpath(PurePosixPath('passwd'))
       PurePosixPath('/etc/passwd')
       >>> PurePosixPath('/etc').joinpath('init.d', 'apache2')
       PurePosixPath('/etc/init.d/apache2')
       >>> PureWindowsPath('c:').joinpath('Program Files')
       PureWindowsPath('c:Program Files')
       >>> PureWindowsPath('c:').joinpath('/Program Files')
       PureWindowsPath('c:/Program Files')
     #+END_EXAMPLE

**** PurePath. *match* (pattern)
     是否与glob风格的PATTERN匹配。

     如果PATTERN为相对路径，则即可为相对路径，也可为绝对路径：

     #+BEGIN_EXAMPLE python
       >>> PurePath('a/b.py').match('*.py')
       True
       >>> PurePath('a/b/c.py').match('b/*.py')
       True
       >>> PurePath('a/b/c.py').match('a/*.py')
       False
       >>> PurePath('a/b/c.py').match('a/**/*.py')
       True
     #+END_EXAMPLE

     如果PATTERN为绝对路径，则也需为绝对路径：

     #+BEGIN_EXAMPLE python
       >>> PurePath('/a.py').match('/*.py')
       True
       >>> PurePath('*/a.py').match('/*.py')
       False
     #+END_EXAMPLE

     是否区别大小写会自动识别：

     #+BEGIN_EXAMPLE
       >>> PureWindowsPath('*/a.py').match('*.PY')
       True
     #+END_EXAMPLE

**** PurePath. *relative_to* (*other)
     返回相对OTHER的路径：
     
     #+BEGIN_EXAMPLE python
       >>> p = PurePosixPath('/etc/passwd')
       >>> p.relative_to('/etc')
       PurePosixPath('passwd')
       >>> p.relative_to('/')
       PurePosixPath('etc/passwd')
       >>> p.relative_to('/usr')
       Traceback (most recent call last):
         File "<stdin>", line 1, in <module>
           File "/usr/lib/python3.5/pathlib.py", line 864, in relative_to
               .format(str(self), str(formatted)))
               ValueError: '/etc/passwd' does not start with '/usr'
     #+END_EXAMPLE

**** PurePath. *with_name* (name)
     替换文件名。如果没有文件名抛出ValueError错误：

     #+BEGIN_EXAMPLE python
       >>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')
       >>> p.with_name('setup.py')
       PureWindowsPath('c:/Downloads/setup.py')
       >>> p = PureWindowsPath('c:/Downloads/pathlib')
       >>> p.with_name('setup.py')
       PureWindowsPath('c:/Downloads/setup.py')
       >>> p = PurePosixPath('bar/baz')
       >>> p.with_name('test.txt')
       PurePosixPath('bar/test.txt')
       >>> p = PureWindowsPath('c:/')
       >>> p.with_name('setup.py')
       Traceback (most recent call last):
         File "<stdin>", line 1, in <module>
           File "/usr/lib/python3.5/pathlib.py", line 809, in with_name
               raise ValueError("%r has an empty name" % (self,))
               ValueError: PureWindowsPath('c:/') has an empty name
     #+END_EXAMPLE

**** PurePath. *with_suffix* (suffix)
     替换后缀名，如果没有后缀名，则添加此后缀：

     #+BEGIN_EXAMPLE python
       >>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')
       >>> p.with_suffix('.bz2')
       PureWindowsPath('c:/Downloads/pathlib.tar.bz2')
       >>> p = PureWindowsPath('c:/Downloads/')
       >>> p.with_suffix('.bz2')
       PureWindowsPath('c:/Downloads.bz2')
     #+END_EXAMPLE

** 具体路径（Concrete Path）
   
   具体路径为纯路径的子类，除上面纯路径的属性和方法外，还添加可调用操
   作系统的方法和属性。
   
*** 类
    有下面3个类创建具体路径。
**** class pathlib. *Path* (*pathsegments)
**** class pathlib. *PosixPath* (*pathsegments)
**** class pathlib. *WindowsPath* (*pathsegments)
     用法和参数同纯路径的对应类，只是只能使用系统对应的类创建对象：

     #+BEGIN_EXAMPLE python
       >>> import os
       >>> os.name
       'posix'
       >>> Path('setup.py')
       PosixPath('setup.py')
       >>> PosixPath('setup.py')
       PosixPath('setup.py')
       >>>
       >>> WindowsPath('setup.py')
       Traceback (most recent call last):
         File "<stdin>", line 1, in <module>
           File "/usr/lib/python3.5/pathlib.py", line 972, in __new__
               % (cls.__name__,))
               NotImplementedError: cannot instantiate 'WindowsPath' on your system
     #+END_EXAMPLE

*** 方法
    除纯路径方法外，具体路径实例还提供下面方法，其中大多数在系统调用失
    败时（如路径不存在）可抛出OSError错误。
    
**** classmethod Path. *cwd* ()
     返回表示当前路径的路径对象。

     #+BEGIN_EXAMPLE python
       >>> Path.cwd()
       PosixPath('/home/claudio')
     #+END_EXAMPLE

     与os.getcwd()返回值相同：

     #+BEGIN_EXAMPLE python
       >>> os.getcwd()
       '/home/claudio'
     #+END_EXAMPLE

**** classmethod Path. *home* ()
     返回表示家目录的路径对象。

     #+BEGIN_EXAMPLE python
       >>> Path.home()
       PosixPath('/home/claudio')
     #+END_EXAMPLE

     与os.path.expanduser('~')返回值相同：

     #+BEGIN_EXAMPLE python
       >>> os.path.expanduser('~')
       '/home/claudio'
     #+END_EXAMPLE

**** Path. *stat* ()
     与os.stat()返回值相似，返回路径对象的具体信息。
     
     #+BEGIN_EXAMPLE python
       >>> p = Path('dict.txt')
       >>> p.stat()
       os.stat_result(st_mode=33188, st_ino=23987801, st_dev=2049, st_nlink=1, st_uid=
       1000, st_gid=1000, st_size=472, st_atime=1495200610, st_mtime=1494496832, st_ct
       >>> p = Path('dict.txt')
       >>> p.stat()
       os.stat_result(st_mode=33188, st_ino=23987801, st_dev=2049, st_nlink=1, st_uid=
       1000, st_gid=1000, st_size=472, st_atime=1495200610, st_mtime=1494496832, st_ct
       ime=1494496832)
       >>> p.stat().st_gid
       1000
       >>> p.stat().st_size
       472
     #+END_EXAMPLE
     
**** Path. *chmod* (mode)
     更改文件模式和权限，类似于os.chmod()。

     #+BEGIN_EXAMPLE python
       >>> p = Path('dict.txt')
       >>> p.stat().st_mode
       33188
       >>> p.chmod(0o444)
       >>> p.stat().st_mode
       33060
     #+END_EXAMPLE

**** Path. *exists* ()
     当前路径是否指向一个存在的文件/文件夹：

     #+BEGIN_EXAMPLE python
       >>> Path('.').exists()
       True
       >>> Path('dict.txt').exists()
       True
       >>> Path('/etc').exists()
       True
       >>> Path('不存在').exists()
       False
     #+END_EXAMPLE

     #+BEGIN_QUOTE
     *注意* ：如果路径指向软链接，是否存在根据指向文件/文件夹是否存在
     判断。
     #+END_QUOTE
**** Path. *expanduser* ()
     返回扩展~和~user后的新路径对象。与os.path.expanduer()返回值相同。
     
     #+BEGIN_EXAMPLE python
       >>> p = PosixPath('~/dict.txt')
       >>> p.expanduser()
       PosixPath('/home/claudio/dict.txt')
     #+END_EXAMPLE
     
**** Path. *glob* (pattern)
     返回路径中匹配glob形式PATTERN的所有文件路径组成的链表。

     #+BEGIN_EXAMPLE python
       >>> sorted(Path('.').glob('*.txt'))
       [PosixPath('.phone-list.txt'), PosixPath('defaultdict.txt'), PosixPath('dict.tx
       t')]
     #+END_EXAMPLE

     可使用“**”匹配“当前文件夹和所有子文件夹”进行递归匹配。（在大型文
     件夹下会很耗时）

**** Path. *group* ()
     返回用户组名称。如果用户组gid不存在于系统数据库中，抛出KeyError错
     误。

     #+BEGIN_EXAMPLE python
       >>> Path('.').group()
       'claudio'
     #+END_EXAMPLE

**** Path. *is_dir* ()
     如果为文件夹，或为指向文件夹的软链接，返回True。

     如果不存在，或为已损坏的软链接，返回False；其他如权限错误会向上抛出。

**** Path. *is_file* ()
     如果为文件，或为指向文件的软链接，返回True。

     如果不存在，或为已损坏的软链接，返回False；其他如权限错误会向上抛
     出。

**** Path. *is_symlink* ()
     如果为软链接返回True，否则返回False。

     如果不存在，返回False；其他如权限错误会向上抛出。

     #+BEGIN_SRC python :session
       from pathlib import Path
       p = Path('/dev/cdrom')
       p.is_symlink()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> True
     #+END_SRC

**** Path. *is_socket* ()
     如果为Unix socket（或为指向Unix socket的软链接），则返回True，否
     则返回False。

     如果不存在，或为已损坏的软链接，返回False；其他如权限错误会向上抛
     出。

**** Path. *is_fifo* ()
     如果为FIFO（或为指向FIFO的软链接），则返回True，否则返回False。

     如果不存在，或为已损坏的软链接，返回False；其他如权限错误会向上抛
     出。

**** Path. *is_block_device* ()
     如果为块设备（或为指向块设备的软链接），则返回True，否则返回False。
     
     如果不存在，或为已损坏的软链接，返回False；其他如权限错误会向上抛
     出。
     
     #+BEGIN_SRC python :session
       from pathlib import Path
       p = Path('/dev/cdrom')
       p.is_block_device()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> True
     #+END_SRC
     
**** Path. *is_char_device* ()
     如果为字符设备（或为指向字符设备的软链接），则返回True，否则返回
     False。

     如果不存在，或为已损坏的软链接，返回False；其他如权限错误会向上抛
     出。

     #+BEGIN_SRC python :session
       from pathlib import *
       Path('/dev/cdrom').is_block_device()
       Path('/dev/tty1').is_char_device()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - True
     - True
     #+END_SRC

**** Path. *iterdir* ()
     当为文件夹时，返回其中内容组成的路径迭代对象：

     #+BEGIN_EXAMPLE python
       for child in Path('.').resolve().iterdir():
           print(child)
     #+END_EXAMPLE

**** Path. *lchmod* (mode)
     类似与Path.chmod()，不过如果为软链接，修改的为软链接的权限模式，
     而不是目标文件的权限模式。

**** Path. *lstat* ()
     类似于Path.lstat()，不过如果为软链接，返回该软链接的文件信息，而
     不是模板文件的信息。

**** Path. *mkdir* (mode=0o777,parents=False,exist_ok=False)
     创建新文件夹。如果指定MODE参数，则系统umask值结果决定文件夹权限。
     如果文件夹已存在，则抛出FileExistsError 错误。

     如果PARENTS参数为True，会自动创建不存在的父文件夹，但这些父文件夹
     的权限模式会使用系统默认值，忽视MODE参数。

     如果PARENTS参数为False（默认值），缺少父文件夹抛出
     FileNotFoundError错误。

     如果EXIST_OK参数为False（默认值），如果文件夹已存在，抛出
     FileExistsError错误。

**** Path. *open* (mode='r',buffering=-1,encoding=None,errors=None,newlines=None)
     与内置函数open类型。

     #+BEGIN_SRC python :session
       from pathlib import Path

       with Path('/etc/hostname').open() as fp:
           fp.readline()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> ... ... 'kali\n'
     #+END_SRC

**** Path. *owner* ()
     返回路径文件的拥有者用户名。如果对应uid不存在于系统数据库，抛出
     KeyError错误。

     #+BEGIN_EXAMPLE python
       >>> Path('dict.txt').owner()
       'claudio'
     #+END_EXAMPLE

**** Path. *read_bytes* ()
     将路径文件内容作为bytes对象返回。

     #+BEGIN_SRC python :session
       from pathlib import Path

       p = Path('~/dict').expanduser()
       p.write_bytes(b'banary-data')
       p.read_bytes()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> 11
     - b'banary-data'
     #+END_SRC

**** Path. *read_text* (encoding=None,errors=None)
     返回路径文件中解码有的内容。

     可选参数与open()函数含义相同。

     #+BEGIN_SRC python :session
       from pathlib import Path
       p = Path('~/dict.txt').expanduser()
       p.write_text('文本文件内容')
       p.read_bytes()
       p.read_text()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> 6
     - b'\xe6\x96\x87\xe6\x9c\xac\xe6\x96\x87\xe4\xbb\xb6\xe5\x86\x85\xe5\xae\xb9'
     - '文本文件内容'
     #+END_SRC

**** Path. *rename* (target)
     将路径文件/文件夹重命名为TARGET。在Unix系统下，如果TARGET存在且为
     文件，并有权限，会无条件重命名。
     
     TARGET可为字符串，也可为另一个路径对象。
     
     #+BEGIN_SRC python :session
       from pathlib import Path

       p = Path('~/foo.txt').expanduser()
       target = Path('~/bar.txt').expanduser()
       p.write_text('1111')
       p.rename(target)
       p.exists()
       target.read_text()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> >>> 4
     - >>> False
     - '1111'
     #+END_SRC
     
**** Path. *replace* (target)
     重命名当前文件/文件夹路径。如果target指向已存在文件/文件夹，无条
     件替换。

     *？* ：与renmae有何区别？？？

     #+BEGIN_SRC python :session
       from pathlib import Path

       p = Path('~/foo.txt').expanduser()
       target = Path('~/bar.txt').expanduser()
       p.write_text('1111')
       p.replace(target)
       p.exists()
       target.read_text()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> >>> 4
     - >>> False
     - '1111'
     #+END_SRC

**** Path. *resolve* ()
     将路径转换为决定路径，如果为软链接返回指向目标文件/文件夹的路径。

     如果路径不存在，抛出FileNotFoundError错误；如果出现无限循环，抛出
     RunTimeError错误。

     #+BEGIN_SRC python :session
       from pathlib import Path

       p = Path('/dev/cdrom/')
       p.resolve()

       p = Path('/dev/cdrom/../cdrom')
       p.resolve()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> PosixPath('/dev/sr0')
     - >>> >>> PosixPath('/dev/sr0')
     #+END_SRC

**** Path. *rglob* (pattern)
     递归版本的path.glob()，相当于在前面添加了“**/”。

     #+BEGIN_EXAMPLE python
       sorted(Path().rglob('*.py'))
     #+END_EXAMPLE

**** Path. *rmdir* ()
     删除路径文件夹。文件夹必须为空文件夹。

**** Path. *samefile* (other_path)
     是否与OTHER_PATH为同一文件。OTHER_PATH可为字符串，也可为另一个路
     径对象。

     两个路径需同时存在。

**** Path. *symlink_to* (target,target_is_directory=False)
     创建软链接。将当前路径作为软链接指向TARGET。

     在Windows中，TARGET_IS_DIRECTORY需为True（默认为False），在POSIX
     中则会忽视此参数。

     #+BEGIN_EXAMPLE python
       In [7]: ls
       test.txt

       In [8]: p = Path('mylink')
     
       In [9]: p.symlink_to('test.txt')

       In [10]: p.resolve()
       Out[10]: PosixPath('/home/claudio/test/test.txt')
     #+END_EXAMPLE

**** Path. *touch* (mode=0o666,exist_ok=True)
     根据路径新建文件。如果有MODE参数，与系统umask值结合决定文件权限和
     模式。如果文件已存在，且EXIST_OK参数不为True，抛出FileExistsError
     错误。
     
**** Path. *unlink* ()
     删除路径表示的文件或软链接。如果为文件夹，使用Path.rmdir()。

**** Path. *write_bytes* (data)
     以二进制模式打开文件，写入DATA，最后关闭。

     #+BEGIN_SRC python :session
       from pathlib import Path
       p = Path('not-exists-file')
       p.write_bytes(b'123')
       p.read_bytes()
       p.unlink()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> 3
     - b'123'
     #+END_SRC

     如果文件已经存在，重写；如果不存在，则创建。

**** Path. *write_text* (data,encoding=None,errors=None)
     以文本模式打开文件，写入DATA，最后关闭文件。

     #+BEGIN_SRC python :session
       from pathlib import Path
       p = Path('not-exists-file')
       p.write_text('123')
       p.read_text()
       p.unlink()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> 3
     - '123'
     #+END_SRC

     如果文件已经存在，重写；如果不存在，则创建。
* os.path - 常用路径名操作
** 模块函数
   此模块提供操作路径名的函数。如需读写文件，使用内置函数open()，操作
   文件系统使用os模块。函数的PATH参数可为字符串，也可为bytes对象。应用
   中首选Unicode形式字符串（默认）。但在Unix系统中，一些文件名不能用字
   符串表示，此时可使用bytes对象；在Windows系统中，bytes对象不能表示所
   有文件名，所以需使用字符串形式。
   
   不同于shell，Python不会自动扩张路径，如需扩张，可使用expanduser()和
   expandvars()函数，也可参考glob模块。
   
   #+BEGIN_QUOTE
   pathlib模块提供高阶的路径对象。
   #+END_QUOTE
   
   #+BEGIN_QUOTE
   *注意* ：此模块中的所有函数只能同时使用字符串和bytes对象中的一种作
   为参数，返回值与参数形式相同。
   #+END_QUOTE
   
   #+BEGIN_QUOTE
   *注意* ：不同的系统路径名规范不同，但os.path始终保存与当前操作系统
   兼容。如需在本地使用不同规范的路径模块，可参考（都有相同接口）：
   
   - posixpath： Unix
   - ntpath：Windows
   - macpath：老式MocOS
   #+END_QUOTE
   
*** os.path. *abspath* (path)
    将将PATH标准化为绝对路径。在绝大多数系统中，等价于
    normpath(join(os.getcwd(), path))。

    #+BEGIN_SRC python :session
      from os.path import abspath
      abspath('README.org')
      abspath('not-exists-file')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - '/home/claudio/Desktop/Python/python-standard-lib-notes/README.org'
    - '/home/claudio/Desktop/Python/python-standard-lib-notes/not-exists-file'
    #+END_SRC

*** os.path. *basename* (path)
    返回PATH的basename，与os.path.split()结果中的第二个元素值相同。

    *注意* ：不同于Unix的basename命令，如'/foo/bar/'，该命令的返回结果
    为'bar'，而此函数的返回值为空。

    #+BEGIN_SRC python :session
      from os.path import basename
      name = '~/data/test.db'
      print(basename('~/qwd/'))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>>
    #+END_SRC

*** os.path. *commonpath* (paths)
    返回PATHS中最长的相同子路径。PATHS只能同时为绝对路径和相对路径中的
    一种，且不能为空，否则抛出ValueError错误。

    不同于commonprefix，此函数的返回值为有效路径。

    #+BEGIN_SRC python :session
      from os.path import commonpath
      commonpath(['/usr/lib', '/usr/local/lib'])
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - '/usr'
    #+END_SRC

    兼容：Unix、Windows

*** os.path. *commonprefix* (list)
    逐个字符比较，获取最长相同路径字符串，如果LIST为空，返回空。

    不同于commonpath函数，此函数返回值可能不是有效路径。

    #+BEGIN_SRC python :session
      from os.path import commonprefix
      commonprefix(['/usr/lib', '/usr/local/lib'])
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - '/usr/l'
    #+END_SRC

*** os.path. *dirname* (path)
    返回路径的文件夹，与os.path.split()返回值的第一个参数相同。

*** os.path. *exits* (path)
    如果PATH表示的路径为存在的文件/文件夹，或表示open file descriptor
    的整数，返回True。如果为被损坏的软链接，返回False。
    
    在一些系统中，如果没有足够权限执行os.stat()，即时文件存在，也会返
    回False。
    
    #+BEGIN_SRC python :session
      import os.path
      os.path.exists('~')
      os.path.exists(os.path.expanduser('~'))
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - False
    - True
    #+END_SRC
    
*** os.path. *lexists* (path)
    如果系统上不能实现os.lstat()，等价于os.path.exists()。即即时时损坏
    的软链接也会返回True。

*** os.path. *expanduser* (path)
    在Unix和Windows系统上，返回最前面将~和~user替换为家目录后的结果。
    如果没有~符号，原样返回。

    在Unix系统中，如果设置了环境变量HOME，~使用该变量值代替；否则使用
    pwd模块获取当前用户的家目录代替。如果为，~usr会直接在password文件
    中查询。

    在Windows系统中，如果有设置，使用HOME和USERPROFILE；否则结合
    HOMEPATH和HOMEDRIVE。 An initial ~user is handled by stripping the
    last directory component from the created user path derived above.

    #+BEGIN_SRC python :session
      from os.path import expanduser
      expanduser('~')
      expanduser('~root')
      expanduser('~notexists')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - '/home/claudio'
    - '/root'
    - '~notexists'
    #+END_SRC

*** os.path. *expandvars* (path)
    将PATH中$name和${name}显示使用环境变量替换。如果不存在该环境变量，
    则保存不变。

    在Windows中，还可使用%name%形式。

    #+BEGIN_SRC python :session
      from os.path import expandvars

      expandvars('${PYTHONPATH}')
      expandvars('${pythonpath}')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> '/home/claudio/python:'
    - '${pythonpath}'
    #+END_SRC

*** os.path. *getatime* (path)
    
    返回PATH上次被访问时间。
    
    结果为自“January 1, 1970, 00:00:00 (UTC).” 开始的秒数。如果不存在
    或无访问权限，抛出OSError错误。
    
    如果os.stat_float_times()的返回结果为True，结果为浮点数。
    
    #+BEGIN_SRC python :session
      from os.path import getatime
      import pathlib
      path = 'files/emma.txt'

      print('起点时间：', getatime(path))
      with open(path) as fp:
          fp.readline()

      print('读取内容后：', getatime(path))

      pathlib.Path(path).chmod(0o666)
      print('修改权限后：', getatime(path))

      with open(path, 'a+') as fp:
          fp.write('10')

      print('写入内容后：', getatime(path))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> >>> 起点时间： 1495265725.0639217
    - ... ... '101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
    - 读取内容后： 1495265935.3199155
    - >>> >>> 修改权限后： 1495265935.3199155
    - >>> ... ... 2
    - 写入内容后： 1495265935.3199155
    #+END_SRC

*** os.path. *getmtime* (path)
    返回PATH上次被修改的时间。
    
    结果为自“January 1, 1970, 00:00:00 (UTC).” 开始的秒数。如果不存在
    或无访问权限，抛出OSError错误。
    
    如果os.stat_float_times()的返回结果为True，结果为浮点数。
    
    #+BEGIN_SRC python :session
      from os.path import getmtime
      import pathlib
      path = 'files/emma.txt'

      print('起点时间：', getmtime(path))
      with open(path) as fp:
          fp.readline()

      print('读取内容后：', getmtime(path))

      pathlib.Path(path).chmod(0o666)
      print('修改权限后：', getmtime(path))

      with open(path, 'a+') as fp:
          fp.write('10')

      print('写入内容后：', getmtime(path))
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> >>> 起点时间： 1495266106.8199103
    - ... ... ''
    - 读取内容后： 1495266106.8199103
    - >>> >>> 修改权限后： 1495266106.8199103
    - >>> ... ... 2
    - 写入内容后： 1495266124.2679098
    #+END_SRC
    
*** os.path. *getctime* (path)
    在Unix系统中，为PATH的metadata上次被修改的时间；在Windows中，为
    PATH创建时间。
    
    结果为自“January 1, 1970, 00:00:00 (UTC).” 开始的秒数。如果不存在
    或无访问权限，抛出OSError错误。
    
    如果os.stat_float_times()的返回结果为True，结果为浮点数。
    
    #+BEGIN_SRC python :session
      from os.path import getctime
      import pathlib
      path = 'files/emma.txt'

      print('起点时间：', getctime(path))
      with open(path) as fp:
          fp.readline()

      print('读取内容后：', getctime(path))

      pathlib.Path(path).chmod(0o666)
      print('修改权限后：', getctime(path))

      with open(path, 'a+') as fp:
          fp.write('10')

      print('写入内容后：', getctime(path))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> >>> 起点时间： 1495265993.2799137
    - ... ... '1010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
    - 读取内容后： 1495265993.2799137
    - >>> >>> 修改权限后： 1495265995.1919136
    - >>> ... ... 2
    - 写入内容后： 1495265995.2199137
    #+END_SRC

*** os.path. *getsize* (path)
    返回以byte数表示的文件大小。如果不存在或无访问权限，抛出OSError错
    误。

    #+BEGIN_SRC python :session
      from os.path import getsize
      getsize('files/emma.txt')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 2
    #+END_SRC

*** os.path. *isabs* (path)
    是否为决定路径。即在Unix系统中，以斜杠开头；在Windows中，去除驱动
    字符（如果有）后以反斜杠开头。

*** os.path. *isfile* (path)
    是否为存在的普通文件。会“跟随”软链接，所以如果为指向普通文件的软链
    接也会返回True。

    #+BEGIN_SRC python :session
      from os.path import isfile
      isfile('/etc/localtime')
      isfile('/dev/cdrom')
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - True
    - False
    #+END_SRC

*** os.path. *isdir* (path)
    是否为存在的文件夹。会“跟随”软链接，所有为指向存在文件夹的软链接也
    会返回True。

    #+BEGIN_SRC python :session
      from os.path import isdir
      isdir('/etc/localtime')
      isdir('files')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - False
    - True
    #+END_SRC

*** os.path. *islink* (path)
    是否为软链接。在不支持软链接的运行环境中，始终返回False。

    #+BEGIN_SRC python :session
      from os.path import islink
      islink('/etc/localtime')
      islink('/dev/cdrom')
      # islink('files/emma.txt')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - True
    - True
    #+END_SRC

*** os.path. *ismount* (path)
    是否为挂载点：当前文件系统中，不同文件系统的的位置。在POSIX中，
    On POSIX, the function checks whether path‘s parent, path/.., is
    on a different device than path, or whether path/.. and path point
    to the same i-node on the same device — this should detect mount
    points for all Unix and POSIX variants. On Windows, a drive letter
    root and a share UNC are always mount points, and for any other
    path GetVolumePathName is called to see if it is different from
    the input path.
    
    #+BEGIN_SRC python :session
      from os.path import ismount
      ismount('/run/user/1000')
      ismount('files/emma.txt')
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - True
    - False
    #+END_SRC

*** os.path. *join* (path, *paths)
    拼接路径。将PATH和*PATH使用os.sep拼接。自动去除多余的斜杠和空字符
    串。当最后一个元素后有斜杠，或为空时，返回结果才以斜杠接受。如果有
    一个元素第一个字符为斜杠（即绝对路径），前面的内容被忽略，从当前开
    始拼接。

    Windows：（待续）

    #+BEGIN_SRC python :session
      import os.path

      os.path.join('~')
      os.path.join('/', 'etc')
      os.path.join('/', 'etc/')
      os.path.join('files', 'emma.txt')
      os.path.join('files/', 'emma.txt', '')
      os.path.join('files/', '', 'emma.txt', '')
      os.path.join('files/', '', '/emma.txt', '')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> '~'
    - '/etc'
    - '/etc/'
    - 'files/emma.txt/'
    - 'files/emma.txt/'
    - 'files/emma.txt/'
    - '/emma.txt/'
    #+END_SRC

*** os.path. *normcase* (path)
    在不忽略大小写的系统上，原样返回；在忽略大小写的系统上，全部转换为
    小写。在Windows中，将斜杠转换为反斜杠。如果PATH不为字符串或bytes对
    象，抛出TypeError错误。

*** os.path. *normpath* (path)
    去除多余相对路径原点和斜杠。在Windows中，会将斜杠转换为反斜杠。

    *注意* ：如果PATH为软链接，可能会改变其含义。

    #+BEGIN_SRC python :session
      from os.path import normpath
      normpath('A//B')
      normpath('A/B/')
      normpath('A/./B')
      normpath('A/foo/../B/')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 'A/B'
    - 'A/B'
    - 'A/B'
    - 'A/B'
    #+END_SRC

*** os.path. *realpath* (path)
    将PATH转换为标准路径，如果为存在的软链接，返回指向目标。

    #+BEGIN_SRC python :session
      from os.path import realpath
      realpath('/dev/cdrom')
      realpath('.')
      realpath('~')
      realpath('not-exists')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - '/dev/sr0'
    - '/home/claudio/Desktop/Python/python-standard-lib-notes'
    - '/home/claudio/Desktop/Python/python-standard-lib-notes/~'
    - '/home/claudio/Desktop/Python/python-standard-lib-notes/not-exists'
    #+END_SRC

*** os.path. *relpath* (path,start=os.curdir)
    返回PATH相对于START（默认值为当前文件夹）的路径。

    仅仅是路径计算：不会访问文件系统判断PATH或START是否真实存在。

    #+BEGIN_SRC python :session
      from os.path import relpath
      relpath('/home')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - '../../../../../hom'
    #+END_SRC
*** os.path. *samefile* (path1,path2)
    如果path1和path2指向同一文件/文件夹，返回True。判断依据为“设备编
    号”（device number）和i-node值。如果对其中任意一个调用os.stat()失
    败，则抛出错误。

    #+BEGIN_SRC python :session
      from os.path import samefile
      samefile('files/emma.txt', 'files/../files/emma.txt')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - True
    #+END_SRC

    兼容：Unix，Windows

*** os.path. *sameopenfile* (fp1,fp2)？？？
    如果FP1和FP2“文件描述符”（file descriptor）指向同一文件，返回True。

    兼容：Unix，Windows
*** os.path. *samestat* (stat1,stat2)
    如果元组STAT1和STAT2指向同一文件，返回True。STAT1和STAT2可为
    os.fstat()、os.lstat()、os.stat()的返回结果。
    
    samefile()和sameopenfile()内部就是使用此函数进行的比较。
    
    兼容：Unix，Windows
    
*** os.path. *split* (path)
    将路径PATH分割为(head, tail)形式。其中tail为路径最后一部分，head为
    前面所有内容。

    tail部分不会有任何斜杠，如果PATH以斜杠结束，则tail为空；如果PATH中
    无任何斜杠，则head为空。

    除非为根目录，head中最后一个斜杠被自动去除。

    所有情况下，os.path.join(head, trail)的结果都与PATH含义一样，可能
    在字符串上有区别。

    #+BEGIN_SRC python :session
      import os.path

      os.path.split('~/Desktop/Python/test.py')
      os.path.split('~/Desktop/Python/')
      os.path.split('test.py')
      os.path.split('/')
      os.path.split('')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> ('~/Desktop/Python', 'test.py')
    - ('~/Desktop/Python', '')
    - ('', 'test.py')
    - ('/', '')
    - ('', '')
    #+END_SRC

*** os.path. *splitdrive* (path)
    将PATH分割为(drive, tail)，其中drive为挂载点或空字符串。在不支持驱
    动路径名的系统上，drive始终为空。所有情况下，drive+tail的结果都为
    PATH。

    如果PATH中有驱动名，则drive为冒号和之前的所有内容，如
    splitdrive('c:/dir')的结果为('c:', '/dir')。

    如果PATH为UNC路径，drive会包含主机名和共享文件夹名，如
    splitdrive('//host/share/dir')的结果为('//host/share', '/dir')。
    
*** os.path. *splitext* (path)
    将PATH分割为(root, ext)，且root+ext==PATH。ext为空或最多包含一个点
    的字符串。basename中最前面的点会被忽视。

    #+BEGIN_SRC python :session
      from os.path import splitext
      splitext('.emacs')
      splitext('.emacs/custom.el')
      splitext('emacs/custom.el')
      splitext('emacs/custom..el')
      splitext('emacs/custom')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - ('.emacs', '')
    - ('.emacs/custom', '.el')
    - ('emacs/custom', '.el')
    - ('emacs/custom.', '.el')
    - ('emacs/custom', '')
    #+END_SRC

*** os.path. *splitunc* (path)
    *注意* ：自从3.1版本就废除，使用splitdrive。
*** os.path. *supports_unicode_filenames*
    是否支持任意Unicode字符串作为文件名。

    #+BEGIN_SRC python :session
      from os.path import supports_unicode_filenames
      print(supports_unicode_filenames)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - False
    #+END_SRC

* fileinput - 迭代多个输入流中的行
  此模块的作用为迭代标准输入列或多个文件，如果只读写单个文件，可使用
  open()函数。
  
  基本用法为：
  
  #+BEGIN_EXAMPLE python
    import fileinput
    for line in fileinput.input():
        process(line)
  #+END_EXAMPLE
  
  此例将迭代sys.argv[1:]指定文件的所有行，如果此链表为空，则迭代
  sys.stdin；如果文件名为'-'，也迭代sys.stdin。如需指定文件名，可将文
  件名组成的链表作为input的参数，也可使用单个文件名作为参数。
  
  除在交互模式，或使用sys.stdin.seek(0)重置时，多次迭代sys.stdin只有第
  一个有效。
  
  空文件一打开就立即关闭。只有上一个文件最后一行读取后后一个文件名才有
  意义。
  
  可使用openhook参数控制文件打开方式。
  
** fileinput. *input* (files=None,inplace=False,backup='',bufsize=0,mode='r',openhook=none)
   创建一个FileInput类的实例。此实例被用作此模块中所有函数的全局状态，
   and is also returned to use during iteration。参数会全部传递给
   FileInput类的构造器。

   可使用with语句上下文管理器，即时处理文件时抛出错误，with语句退出时
   也会自动关闭文件：

   #+BEGIN_EXAMPLE python
     with fileinput.input(files=('spam.txt', 'eggs.txt')) as f:
          for line in f:
              process(line)
   #+END_EXAMPLE

   #+BEGIN_SRC python :session
      import fileinput
      with fileinput.input(files=('files/a.txt', 'files/b.txt')) as f:
          for line in f:
              print(line)
   #+END_SRC

   #+RESULTS:
   #+BEGIN_SRC org
   - ... ... ... 1
   - 2
   - 3
   - a
   - b
   - c
   #+END_SRC

   下面为使用fileinput.input()创建全局状态的函数。如果还没有调用
   fileinput.input()，抛出RuntimeError错误。

   #+BEGIN_SRC python :session
     import fileinput
     fileinput.filename()
   #+END_SRC

   #+RESULTS:
   #+BEGIN_SRC org
   - Traceback (most recent call last):
   -   File "<stdin>", line 1, in <module>
   -   File "/usr/lib/python3.5/fileinput.py", line 127, in filename
   -     raise RuntimeError("no active input()")
   - RuntimeError: no active input()
   #+END_SRC
   
*** fileinput. *filename* ()
    返回当前处理的文件名。如果还没开始读取，返回None。
    
    #+BEGIN_SRC python :session
      import fileinput
      with fileinput.input(files=('files/a.txt', 'files/b.txt')) as f:
          print(fileinput.filename())
          for line in f:
              print(fileinput.filename() + ' -> ' + line)
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - ... ... ... ... None
    - files/a.txt -> 1
    - files/a.txt -> 2
    - files/a.txt -> 3
    - files/b.txt -> a
    - files/b.txt -> b
    - files/b.txt -> c
    #+END_SRC

*** fileinput. *fileno* ()
    返回整数表示的当前文件“文件描述符”。如果没有文件被打开，返回-1。

    #+BEGIN_QUOTE
    文件描述符：第一次打开为3，以后每次打开增加1。？？？
    #+END_QUOTE

    #+BEGIN_SRC python :session
      import fileinput
      files = ('files/a.txt', 'files/b.txt')
      with fileinput.input(files=files) as f:
          print(fileinput.fileno())
          for line in f:
              print(fileinput.fileno(), ' -> ', line)
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> ... ... ... ... -1
    - 3  ->  1
    - 3  ->  2
    - 3  ->  3
    - 3  ->  a
    - 3  ->  b
    - 3  ->  c
    #+END_SRC

*** fileinput. *lineno* ()
    返回当前所有文件总共的处理函数。如果还没开始读取文件，返回0；如果
    已处理完所有行，返回最后一行的行数。

    #+BEGIN_SRC python :session
      import fileinput
      files = ('files/a.txt', 'files/b.txt')
      with fileinput.input(files=files) as f:
          print(fileinput.lineno())
          for line in f:
              print(fileinput.lineno(), ' -> ', line)
          print(fileinput.lineno())
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> ... ... ... ... ... 0
    - 1  ->  1
    - 2  ->  2
    - 3  ->  3
    - 4  ->  a
    - 5  ->  b
    - 6  ->  c
    - 6
    #+END_SRC

*** fileinput. *filelineno* ()
    返回当前文件所在行数。如果还没读取任何行，返回0；如果已读取最后一
    个文件的最后一行，返回最后一个文件最后一行的行数。

    #+BEGIN_SRC python :session
      import fileinput
      files = ('files/a.txt', 'files/b.txt')
      with fileinput.input(files=files) as f:
          print(fileinput.filelineno())
          for line in f:
              print(fileinput.filelineno(), ' -> ', line)
          print(fileinput.filelineno())
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> ... ... ... ... ... 0
    - 1  ->  1
    - 2  ->  2
    - 3  ->  3
    - 1  ->  a
    - 2  ->  b
    - 3  ->  c
    - 3
    #+END_SRC

*** fileinput. *isfirstline* ()
    如果时当前文件的第一行返回True，否则返回False。

    #+BEGIN_SRC python :session
      import fileinput
      files = ('files/a.txt', 'files/b.txt')
      with fileinput.input(files=files) as f:
          print(fileinput.isfirstline())
          for line in f:
              print('YES' if fileinput.isfirstline() else 'NO', ' -> ', line)
          print(fileinput.isfirstline())
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> ... ... ... ... ... False
    - YES  ->  1
    - NO  ->  2
    - NO  ->  3
    - YES  ->  a
    - NO  ->  b
    - NO  ->  c
    - False
    #+END_SRC

*** fileinput. *isstdin* ()
    如果上一行读取自sys.stdin返回True。

*** fileinput. *nextfile* ()
    关闭当前处理文件，读取下一个文件（如果有）。总共读取的函数lineno()
    根据实际读取行数递增。直到下一个文件的第一行读取，filename()不会变。

    在第一个文件的第一行读取前，以及在最后一个文件的最后一行读取后，此
    函数没有任何效果。

    #+BEGIN_SRC python :session
      import fileinput
      files = ('files/a.txt', 'files/b.txt')
      with fileinput.input(files=files) as f:
          print(f.readline())
          print(fileinput.fileno())
          print('共读取行数：', fileinput.lineno())
          fileinput.nextfile()
          print(f.readline())
          print('共读取行数：', fileinput.lineno())
          print(fileinput.filename())
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> ... ... ... ... ... ... ... ... 1
    - 3
    - 共读取行数： 1
    - a
    - 共读取行数： 2
    - files/b.txt
    #+END_SRC

*** fileinput. *close* ()
    关闭文件序列。
** class fileinput. *FileInput* *input* (files=None,inplace=False,backup='',bufsize=0,mode='r',openhook=none)
   
   FileInput类是i内部实现。除上面的模块函数对应的方法外，还有
   readline()方法，用于读取下一行；以及用于实现序列特性的__getitem__()
   方法。作为序列时，需按顺序获取内容；不能随机获取内容和readline()方
   法同时使用。
   
   #+BEGIN_SRC python :session
     import fileinput
     files = ('files/a.txt', 'files/b.txt')
     fs = fileinput.FileInput(files=files)
     # for line in fs:
     print(fs.readline())
     print(fs.readline())
     fs.close()
   #+END_SRC
   
   #+RESULTS:
   #+BEGIN_SRC org
   - >>> >>> ... 1
   - 2
   #+END_SRC
   
   MODE参数需为'r'、'rU'、'U'和'rb'中的一种。
   
   #+BEGIN_SRC python :session
     import fileinput
     files = ('files/a.txt', 'files/b.txt')

     def hook(filename, mode):
         return open(filename, mode='r+')

     with fileinput.input(files=files, openhook=hook) as fp:
         for line in fp:
             print(line)
   #+END_SRC
   
   #+RESULTS:
   #+BEGIN_SRC org
   - >>> >>> ... ... >>> ... ... ... 1
   - 2
   - 3
   - a
   - b
   - c
   #+END_SRC
   
   提供OPENHOOK参数时，须为接受两个参数的函数，FILENAME和MODE，并返回
   对应类文件对象。不同时使用INPLACE和OPENHOOK参数。
   
   FileInput实例也可用于with上下文，所有文件在离开with时自动关闭：

   #+BEGIN_EXAMPLE python
     with FileInput(files=('spam.txt', 'eggs.txt')) as input:
          process(input)
   #+END_EXAMPLE

*** inplace可选参数

    如果将fileinput.input()和FileInput的inplace参数设置为True，原文件
    将备份，且输出内容直接写入原文件。此时如果提供BACKUP参数，需为指定
    备份文件后缀的字符串。

    读取标准输入流时，此参数被忽视。

    #+BEGIN_EXAMPLE python
      import fileinput
      files = ('files/a.txt', 'files/b.txt')
      with fileinput.input(files=files, inplace=True, backup='.BAK') as fp:
          for line in fp:
              print(fileinput.filename() + ' ' + line)
    #+END_EXAMPLE

*** 钩子函数
**** fileinput. *hook_compressed* (filename, mode)
     使用gzip和bz2模块打开gzip和bzip2压缩文件（依靠.gz和.bz2后缀识别）。
     如果文件不是以.gz或.bz2结尾，如普通文件一样打开。用法：

     #+BEGIN_EXAMPLE python
       fi = fileinput.Fileinput(openhook=fileinput.hook_compressed)
     #+END_EXAMPLE

**** fileinput. *hook_encoded* (encoding)
     使用指定ENCODING打开并返回文件对象。用法：

     #+BEGIN_EXAMPLE python
       fi = fileinput.Fileinput(openhook=fileinput.hook_encoded)
     #+END_EXAMPLE

* stat - 解释os.*stat()函数结果
  stat模块定义了用于解释os.stat()、os.fstat()和os.lstat()返回结果的常
  量和函数。
  
  #+BEGIN_SRC python :session
    import stat
    import os
    print(os.stat('files/a.txt'))
  #+END_SRC
  
  #+RESULTS:
  #+BEGIN_SRC org
  - >>> os.stat_result(st_mode=33188, st_ino=24779705, st_dev=2049, st_nlink=1, st_uid=1000, st_gid=1000, st_size=6, st_atime=1495527828, st_mtime=1495439408, st_ctime=1495439408)
  #+END_SRC
  
** 判断函数

   正常情况下，可使用os.path.is*()函数判断文件类型。当多次判断同一文件
   的属性时，使用这些函数可避免重复调用stat()。还可判断os.path不能处理
   的文件类型，如块类型文件。

   *？* ：使用pathlib中的判断方法也能解决所有类型文件的判断问题。

   #+BEGIN_SRC python :session
    import os
    import sys
    import stat

    def walktree(top, callback):
        for f in os.listdir(top):
            pathname = os.path.join(top, f)
            mode = os.stat(pathname).st_mode
            # print(os.stat(pathname))
            if stat.S_ISDIR(mode):
                walktree(pathname, callback)
            elif stat.S_ISREG(mode):
                callback(pathname)
            else:
                print('跳过：' + pathname)

    def visitfile(file):
        print('访问：' + file)

    walktree(os.path.expanduser('files'), visitfile)
   #+END_SRC

   #+RESULTS:
   #+BEGIN_SRC org
    - >>> >>> >>> ... ... ... ... ... ... ... ... ... ... ... >>> ... ... >>> 访问：files/argparse_demo.py
    - 访问：files/b.txt
    - 访问：files/diff.py
    - 访问：files/output.txt
    - 访问：files/args.txt
    - 访问：files/gestalt.c
    - 访问：files/input.txt
    - 访问：files/a.txt
    - 访问：files/gestalt
    - 访问：files/emma.txt
    - 访问：files/argparse_demo_prog.py
   #+END_SRC
   
*** stat. *S_ISDIR* (mode)
    如果MODE来自文件夹，返回非0值。

    #+BEGIN_SRC python :session
      import os
      import stat
      filename = 'files/emma.txt'
      dirname = 'files'
      file_mode = os.stat(filename).st_mode
      dir_mode = os.stat(dirname).st_mode
      print('原来mode类型为整数：', file_mode)
      stat.S_ISREG(file_mode)
      stat.S_ISDIR(dir_mode)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> >>> >>> >>> 原来mode类型为整数： 33206
    - True
    - True
    #+END_SRC

*** stat. *S_ISCHR* (mode)
    如果MODE来自字符类型文件，返回非0值。

    #+BEGIN_SRC python :session
      import os
      import stat
      mode = os.stat('/dev/tty').st_mode
      stat.S_ISCHR(mode)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> True
    #+END_SRC

*** stat. *S_ISBLK* (mode)
    如果MODE来自块类型文件，返回非0值。

    #+BEGIN_SRC python :session
      import stat
      import os
      mode = os.stat('/dev/cdrom').st_mode
      stat.S_ISBLK(mode)
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> True
    #+END_SRC
    
*** stat. *S_ISREG* (mode)
    如果MODE来自普通文件，返回非0值。

    #+BEGIN_SRC python :session
      import os
      import stat
      mode = os.stat('files/emma.txt').st_mode
      stat.S_ISREG(mode)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> True
    #+END_SRC

*** stat. *S_ISFIFO* (mode)
    如果MODE来自FIFO类型文件（如命名管道），返回非0值。
*** stat. *S_ISLINK* (mode) ？？？
    如果MODE来自软链接，返回非0值。

    #+BEGIN_SRC python :session
      import os
      import stat
      mode = os.stat('/dev/cdrom').st_mode
      print(mode)
      stat.S_ISLNK(mode)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> 25008
    - False
    #+END_SRC

*** stat. *S_ISSOCK* (mode) （待续）
*** stat. *S_ISDOOR* (mode) （待续）
*** stat. *S_ISPORT* (mode) （待续）
*** stat. *S_ISWHT* (mode) （待续）
*** stat. *S_IMODE* (mode)
    返回MODE中能被os.chmod()使用的部分。即权限位、sticky位、用户组ID位、
    用户ID位。

    #+BEGIN_SRC python :session
      import os
      import stat
      mode = os.stat('files').st_mode
      print(mode, stat.S_IMODE(mode))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> 16877 493
    #+END_SRC

*** stat. *S_IFMT* (mode)
    返回MODE中表示文件类型的部分。上面的S_IS*判断函数就是使用的此返回
    值。

    #+BEGIN_SRC python :session
      import os
      import stat
      mode = os.stat('files').st_mode
      print(mode, stat.S_IFMT(mode))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> 16877 16384
    #+END_SRC

** 将mode转换为可读性强的字符形式
*** stat. *filemode* (mode)

    #+BEGIN_SRC python :session
      import os
      import stat
      mode = os.stat('files/emma.txt').st_mode
      stat.filemode(mode)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> '-rw-rw-rw-'
    #+END_SRC
** 对stat()结果进行索引的常量
   os.stat()、os.fstat()和os.lstat()的返回结果都是10个元素的元组。下面
   的常量其实都是整数，用于索引元组中的对应元素。
   
*** stat. *ST_MODE* ？？？
    inode protection mode。

    #+BEGIN_SRC python :session
       import stat
       import os
       mode = os.stat('files/')
       mode[stat.ST_MODE]
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> 16877
    #+END_SRC

*** stat. *ST_INO*
    inode值。

    #+BEGIN_SRC python :session
      import os
      import stat
      st = os.stat('files/emma.txt')
      st[stat.ST_INO]
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> 24779756
    #+END_SRC

    #+BEGIN_SRC sh :session
      ls files/emma.txt --inode
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 24779756 files/emma.txt
    #+END_SRC

*** stat. *ST_DEV* ？？？
    所在设备。

    #+BEGIN_SRC python :session
      import os
      import stat

      st = os.stat('files/emma.txt')
      print(st)
      st[stat.ST_DEV]
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> >>> os.stat_result(st_mode=33206, st_ino=24779756, st_dev=2049, st_nlink=1, st_uid=1000, st_gid=1000, st_size=2, st_atime=1495507123, st_mtime=1495266124, st_ctime=1495266124)
    - 2049
    #+END_SRC

*** stat. *ST_NLINK*
    链接数量。

    #+BEGIN_SRC python :session
      st[stat.ST_NLINK]
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 1
    #+END_SRC

*** stat. *ST_UID*
    用户ID。

    #+BEGIN_SRC python :session
      st[stat.ST_UID]
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 1000
    #+END_SRC

*** stat. *ST_GID*
    用户组ID。

    #+BEGIN_SRC python :session
      st[stat.ST_GID]
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 1000
    #+END_SRC

*** stat. *ST_SIZE*
    文件大小。

    文件“大小”的解释取决于文件类型。

    - 普通文件为byte数。
    - FIFO（如命名管道）和socket为当os.stat()、os.fstat()和os.lstat()
      调用时等待读取的byte数。
    - 字符型和块型文件的大小取决于系统调用。

    #+BEGIN_SRC python :session
      st[stat.ST_SIZE]
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - 2
    #+END_SRC
    
*** stat. *ST_ATIME*
*** stat. *ST_MTIME*
*** stat. *ST_CTIME*
    上次访问时间、修改时间和创建时间。

    创建时间CTIME由系统决定。在Unix中为上次元数据修改时间，Windows中为
    创建时间。

    #+BEGIN_SRC python :session
      import datetime
      import os
      import stat
      st = os.stat('files/emma.txt')
      atime = st[stat.ST_ATIME]
      mtime = st[stat.ST_MTIME]
      ctime = st[stat.ST_CTIME]

      def time_2_readable(time):
          return datetime.date.fromtimestamp(time)

      print('上次访问时间：', time_2_readable(atime))
      print('上次修改时间：', time_2_readable(mtime))
      print('创建时间：', time_2_readable(ctime))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> >>> >>> >>> >>> >>> >>> ... ... >>> >>> 上次访问时间： 2017-05-23
    - 上次修改时间： 2017-05-20
    - 创建时间： 2017-05-20
    #+END_SRC
** ST_MODE使用的flags
   Use of the functions above is more portable than use of the first
   set of flags:
   
*** stat. *S_IFSOCK*
    Socket。
*** stat. *S_IFLINK*
    软链接。
*** stat. *S_IFREG*
    普通文件。
*** stat. *S_IFBLK*
    块设备文件。
*** stat. *S_IFDIR*
    文件夹。
*** stat. *S_IFCHR*
    字符型文件。
*** stat. *S_IFIFO*
    FIFO。
*** stat. *S_IFDOOR*
    Door。
*** stat. *S_IFPORT*
    时间端口。
*** stat. *S_IFWHT*
    Whiteout。

    #+BEGIN_QUOTE
    *注意* ：对于S_IFDOOR、S_IFPORT和S_IFWHT，如果系统不支持此类型文件，
    则定义为0。
    #+END_QUOTE
    
    #+BEGIN_SRC python :session
      import stat
      flags = ['S_IFSOCK', 'S_IFLNK', 'S_IFREG', 'S_IFBLK',
               'S_IFDIR', 'S_IFCHR', 'S_IFIFO', 'S_IFDOOR', 'S_IFPORT', 'S_IFWHT']
      for flag in flags:
          print('stat.{} = {}'.format(flag, stat.__dict__[flag]))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - ... >>> ... ... stat.S_IFSOCK = 49152
    - stat.S_IFLNK = 40960
    - stat.S_IFREG = 32768
    - stat.S_IFBLK = 24576
    - stat.S_IFDIR = 16384
    - stat.S_IFCHR = 8192
    - stat.S_IFIFO = 4096
    - stat.S_IFDOOR = 0
    - stat.S_IFPORT = 0
    - stat.S_IFWHT = 0
    #+END_SRC

** 可作为os.chmod()的MODE参数flag的属性
*** stat. *S_ISUID*
    设置UID位。
    
    #+BEGIN_EXAMPLE ipython
      In [21]: ls -l test.txt
      -rw-r--r-- 1 claudio claudio 0 May 24 09:58 test.txt

      In [22]: os.chmod('test.txt', stat.S_ISUID)

      In [23]: ls -l test.txt
      ---S------ 1 claudio claudio 0 May 24 09:58 test.txt
    #+END_EXAMPLE

*** stat. *S_ISGID*
    设置GID位。此位有几个特殊用途。对于文件件：

    1. 其中创建的文件基础该文件夹的用户组ID，而不是创建该文件的用户组ID。
    2. 其中创建的子文件夹会自动设置S_ISGID位。

    对于普通文件：

    1. 如果没有设置用户组执行位（S_IXGRP），the set-group-ID bit
       indicates mandatory file/record locking。

    文件例子：

    #+BEGIN_EXAMPLE python
      In [40]: ls -l test.txt
      -rw-r--r-- 1 claudio claudio 0 May 24 10:02 test.txt

      In [41]: os.chmod('test.txt', stat.S_ISGID)

      In [42]: ls -l test.txt
      ------S--- 1 claudio claudio 0 May 24 10:02 test.txt
    #+END_EXAMPLE

    文件夹例子：

    #+BEGIN_EXAMPLE ipython
      In [37]: ls -ld test-dir/
      drwxr-xr-x 2 claudio claudio 4096 May 24 10:02 test-dir//

      In [38]: os.chmod('test-dir/', stat.S_ISGID)

      In [39]: ls -ld test-dir/
      d-----S--- 2 claudio claudio 4096 May 24 10:02 test-dir//
    #+END_EXAMPLE

*** stat. *S_ISVTX*
    Sticky位。如果设置在文件夹上，其中的文件重命名和删除只能由该文件拥
    有者、文件夹拥有者和授权进程操作。

    #+BEGIN_EXAMPLE ipython
      In [56]: ls -ld test-dir
      drwxr-xr-x 2 claudio claudio 4096 May 24 10:16 test-dir/

      In [57]: os.chmod('test-dir/', stat.S_ISVTX)

      In [58]: ls -ld test-dir
      d--------T 2 claudio claudio 4096 May 24 10:16 test-dir/
    #+END_EXAMPLE
    
*** stat. *S_IRWXU*
    所有者的权限mask。

    #+BEGIN_EXAMPLE python
      In [62]: ls -l test.txt
      -rw-r--r-- 1 claudio claudio 0 May 24 10:19 test.txt

      In [63]: os.chmod('test.txt', stat.S_IRWXU)

      In [64]: ls -l test.txt
      -rwx------ 1 claudio claudio 0 May 24 10:19 test.txt*
    #+END_EXAMPLE

*** stat. *S_IRUSR*
*** stat. *S_IWUSR*
*** stat. *S_IXUSR*
    拥有者的读、写和执行权限。

    #+BEGIN_EXAMPLE ipython
      In [76]: ls -l test.txt
      -rw-r--r-- 1 claudio claudio 0 May 24 10:23 test.txt

      In [77]: os.chmod('test.txt', stat.S_IRUSR)

      In [78]: ls -l test.txt
      -r-------- 1 claudio claudio 0 May 24 10:23 test.txt

      In [79]: os.chmod('test.txt', stat.S_IWUSR)

      In [80]: ls -l test.txt
      --w------- 1 claudio claudio 0 May 24 10:23 test.txt

      In [81]: os.chmod('test.txt', stat.S_IXUSR)

      In [82]: ls -l test.txt
      ---x------ 1 claudio claudio 0 May 24 10:23 test.txt*
    #+END_EXAMPLE

*** stat. *S_IRWXG*
    用户组的权限mask。
    
    #+BEGIN_EXAMPLE ipython
      In [85]: ls -l test.txt
      -rw-r--r-- 1 claudio claudio 0 May 24 10:28 test.txt

      In [86]: os.chmod('test.txt', stat.S_IRWXG)

      In [87]: ls -l test.txt
      ----rwx--- 1 claudio claudio 0 May 24 10:28 test.txt*
    #+END_EXAMPLE

*** stat. *S_IRGRP*
*** stat. *S_IWGRP*
*** stat. *S_IXGRP*
    用户组的读、写和执行权限。

    #+BEGIN_EXAMPLE ipython
      In [92]: ls -l test.txt
      -rw-r--r-- 1 claudio claudio 0 May 24 10:31 test.txt

      In [93]: os.chmod('test.txt', stat.S_IRGRP)
    
      In [94]: ls -l test.txt
      ----r----- 1 claudio claudio 0 May 24 10:31 test.txt

      In [95]: os.chmod('test.txt', stat.S_IWGRP)

      In [96]: ls -l test.txt
      -----w---- 1 claudio claudio 0 May 24 10:31 test.txt
    
      In [97]: os.chmod('test.txt', stat.S_IXGRP)

      In [98]: ls -l test.txt
      ------x--- 1 claudio claudio 0 May 24 10:31 test.txt*
    #+END_EXAMPLE

*** stat. *S_IRWXO*
    其他用户的权限mask。
*** stat. *S_IROTH*
*** stat. *S_IWOTH*
*** stat. *S_IXOTH*
    其他用户的读、写和执行权限。

    #+BEGIN_EXAMPLE ipython
      In [102]: ls -l test.txt
      -rw-r--r-- 1 claudio claudio 0 May 24 10:33 test.txt

      In [103]: os.chmod('test.txt', stat.S_IROTH)

      In [104]: ls -l test.txt
      -------r-- 1 claudio claudio 0 May 24 10:33 test.txt

      In [105]: os.chmod('test.txt', stat.S_IWOTH)

      In [106]: ls -l test.txt
      --------w- 1 claudio claudio 0 May 24 10:33 test.txt

      In [107]: os.chmod('test.txt', stat.S_IXOTH)

      In [108]: ls -l test.txt
      ---------x 1 claudio claudio 0 May 24 10:33 test.txt*
    #+END_EXAMPLE

*** stat. *S_ENFMT*
*** stat. *S_IREAD*
*** stat. *S_IWRITE*
*** stat. *S_IEXEC*
    上面4个为[[https://en.wikipedia.org/wiki/Version_7_Unix][Unix V7]]的权限位。
** 可作为os.chflags()FLAGS参数的值。

   #+BEGIN_QUOTE
   *？* ：我的Kali不支持chflags系统调用。
   #+END_QUOTE
   
*** stat. *UF_NODUMP*
    不dump文件。
*** stat. *UF_IMMUTABLE*
    可能不允许被修改。
*** stat. *UF_APPEND*
    可能只允许追加内容。
*** stat. *UF_OPAQUE* ？？？
    The directory is opaque when viewed through a union stack。
*** stat. *UF_NOUNLINK*
    文件可能不允许被重命名和删除。
*** stat. *UF_COMPRESSED*
    文件以压缩形式存储（Mac OS X 10.6+）。
*** stat. *UF_HIDDEN*
    在GUI环境中文件不显示（Mac OS X 10.5+）。
*** stat. *SF_ARCHIVED*
    文件可以被归档。

*** stat. *SF_IMMUTABLE*
    文件可能不允许被修改。
*** stat. *SF_APPEND*
    文件可能只允许追加内容。
*** stat. *SF_NOUNLINK*
    文件可能不允许被重命名和删除。
*** stat. *SF_SNAPSHOT*
    为快照文件。
** Windows中用于测试st_file_attributes中位的常量。（待续）

   #+BEGIN_SRC python :session
     import os
     print(os.name)
     print(os.stat('files/emma.txt'))
   #+END_SRC

   #+RESULTS:
   #+BEGIN_SRC org
   - posix
   - os.stat_result(st_mode=33206, st_ino=24779756, st_dev=2049, st_nlink=1, st_uid=1000, st_gid=1000, st_size=2, st_atime=1495593867, st_mtime=1495266124, st_ctime=1495266124)
   #+END_SRC

* filcmp - 文件和文件夹对比 （待续）
* tempfile - 创建临时文件/文件夹
  此模块的作用为创建临时文件/文件夹，兼容所有支持临时文件/文件夹的系统。
  TemporaryFile、NamedTemporaryFile、TemporaryDirectory和
  SpooledTemporaryFile为高阶接口，可自动清除临时文件/文件夹，可用于上
  下文管理器。mkstemp()和mkdtemp()为底层接口，需手动清除。

  所有用户可调用函数和构造器，都允许通过参数指定临时文件/文件夹地址和
  名称。此模块生成的文件名使用随机字符，可安全用于共享临时文件夹。为向
  后兼容，参数顺序有些许奇怪，建议使用关键字参数。

** 此模块所有用户可调用函数和构造器
*** tempfile. *TemporaryFile* (mode='w+b',buffering=None,encoding=None,newline=None,suffix=None,prefix=None,dir=None)
    返回“类文件对象”，可用于存储临时数据。以安全方式创建文件，使用
    mkstemp()相同的权限规则。关闭后自动清除（含垃圾回收后自动清除）。
    在Unix中，临时文件所在的文件夹不会创建，或在文件关闭后自动删除。其
    他系统不支持此特性，不可依赖此函数在文件系统中创建的文件名。

    可用于上下文管理器中，当退出上下文管理器，或删除返回的文件对象后，
    临时文件自动清除。

    MODE参数默认为'w+b'，所以可同时支持读和写模式，二进制模式保证所有
    平台上存储行为一致。BUFFERING、ENCODING和NEWLINE参数实际上是传递给
    open()函数。

    DIR、PREFIX和SUFFIX与mkstemp()同名参数用法相同。

    在POSIX平台上，返回结果为真正的文件对象；在其他平台下，为“类文件对
    象”，其file属性为实际文件对象。

    Linux内核3.11后，会自动使用os.O_TMPFILE flag。

*** tempfile. *NamedTemporaryFile* (mode='w+b',buffering=None,encoding=None,newline=None,suffix=None,prefix=None,dir=None,delete=None)
    除在文件系统中有可见文件名外（在Unix中，the directory entry is
    unlinked），与TemporaryFile()完全相同。文件名可通过返回值的name属
    性获取，是否可使用open()再次打开取决于操作系统（在Unix中可行，在
    Windows NT及以后版本不行）。返回对象总是“类文件对象”，实际文件对象
    可通过file属性获取，可同普通文件对象一样用于with上下文管理器。如果
    DELETE属性为True（默认），文件对象关闭后自动删除。

*** tempfile. *SpooledTemporaryFile* (mode='w+b',buffering=None,encoding=None,newline=None,suffix=None,prefix=None,dir=None)
    除数据直到超过MAX_SIZE前，或返回文件对象上调用fileno()方法前，都存
    储在内存中外，与TemporaryFile()完全相同。
    
    此外，返回的“类文件对象”有一个额外方法rollover()，不管大小，将文件
    数据全部写入（rollover）到磁盘中。
    
    返回值为“类文件对象”，_file属性为io.BatesIO或io.StringIO对象（取决
    于二进制还是文本模式打开），或真正文件对象（是否调用rollover()）方
    法。可同普通文件对象一样用于with上下文管理器。
    
*** tempfile. *TemporaryDirectory* (suffix=None,prefix=None,dir=None)
    使用mkdtemp()相同的规则，安全创建文件夹。返回对象可用于上下文管理
    器。山下文管理器退出，或返回对象被回收后，临时文件夹及其中内容全部
    清除。
    
    可通过返回对象的name属性获取文件夹名称。当在with上下文管理器中使用
    时，as后变量的值为此name属性值。
    
    可通过cleanup()方法手动清除文件夹。
    
*** tempfile. *mkstemp* (suffix=None,prefix=None,dir=None,text=False)
    以尽可能安全的方式创建临时文件。如果系统对os.open()有os.O_EXCL
    flag实现，则There are no race conditions in the file’s creation。
    只有创建此文件的用户对该文件有读和写权限；如果系统使用权限位表示文
    件是否可执行，则任何用户都没有执行权限。文件描述符不被子进程继承。

    不同于TemporaryFile()，使用完临时文件后，使用mkstemp()的用户有责任
    将其删除。

    如果SUFFIX参数不为None，新建临时文件以该参数值作为后缀，否则没有后
    缀。mkstemp()不会在文件名后后缀间添加点，如果需要，直接添加在
    SUFFIX参数值的最前面。

    如果PREFIX参数不为None，则新建文件夹以其参数值作为前缀，否则使用默
    认前缀。gettempprefix()和gettempprefixb()可返回默认前缀：

    #+BEGIN_SRC python :session
      import tempfile
      tempfile.gettempprefix()
      tempfile.gettempprefixb()
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - 'tmp'
    - b'tmp'
    #+END_SRC
    
    如果DIR参数不为None，则新建临时文件在该文件夹内，否则新建文件夹在
    默认文件夹内。默认临时文件夹由系统决定，但可通过设置环境变量TMPDIR、
    TEMP和TMP更改。There is thus no guarantee that the generated
    filename will have any nice properties, such as not requiring
    quoting when passed to external commands via os.popen()。？？？
    
    如果SUFFIX、PREFIX和DIR参宿任意一个不为None，都需同时为字符串或
    bytes对象的一种。如果都为bytes对象，则返回结果也为bytes对象。其他
    情况下如需返回结果为bytes对象，可在传递SUFFIX参数时使用bytes对
    象。？？？
    
    TEXT参数表示打开该文件时是否采用二进制（默认）方法。在一些系统中，
    此参数会被忽略。
    
    返回值为元组，第一个参数为使用os.open()打开该临时文件时返回的文件
    描述符，第二个参数为该临时文件的决定路径。
    
*** tempfile. *mkdtemp* (suffix=None,prefix=None,dir=None)
    以尽可能安全的方式创建临时文件夹。There are no race conditions in
    the directory’s creation. ？？？。只有创建该文件夹的用户对此文件夹
    有读、写和执行权限。

    使用mkdtemp()的用户有责任在使用完后删除该临时文件夹和文件夹中的内
    容。

    PREFIX、SUFFIX和DIR参数用法与mkstemp()相同。

    返回值为新文件夹的决定路径。

*** tempfile. *gettempdir* ()
*** tempfile. *gettempdirb* ()
    返回放置临时文件的文件夹。是本模块中所有函数的DIR参数的默认值。
    
    搜索顺序为：
    
    1. 环境变量TMPDIR指定文件夹。
    2. 环境变量TEMP指定文件夹。
    3. 环境变量TMP指定文件夹。
    4. 操作系统决定：
       - Windows：顺序为，C:\TEMP，C:\TMP和\TEMP。
       - 其他系统：顺序为：/tmp，/var/tmp和/usr/tmp。
    5. 当前文件夹。

    搜索结果会被缓存。

*** tempfile. *gettempprefix* ()
*** tempfile. *gettempprefixb* ()
    临时文件夹前缀。
    
*** tempfile. *tempdir*
    全局变量，缓存gettempdir()搜索结果。可直接设置，但不推荐。定制可通
    过各个函数的DIR参数实现。
    
    当设置为非None值后，会成为本模块中所有函数DIR参数的默认值。
    
    如果设置为None或unset，调用上面除gettempprefix()外的函数会同
    gettempdir()执行顺序一样初始化。
    
** 举例
   
   #+BEGIN_EXAMPLE python
     import tempfile
   
     # 创建临时文件，并写入数据
     fp = tempfile.TemporaryFile()
     fp.write(b'hello, world!')
     # 读取数据
     fp.seek(0)
     print(fp.read())
   
     # 使用上下文管理器创建临时文件
     with tempfile.TemporaryFile() as fp:
         fp.write(b'hello world!')
         fp.seek(0)
         print(fp.read())
   
     # 此时临时文件关闭并自动删除

     # 使用上下文管理器创建临时文件夹
     with tempfile.TemporaryDirectory() as tmpdirname:
         print('创建临时文件夹：', tmpdirname)

     # 文件夹中的内容及文件夹被删除
   #+END_EXAMPLE

** 已废除函数和常量
*** tempfile. *mktemp* (suffix='',prefix='tmp',dir=None)
* glob - Unix风格“路径”扩张
  根据Unix shell规则，查找所有满足匹配的路径，但结果顺序不定。不会扩张
  “~”，但可扩张*、?和使用[]包裹的字符。实际上是调用了os.listdir()和
  fnmatch.fnmatch()，不使用subshell。与fnmatch.fnmath()不同，glob将以
  “.”开始的文件名特殊对待。如需扩张“~”和系统变量，使用
  os.path.expanduser()和os.path.expandvars()。
  
  如需匹配特殊字符本身，可将其置于[]内。如[?]匹配'?'。
  
** glob. *glob* (pathname,*,recursive=False)
   返回匹配PATHNAME文件路径字符串组成的链表。PATHNAME可以为绝对路径字
   符串（如/usr/src/**/*.py），也可为相对路径（如../../Tools/*/*.gif），
   可含shell风格的通配符，已损坏的软链接也包含在结果中。

   如果RECURSIVE参数为True，则PATHNAME中的**会匹配任何文件，以及0个或
   多个文件夹和子文件夹。如果同时PATHNAME以os.sep结尾，则只匹配文件夹
   和子文件夹。

** glob. *iglob* (pathname,recursive=False)
   与glob()结果相同，只是返回值为iterator，不将结果写入内容。
** glob. *escape* (pathname)
   去转义（escape）所有特殊字符（?、 * 、[）。drive/UNC sharepoit中的
   特殊字符不去转义，如Windows中，escape('//?/c:/Quo vadis?.txt')返回
   结果为'//?/c:/Quo vadia[?].txt'。

   #+BEGIN_SRC python :session
     import glob
     glob.escape('?*[')
   #+END_SRC

   #+RESULTS:
   #+BEGIN_SRC org
   - '[?][*][[]'
   #+END_SRC

** 举例
   
   假设当前文件夹中有文件1.gif、2.txt和card.gf，子文件夹sub，其中含文
   件3.txt。
   
   #+BEGIN_EXAMPLE python
     >>> import glob
     >>> glob.glob('./[0-9].*')
     ['./2.txt', './1.gif']
     >>> glob.glob('*.gif')
     ['card.gif', '1.gif']
     >>> glob.glob('?.gif')
     ['1.gif']
     >>> glob.glob('**/*.txt')
     ['sub/3.txt']
     >>> glob.glob('**/*.txt', recursive=True)
     ['2.txt', 'sub/3.txt']
     >>> glob.glob('./**/', recursive=True)
     ['./', './sub/']
     >>> glob.glob('./**/')
     ['./sub/']
   #+END_EXAMPLE
   
* fnmatch - Unix“文件名”模式匹配
  此模块提供Unix shell风格的通配符匹配文件，区别于正则。支持的特殊字符
  有：

  | 模板   | 含义                  |
  |--------+-----------------------|
  | *      | 匹配所有              |
  | ?      | 匹配单个字符          |
  | [seq]  | 匹配seq中任意一个字符 |
  | [!seq] | 不匹配seq中任何字符   |

  如需将特殊字符作为普通字符，将其包含在方括号中。如'[?]'匹配'?'。

  *注意* ：

  - 路径分隔符"/"不为特殊字符。
  - 点“.”也不为特殊字符。

** fnmatch. *fnmatch* (filename,pattern)
   测试FILENAME是否匹配PATTERN字符串，返回True或False。

   如果操作系统不区分大小写，两个参数都全会转换为大写/小写后再比较。不
   管系统是否区分大小写，可使用fnmatchcase()进行区分大小写的比较。

   如下例打印当前文件夹中以'.txt'为后缀的文件：

   #+BEGIN_EXAMPLE python
     import fnmatch
     import os

     for file in os.listdir('.'):
         if fnmatch.fnmatch(file, '*.txt'):
            print(file)
   #+END_EXAMPLE

** fnmatch. *fnmatchcase* (filename,pattern)
   强制区分大小写的fnmatch()版本。
** fnmatch. *filter* (names,pattern)
   返回链表NAMES中匹配PATTERN的子集，基本上等价于：

   #+BEGIN_EXAMPLE python
     [n for n in names if fnmatch(n, pattern)]
   #+END_EXAMPLE

   不过效率更高。

** fnmatch. *translate* (pattern)
   将shell风格的PATTERN转换为正则字符串，可被re.match()使用：

   #+BEGIN_EXAMPLE python
     import fnmatch
     import re

     regex = fnmatch.translate('*.txt')
     print(regex)
     reobj = re.compile(regex)
     print(reobj.match('foobar.txt'))
   #+END_EXAMPLE

* linecache - 随机访问文本行 （待续）
* shutil - 高阶文件操作o
  shutil模块提供了复制和删除多个文件/文件夹的高阶操作。如需操作单个文
  件，使用os模块。

  #+BEGIN_QUOTE
  *警告* ：即时使用shutil.copy()和shutil.copy2()也不能完全复制所有文件
  的元数据。

  - POSIX平台上：文件的拥有者、拥有者用户组和ACL丢失。
  - Mac OS：resource fork和其他元数据丢失。即resources丢失，以及创建者
    信息出现偏差。？？？
  - Windows：文件拥有者、ACL和其他数据流丢失。？？？
  #+END_QUOTE

** 文件和文件夹操作
*** shutil. *copyfileobj* (fsrc,fdst[,lenth])
    将“类文件对象”FSRC中的内容复制到“类文件对象”FDST中。

    LENGTH参数如果提供，则表示缓存大小。如果为负数，表示不从缓存中读取
    数据；默认会在缓存中读取数据，以免造成内存耗尽。

    如果当前FSRC中文件指针不为0，则从当前位置开始复制数据。

    #+BEGIN_SRC sh :session
      cat files/a.txt
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 1
    - 2
    - 3
    #+END_SRC

    #+BEGIN_SRC sh :session
      cat files/b.txt
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - a
    - b
    - c
    #+END_SRC

    #+BEGIN_SRC python :session
      import shutil
      fo_src = open('files/a.txt')
      fo_dst = open('files/b.txt', 'a')
      shutil.copyfileobj(fo_src, fo_dst)
      fo_src.close()
      fo_dst.close()
    #+END_SRC

    #+BEGIN_SRC sh :session
      cat files/b.txt
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - a
    - b
    - c
    - 1
    - 2
    - 3
    #+END_SRC

*** shutil. *copyfile* (src,dst,*,follow_symlinks=True)
    将名为SRC文件中的内容（如元数据）复制到名为DST的文件中。SRC和DST都
    为字符串。如果SRC和DST为同一文件，抛出shutil.SameFileError错误。

    DST所在的文件夹需有可写权限，否则抛出OSError错误。如果DST已存在，
    则替换。特殊文件如字符型和块型文件不能使用此函数复制。

    如果FOLLOW_SYMLINKS为False，且SRC为软链接，复制的是软链接本身，而
    不是软链接指向的目标文件。

    #+BEGIN_SRC python :session
      import shutil
      src = 'files/a.txt'
      dst = 'files/b.txt'
      shutil.copyfile(src, dst)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> 'files/b.txt'
    #+END_SRC

**** exception shutil. *SameFileError*
     copyfile()中SRC和DST为同一文件时抛出的错误类型，为Error的子类。

*** shutil. *copymode* (src,dst,*,follow_symlinks=True)
    将SRC的权限位复制到DST上。文件的内容、拥有者、拥有者用户组不被影响。
    SRC和DST都为字符串。

    如果FOLLOW_SYMLINKS为False，操作的为软链接本身，而非指向的目标文件。
    并不是所有系统都支持修改软链接，具体可参考copystat()函数。如果复制
    失败不会报错。

    #+BEGIN_EXAMPLE ipython
      In [188]: ls -l a.txt b.txt
      -rwx------ 1 claudio claudio 6 May 24 15:32 a.txt*
      -rw-rw-rw- 1 claudio claudio 6 May 20 15:42 b.txt

      In [189]: shutil.copymode('b.txt', 'a.txt')

      In [190]: ls -l a.txt b.txt
      -rw-rw-rw- 1 claudio claudio 6 May 24 15:32 a.txt
      -rw-rw-rw- 1 claudio claudio 6 May 20 15:42 b.txt
    #+END_EXAMPLE
    
*** shutil. *copystat* (src,dst,*,follow_symlinks=True)
    将SRC的权限位、上次访问时间、上次修改时间和flags复制到DST。在Linux
    中，还会尽可能复制“扩展属性”。不会修改文件内容、所有者、所有者用户
    组。SRC和DST都为指定路径的字符串。
    
    如果FOLLOW_SYMLINKS为False，为操作软链接，而非指向文件。
    
    #+BEGIN_QUOTE
    *注意* ：并不是所有系统都支持检查和修改软链接。可使用Python获取支
    持情况：
    
    - 如果os.chmod在os.supports_follow_symlinks中，copystat()可修改软
      链接权限位。
    - 如果os.utime在os.supports_follow_symlinks中，copystat()可修改软
      链接上次访问时间和修改时间。
    - 如果os.chflags在os.supports_follow_symlinks中，copystat()可修改
      软链接的flags。（不是所有系统都支持。）

    如果系统中一些上述功能缺少，修改软链接时copystat()会尽量修改能修改
    的部分，从不因失败报错。

    #+BEGIN_SRC python :session
      import os
      os.supports_follow_symlinks
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - {<built-in function stat>, <built-in function utime>, <built-in function chown>, <built-in function link>, <built-in function access>}
    #+END_SRC

    #+END_QUOTE

    #+BEGIN_EXAMPLE ipython
      In [174]: ls -l a.txt
      -rw-r--r-- 1 claudio claudio 6 May 22 15:50 a.txt

      In [175]: os.chmod('a.txt', stat.S_IRWXU)

      In [176]: ls -l a.txt b.txt
      -rwx------ 1 claudio claudio 6 May 22 15:50 a.txt*
      -rw-r--r-- 1 claudio claudio 6 May 24 15:07 b.txt

      In [177]: shutil.copystat('a.txt', 'b.txt')

      In [178]: ls -l a.txt b.txt
      -rwx------ 1 claudio claudio 6 May 22 15:50 a.txt*
      -rwx------ 1 claudio claudio 6 May 22 15:50 b.txt*
    #+END_EXAMPLE
    
*** shutil. *copy* (src,dst,*,follow_symlinks=True)
    将SRC文件复制为DST文件，或复制到DST文件夹中。SRC和DST都需为字符串。
    如果DST为文件夹，则将SRC复制到文件夹中，且使用SRC的basename作为新
    文件名，返回新文件的路径字符串。

    如果FOLLOW_SYMLINKS为False，且SRC为软链接，则DST也为软链接；如果为
    True，DST为SRC指向的目标文件。
    
    copy()复制文件内数据和文件权限位，其他如文件创建和修改时间等元数据
    不会复制。如需复制所有文件元数据，参考copy2()。
    
    如使用copy()不会修改新文件最后修改时间：

    #+BEGIN_EXAMPLE ipython
      In [206]: ls -l a.txt b.txt
      -rw-rw-rw- 1 claudio claudio 6 May 24 15:32 a.txt
      -rw-rw-rw- 1 claudio claudio 6 May 24 15:46 b.txt

      In [207]: shutil.copy('a.txt', 'b.txt')
      Out[207]: 'b.txt'

      In [208]: ls -l a.txt b.txt
      -rw-rw-rw- 1 claudio claudio 6 May 24 15:32 a.txt
      -rw-rw-rw- 1 claudio claudio 6 May 24 15:46 b.txt
    #+END_EXAMPLE

    而使用copy2()则会使两者最后修改时间相同：

    #+BEGIN_EXAMPLE ipython
      In [209]: shutil.copy2('a.txt', 'b.txt')
      Out[209]: 'b.txt'

      In [210]: ls -l a.txt b.txt
      -rw-rw-rw- 1 claudio claudio 6 May 24 15:32 a.txt
      -rw-rw-rw- 1 claudio claudio 6 May 24 15:32 b.txt
    #+END_EXAMPLE

*** shutil. *copy2* (src,dst,*,follow_symlinks=True)
    除copy()的功能外，还会使用copystat()尽可能复制文件元数据。
    
*** shutil. *ignore_patterns* (*patterns)
    工厂函数，返回作为copytree()的IGNORE参数的可调用对象。即忽视匹配
    glob风格PATTERN的文件和文件夹。

*** shutil. *copytree* (src,dst,symlinks=False,ignore=None,copy_function=copy2,ignore_dangling_symlinks=False)
    将文件夹SRC递归复制到文件夹DST，返回DST路径字符串。DST文件夹需不存
    在，如果父路径不存在，自动创建。对应权限和时间数据，文件夹和子文件
    夹使用copystat()复制，单个使用copy2()复制。
    
    #+BEGIN_EXAMPLE ipython
      In [236]: ls -l dir1
      total 4
      drwxr-xr-x 2 claudio claudio 4096 May 24 15:59 dir-in/
      -rw-r--r-- 1 claudio claudio    0 May 24 15:59 test.txt

      In [237]: shutil.copytree('dir1', 'dir2')
      Out[237]: 'dir2'

      In [238]: ls -l dir2
      total 4
      drwxr-xr-x 2 claudio claudio 4096 May 24 15:59 dir-in/
      -rw-r--r-- 1 claudio claudio    0 May 24 15:59 test.txt

      in [239]: shutil.copytree('dir1', 'DIR/dir2')
      Out[239]: 'DIR/dir2'

      In [240]: ls -l DIR
      total 4
      drwxr-xr-x 3 claudio claudio 4096 May 24 15:59 dir2/
    #+END_EXAMPLE
    
    如果SYMLINKS参数为True，软链接及其元数据也会复制到新的文件夹；如果
    为False，则是复制软链接指向的文件及其元数据到新文件夹。
    
    如果SYMLINKS参数为False，且软链接指向的文件不存在，复制时会将抛出
    错误添加到由错误组成的链表中，在整个复制过程结束后抛出。如需忽视此
    错误，可设置IGNORE_DANGLING_SYMLINKS参数为True。不过，在不支持
    os.symlink()的系统中，没有任何效果。

    如果设置参数IGNORE，须为接受copytree()执行过程中的当前文件夹路径，
    以及当前文件夹执行os.listdir()结果的链表，返回值为由当前文件夹路径
    和文件组成的链表，此链表中的文件路径被忽视。也可使用
    shutil.ignore_patterns()工厂函数返回值。源码为：

    #+BEGIN_EXAMPLE python
      def ignore_patterns(*patterns):
          """Function that can be used as copytree() ignore parameter.
          Patterns is a sequence of glob-style patterns
          that are used to exclude files"""
          def _ignore_patterns(path, names):
              ignored_names = []
              for pattern in patterns:
                  ignored_names.extend(fnmatch.filter(names, pattern))
              return set(ignored_names)
          return _ignore_patterns
    #+END_EXAMPLE

    举例：忽视后缀为.txt的文件。

    #+BEGIN_EXAMPLE ipython
      In [250]: ls -l dir1
      total 4
      drwxr-xr-x 2 claudio claudio 4096 May 24 15:59 dir-in/
      -rw-r--r-- 1 claudio claudio    0 May 24 15:59 test.txt

      In [251]: shutil.copytree('dir1', 'dir2', ignore=shutil.ignore_patterns('*.txt'))
      Out[251]: 'dir2'

      In [252]: ls -l dir2
      total 4
      drwxr-xr-x 2 claudio claudio 4096 May 24 15:59 dir-in/
    #+END_EXAMPLE

*** shutil. *rmtree* (path,ignore_errors=False,onerror=None)
    删除整个文件夹；PATH需为表示文件夹路径的字符串（不能为指向文件夹的
    软链接）。
    
    如果IGNORE_ERRORS参数为True，任何删除文件时抛出的错误将被忽视；如
    果为False，函数执行过程中所有抛出的错误会添加到一个链表中，最后由
    ONERROR参数（可调用对象处理）。
    
    如果提供ONERROR参数，须为接受三个参数的可调用对象：fn、path,
    excinfo。其中：
    
    - fn：抛出错误时执行的函数；由系统和Python实现决定。
    - path：传递个fn的路径参数。
    - excinfo：sys.exc_info()返回结果。
      
    ONERROR抛出的结果不被捕获。
    
**** rmtree. *avoid_symlink_attacks*

     表明Python在当前系统中的实现，是否支持防止 [[http://www.freebuf.com/vuls/49641.html][软链接攻击]] 版本的
     rmtree()：

     #+BEGIN_SRC python :session
       import shutil
       shutil.rmtree.avoids_symlink_attacks
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - True
     #+END_SRC

*** shutil. *move* (src,dst,copy_function=copy2)
    递归将文件/文件夹（SRC）移至DST，返回最终路径字符串。

    如果DST为已存在的文件夹，则将SRC移至DST中；如果存在，但不是文件夹，
    则根据os.rename()的语法进行操作（一般为默认删除原来文件）。

    如果DST存在于同一文件系统，实际上调用的时os.rename()。否则，会使用
    COPY_FUNCTION参数指定的函数将复制到DST，然后再删除。

    如果SRC为软链接，会将SRC指向的目标文件复制为DST或移至DST中，然后删
    除SRC。

    如果指定COPY_FUNCTION参数，需为接受src和dst（将src复制到dst）两个
    参数的函数，但在os.rename()不能使用的情况下才调用。如果SRC为文件夹，
    默认的，会调用copy_tree()函数，COPY_FUNCTION也会用于copy_tree()的
    同名参数。在不能复制元数据的情况系，可选用copy()。

*** shutil. *disk_usage* (path) ？？？
    返回PATH路径下的磁盘使用情况，返回值为namedtuple，分别为总量，已使
    用大小和剩余大小。

    #+BEGIN_SRC python :session
      import shutil
      shutil.disk_usage('/home/claudio/Desktop/Python/')
      shutil.disk_usage('/home/claudio/Desktop/Emacs/')
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - usage(total=488081694720, used=28870664192, free=434394173440)
    - usage(total=488081694720, used=28870664192, free=434394173440)
    #+END_SRC

    兼容：Unix,Windows。

*** shutil. *chown* (path,user=None,group=None)
    改变PATH指定文件/文件夹的拥有者或/和拥有者用户组。

    USER和GROUP需至少指定一个，可以是ID，也可以是名称。

    os.chown()为其内部实现函数。

    兼容：Unix。

*** shutil. *which* (cmd,mode=os.F_OK|os.X_OK,path=None)
    返回命令CMD对应的可执行文件路径。如果没有找到，返回None。

    MODE参数为os.access()使用的权限掩码，默认为存在且可执行。

    如果没提供PATH参数，则使用os.environ中“PATH”对应值，如果不能获取
    “PATH”则使用os.defpath。

    #+BEGIN_SRC python :session
      import shutil
      shutil.which('emacs')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - '/usr/bin/emacs'
    #+END_SRC

    Windows中：（待续）。

*** exception shutil. *Error*
    在操作多个文件时，所有抛出错误组成的exception集合。对于copytree()，
    exception的参数为3元素元组（srcname,dstname,exception）。

*** copytree举例
    下例为copytree()函数的大致源码。可用来理解此模块中其他几个函数的用
    法：

    #+BEGIN_EXAMPLE python
      def copytree_(src, dst, symlinks=False):
          names = os.listdir(src)
          os.makedirs(dst)
          errors = []
          for name in names:
              srcname = os.path.join(src, name)
              dstname = os.path.join(dst, name)
              try:
                  if symlinks and os.path.islink(srcname):
                      linkto = os.readlink(srcname)
                      os.symlink(linkto, dstname)
                  elif os.path.isdir(srcname):
                      copytree_(srcname, dstname, symlinks)
                  else:
                      cop2(srcname, dstname)
              except OSError as why:
                  errors.append((srcname, dstname, str(why)))
              except Error as err:
                  errors.extend(err.args[0])
          try:
              copystat(src, dst)
          except OSError as why:
              if why.winerror is None:
                  errors.extend((src, dst, str(why)))
          if errors:
              raise Error(errors)
    #+END_EXAMPLE
    
    使用ignore_patters()工厂函数可过滤不想复制的内容。
    
    #+BEGIN_EXAMPLE python
      from shutil import copytree, ignore_patterns

      copytree(source, destination, ignore=ignore_patterns('*.pyc', 'tmp*'))
    #+END_EXAMPLE
    
    还可定制ignore函数，使其不过滤任何文件，只提供当前文件夹信息：
    
    #+BEGIN_EXAMPLE python
      from shutil import copytree
      import logging

      def _logpath(path, names):
          logging.info('正在处理文件夹： {}'.format(path))
          return [] # 不过滤任何内容

      copytree.(source, destination, ignore=_logpath)
    #+END_EXAMPLE
    
*** rmtree举例
    如何在Windows中删除没有可写权限文件夹中的文件。
    
    #+BEGIN_EXAMPLE python
      import os, stat, shutil

      def remove_readonly(fun, path, _):
          '清除自读权限，再次尝试删除。'
          os.chmod(path, stat.S_IWRITE)
          func(path)

      shutil.rmtree(directory, onerror=remove_readonly)
    #+END_EXAMPLE
    
** 归档操作
   提供压缩和归档文件的高阶函数。依赖于zipfile和tarfile两个模块。
   
*** shutil. *make_archive* (base_name,format[,root_dir[,base_dir[,verbose[,dry_run[,owner[,group[,logger]]]]]]])
    创建归档文件（如.zip和.tar），返回归档文件名称。

    BASE_NAME：将创建的归档文件名称，不需提供后缀。

    FORMAT：归档文件格式，如："zip"（依赖于zlib模块）、"tar"和"gztar"
    （依赖于gztar模块）、"bztar"（依赖于bz2模块）或"xztar"（依赖于lzma
    模块）。

    ROOT_DIR：为归档文件最终所处文件夹；比如通常将当前路径更改为
    ROOT_DIR再创建归档文件。
    
    BASE_DIR：开始归档的文件夹。BASE_DIR会成为所有归档文件和文件夹的路
    径前缀。

    ROOT_DIR和BASE_DIR都默认为当前文件夹。

    DRY_RUN：如果为True，不会创建归档文件，但操作还是会执行，并被记录
    到LOGGER。
    
    OWNER和GROUP：用于创建归档文件。默认为当前用户和用户组。

    LOGGER：需为兼容 [[https://www.python.org/dev/peps/pep-0282/][PEP 282]] 的对象，通常为logging.Logger。
    
    VERBOSE：已废除。
    
*** shutil. *get_archive_formats* ()
    返回支持的归档格式，结果为2元组(name, description)组成的链表。

    #+BEGIN_SRC python :session
      import shutil
      shutil.get_archive_formats()
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - [('bztar', "bzip2'ed tar-file"), ('gztar', "gzip'ed tar-file"), ('tar', 'uncompressed tar file'), ('xztar', "xz'ed tar-file"), ('zip', 'ZIP file')]
    #+END_SRC

    shutil默认提供的格式有：

    - zip：ZIP文件（依赖zlib模块）。
    - tar：未压缩的tar文件。
    - gztar：采用gzip压缩后的归档文件（依赖于zlib模块）。
    - bztar：采用bzip2压缩后的归档文件（依赖于bz2模块）。
    - xztar：采用xz压缩后的归档文件（依赖于lzma模块）。

    可使用register_archive_format()函数注册自己的格式，或修改现有格式
    的操作函数。

*** shutil. *register_archive_format* (name,function[,extra_args[,description]]) （待续）
    在get_archive_formats()结果的基础上添加归档格式和对应操作函数。

*** shutil. *unregister_archive_format* (name)
    将格式NAME从支持的格式中移除。

*** shutil. *unpack_archive* (filename[,extra_dir[,format]])
    解压归档文件，FILENAME为归档文件的全路径。

    EXTRACT_DIR为解压后文件的放置位置。默认为当前文件夹。

    FORMAT为归档格式中的一种："zip"、"tar"、"gztar"、"bztar"或"xztar"，
    或为register_unpack_format()注册的格式。如果没有有提供，
    unpack_archive()会根据文件后缀检查对应格式是否注册。如果没找到则抛
    出ValueError错误。

*** shutil. *register_unpack_format* (name,extensions,function[,extra_args[,description]]) （待续）
    注册解压格式和对应操作函数。
*** shutil. *unregister_unpack_format* (name)
    将NAME中解压格式支持中移除。
*** shutil. *get_unpack_formats* ()
    获取支持的解压格式。结果为3元素元组(name, extensions, description)
    组成的链表。

    #+BEGIN_SRC python :session
      import shutil
      shutil.unregister_unpack_format('bztar')
      shutil.get_unpack_formats()
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> [('gztar', ['.tar.gz', '.tgz'], "gzip'ed tar-file"), ('tar', ['.tar'], 'uncompressed tar file'), ('xztar', ['.tar.xz', '.txz'], "xz'ed tar-file"), ('zip', ['.zip'], 'ZIP file')]
    #+END_SRC

*** 归档举例
    归档家目录下的.ssh文件夹。

    #+BEGIN_EXAMPLE
      >>> from shutil import make_archive
      >>> import os
      >>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))
      >>> root_dir = os.path.expanduser(os.path.join('~', '.ssh'))
      >>> make_archive(archive_name, 'gztar', root_dir)
      '/home/claudio/myarchive.tar.gz'
    #+END_EXAMPLE

    结果为：

    #+BEGIN_EXAMPLE
      claudio@host:~$ tar ztvf myarchive.tar.gz
      drwx------ claudio/claudio   0 2017-02-12 18:51 ./
      -rw-r--r-- claudio/claudio 404 2017-02-12 18:49 ./id_rsa.pub
      -rw-r--r-- claudio/claudio 2210 2017-03-30 21:01 ./known_hosts
      -rw------- claudio/claudio 1679 2017-02-12 18:49 ./id_rsa
    #+END_EXAMPLE

** 获取输出终端大小
*** shutil. *get_terminal_size* (fallback=(columns,lines))
    获取终端窗口大小。
    
    如果有系统变量COLUMNS和LINES，则检查其值，如果定义且为正整数，就使
    用该值。
    
    当没有定义这两个系统变量时，the terminal connected to
    sys.__stdout__ is queried by invoking os.get_terminal_size()。？？？
    
    如果上述方法都请求失败，可能为系统不支持，或当前进程并没有连接在终
    端上。此时使用FALLBACK参数值返回，默认为(80, 24)，即大多数终端模拟
    器的默认尺寸。
    
    返回值为namedtuple，类型为os.terminal_size。
    
    #+BEGIN_SRC python :session
      import shutil
      shutil.get_terminal_size()
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - os.terminal_size(columns=80, lines=0)
    #+END_SRC
    
* macpath - “Mac OS 9”路径处理函数 （待续）
