# Author: Claudio <3261958605@qq.com>
# Created: 2017-05-19 11:23:35
# Commentary:
#+TITLE: 文件和文件夹操作

* pathlib - 面向对象的文件系统路径
  此模块提供不同系统表示文件系统的类。路径类分为两类，对I/O没有操作的
  纯路径计算操作Pure Path，和继承于Pure Path，对I/O有操作的Concrete
  Path。
  
  如果从来没使用过此模块，或不确定使用哪个类，最好选用Path类。它实例
  化了当前环境中的Concrete Path。
  
  Pure Path在一些特殊情况下有用。如：
  
   - 如需在Unix系统下操作Window路径（反之亦然），不能在Unix系统上实例
     化WindowsPath类，但可以实例化PureWindowsPath。
   - 如需保证代码操作路径同时，不与操作系统产生交互，可实例化纯路径类。
     
** 基本用法
   导入主类：
   
   #+BEGIN_EXAMPLE python
     >>> from pathlib import Path
   #+END_EXAMPLE
   
   列出当前子文件夹：
   
   #+BEGIN_EXAMPLE python
     >>> [x for x in p.iterdir() if x.is_dir()]
     [...]
   #+END_EXAMPLE
   
   列出当前文件夹中的所有Python源码文件：
   
   #+BEGIN_EXAMPLE python
     >>> list(p.glob('**/*.py'))
     [PosixPath('test.py')]
   #+END_EXAMPLE
   
   浏览在文件夹中：
   
   #+BEGIN_EXAMPLE python
     >>> p = Path('/etc')
     >>> q = p/'init.d'/'reboot'
     >>> q
     PosixPath('/etc/init.d/reboot')
     >>> q.resolve()
     PosixPath('/etc/init.d/reboot')
   #+END_EXAMPLE
   
   获取路径属性：
   
   #+BEGIN_EXAMPLE python
     >>> q.exists()
     True
     >>> q.is_dir()
     False
     >>> q.is_file()
     True
   #+END_EXAMPLE
   
   打开文件：
   
   #+BEGIN_EXAMPLE python
     >>> with q.open() as f: f.readline()
     ...
     '#! /bin/sh\n'
   #+END_EXAMPLE
   
** 纯路径（Pure Path）
*** 类
    纯路径对象可在不真正操作文件系统情况下处理路径。有下面3个类可选。

    因为没有真正操作文件系统，任何操作系统中都可实例化这些对象。

**** class pathlib. *PurePath* (*pathsegments)
     通用类，根据系统路径特点表示路径（通过调用PurePosixPath或
     PureWindowsPath实例化）。

     #+BEGIN_EXAMPLE python
       >>> PurePath('setup.py')
       PurePosixPath('setup.py')
     #+END_EXAMPLE

     PATHSEGMENTS参数可为单个字符串，也可为多个字符串或path对象：

     #+BEGIN_EXAMPLE python
       >>> PurePath('foo', 'some/path', 'bar')
       PurePosixPath('foo/some/path/bar')
       >>> PurePath(Path('foo'), 'bar')
       PurePosixPath('foo/bar')
     #+END_EXAMPLE

     如果无参数，则表示当前文件夹：

     #+BEGIN_EXAMPLE
       >>> PurePath()
       PurePosixPath('.')
     #+END_EXAMPLE

     如果有多个决定路径，则最后一个被作为起点：

     #+BEGIN_EXAMPLE python
       >>> PurePath('etc', '/usr', 'lib64')
       PurePosixPath('/usr/lib64')
       >>> PurePath('foo', '/etc', '/bar', 'usr', 'lib64')
       PurePosixPath('/bar/usr/lib64')
       >>> PureWindowsPath('c:/Windows', 'd:/bar')
       PureWindowsPath('d:/bar')
     #+END_EXAMPLE

     但在Windows形式中，设置根目录不会忽视驱动盘位置：

     #+BEGIN_EXAMPLE python
       >>> PureWindowsPath('c:/Windows', '/Program Files')
       PureWindowsPath('c:/Program Files')
     #+END_EXAMPLE

     多余的单点和斜杠会被自动去除，双点则不会：

     #+BEGIN_EXAMPLE python
       >>> PurePath('foo//bar')
       PurePosixPath('foo/bar')
       >>> PurePath('foo/./bar')
       PurePosixPath('foo/bar')
       >>> PurePath('foo/../bar')
       PurePosixPath('foo/../bar')
     #+END_EXAMPLE

**** class pathlib. *PurePosixPath* (*pathsegments)
     PurePath子类，表示非-Windows系统文件路径。

     PATHSEGMENTS参数用法同PurePath。

     #+BEGIN_EXAMPLE python
       >>> PurePath('/etc')
       PurePosixPath('/etc')
     #+END_EXAMPLE

**** class pathlib. *PureWindowsPath* (*pathsegments)
     PurePath子类，表示Windows系统文件路径。

     PATHSEGMENTS参数用法同PurePath。

     #+BEGIN_EXAMPLE
       >>> PureWindowsPath('c:/Proram Files')
       PureWindowsPath('c:/Proram Files')
     #+END_EXAMPLE

*** 一般属性
    Path对象为Immutable类型，可哈希。可同字符串一样进行排序和大小比较。
    大小写与对应的系统类别相同，即非-Windows类型区分大小写，Windows类
    型不区分大小写。

    #+BEGIN_EXAMPLE python
      >>> PurePosixPath('foo') == PurePosixPath('FOO')
      False
      >>> PureWindowsPath('foo') == PureWindowsPath('FOO')
      True
      >>> PureWindowsPath('foo') in  {PureWindowsPath('FOO')}
      True
      >>> PureWindowsPath('c:') < PureWindowsPath('d:')
      True
      >>> PureWindowsPath('c:') < PureWindowsPath('D:')
      True
    #+END_EXAMPLE

    不同类型的路径形式绝不相等，且不可比较大小：

    #+BEGIN_EXAMPLE
      >>> PureWindowsPath('foo') == PurePosixPath('foo')
      False
      >>> PureWindowsPath('foo') < PurePosixPath('foo')
      Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
        TypeError: unorderable types: PureWindowsPath() < PurePosixPath()
    #+END_EXAMPLE

*** 操作符
    使用斜杠可创建子路径：

    #+BEGIN_EXAMPLE python
      >>> p = PurePath('/etc')
      >>> p / 'init.d' / 'apache2'
      PurePosixPath('/etc/init.d/apache2')
      >>> q = PurePath('bin')
      >>> '/usr' / q
      PurePosixPath('/usr/bin')
    #+END_EXAMPLE

    将Path对象转换为字符串后，斜杠会根据不同系统类型转换：
    
    #+BEGIN_EXAMPLE python
      >>> p = PurePath('/etc')
      >>> str(p)
      '/etc'
      >>> p = PureWindowsPath('c:/Program Files')
      >>> p
      PureWindowsPath('c:/Program Files')
      >>> str(p)
      'c:\\Program Files'
    #+END_EXAMPLE

    使用bytes转换同理：

    #+BEGIN_EXAMPLE python
      >>> p = PurePath('/etc')
      >>> bytes(p)
      b'/etc'
      >>> p = PureWindowsPath('c:/Program Files')
      >>> bytes(p)
      b'c:\\Program Files'
    #+END_EXAMPLE

    #+BEGIN_QUOTE
    *注意* ：bytes仅在Unix系统上建议使用。
    #+END_QUOTE

*** 获取部分内容
**** PurePath. *parts*
     返回路径每个部分组成的元组：

     #+BEGIN_EXAMPLE python
       >>> p = PurePath('/usr/bin/python3')
       >>> p.parts
       ('/', 'usr', 'bin', 'python3')
       >>> p = PureWindowsPath('c:/Program Files')
       >>> p.parts
       ('c:\\', 'Program Files')
     #+END_EXAMPLE

*** 方法和属性
**** PurePath. *drive*
     如果路径中有驱动设备名，返回该字母：

     #+BEGIN_EXAMPLE python
       >>> PureWindowsPath('c:/Program Files').drive
       'c:'
       >>> PureWindowsPath('Program Files').drive
       ''
       >>> PurePath('c:/Program Files').drive
       ''
       >>> PureWindowsPath('//host/share/foo.txt').drive
       '\\\\host\\share'
     #+END_EXAMPLE

**** PurePath. *root*
     根目录：

     #+BEGIN_EXAMPLE python
       >>> PureWindowsPath('c:/Program Files').root
       '\\'
       >>> PureWindowsPath('c:Program Files').root
       ''
       >>> PurePosixPath('/etc').root
       '/'
       >>> PureWindowsPath('//host/share').root
       '\\'
     #+END_EXAMPLE
**** PurePath. *anchor*
     drive属性+root属性：

     #+BEGIN_EXAMPLE python
       >>> PureWindowsPath('c:/Program Files').anchor
       'c:\\'
       >>> PureWindowsPath('c:Program Files/').anchor
       'c:'
       >>> PurePosixPath('/etc').anchor
       '/'
       >>> PureWindowsPath('//host/share').anchor
       '\\\\host\\share\\'
     #+END_EXAMPLE

**** PurePath. *parents*
     immutable类类型序列，含所有上级路径。

     #+BEGIN_EXAMPLE python
       >>> p=PureWindowsPath('c:/foo/bar/setup.py')
       >>> p.parents
       <PureWindowsPath.parents>
       >>> list(p.parents)
       [PureWindowsPath('c:/foo/bar'), PureWindowsPath('c:/foo'), PureWindowsPath('c:/')]
     #+END_EXAMPLE

**** PurePath. *parent*
     字面上的父级路径。

     #+BEGIN_EXAMPLE python
       >>> p = PurePosixPath('/a/b/c/d')
       >>> p.parent
       PurePosixPath('/a/b/c')
     #+END_EXAMPLE

     如果没有父级，返回本身：

     #+BEGIN_EXAMPLE python
       >>> p = PurePosixPath('/')
       >>> p.parent
       PurePosixPath('/')
       >>> p = PurePosixPath('.')
       >>> p.parent
       PurePosixPath('.')
     #+END_EXAMPLE

     “字面上”的含义是只考虑参数字符串，如：

     #+BEGIN_EXAMPLE
       >>> p = PurePosixPath('foo/..')
       >>> p
       PurePosixPath('foo/..')
       >>> p.parent
       PurePosixPath('foo')
     #+END_EXAMPLE

     如需向上变量文件系统，建议先调用Path.resolve()方法，以确认软连接
     和“..”部分。

**** PurePath. *name*
     返回表示路径最末部分的字符串：

     #+BEGIN_EXAMPLE python
       >>> PurePosixPath('my/lib/setup.py').name
       'setup.py'
       >>> PureWindowsPath('//some/share/setup.py').name
       'setup.py'
       >>> PureWindowsPath('//some/share/').name
       ''
       >>> PureWindowsPath('//some/share').name
       ''
     #+END_EXAMPLE
**** PurePath. *suffix*
     返回字符串表示的文件后缀：

     #+BEGIN_EXAMPLE python
       >>> PurePosixPath('my/lib/setup.py').suffix
       '.py'
       >>> PurePosixPath('my/lib.tar.gz').suffix
       '.gz'
       >>> PurePosixPath('my/lib').suffix
       ''
     #+END_EXAMPLE

**** PurePath. *suffixes*
     所有文件后缀组成的链表：

     #+BEGIN_EXAMPLE python
       >>> PurePosixPath('my/lib/setup.py').suffixes
       ['.py']
       >>> PurePosixPath('my/lib.tar.gz').suffixes
       ['.tar', '.gz']
       >>> PurePosixPath('my/lib').suffixes
       []
     #+END_EXAMPLE

**** PurePath. *stem*
     除后缀外的路径最后部分：

     #+BEGIN_EXAMPLE python
       >>> PurePosixPath('my/lib/setup.py').stem
       'setup'
       >>> PurePosixPath('my/lib.tar.gz').stem
       'lib.tar'
       >>> PurePosixPath('my/lib').stem
       'lib'
     #+END_EXAMPLE
**** PurePath. *as_posix* ()
     返回以斜杠（/）形式表示的路径字符串：

     #+BEGIN_EXAMPLE python
       >>> p = PureWindowsPath('c://Windows')
       >>> str(p)
       'c:\\Windows'
       >>> p.as_posix()
       'c:/Windows'
     #+END_EXAMPLE

**** PurePath. *as_uri* ()
     将路径名转换为文件链接。如果不是绝对路径，抛出ValueError错误：

     #+BEGIN_EXAMPLE python
       >>> PurePosixPath('/etc/passwd').as_uri()
       'file:///etc/passwd'
       >>> PureWindowsPath('c:/Windows').as_uri()
       'file:///c:/Windows'
       >>> PurePosixPath('./passwd').as_uri()
       Traceback (most recent call last):
         File "<stdin>", line 1, in <module>
           File "/usr/lib/python3.5/pathlib.py", line 713, in as_uri
               raise ValueError("relative path can't be expressed as a file URI")
               ValueError: relative path can't be expressed as a file URI
     #+END_EXAMPLE
**** PurePath. *is_absolute* ()
     是否为绝对路径，即同时具备驱动路径（Windows）和根目录：
     
     #+BEGIN_EXAMPLE python
       >>> PurePosixPath('/a/b').is_absolute()
       True
       >>> PurePosixPath('a/b').is_absolute()
       False
       >>> PureWindowsPath('c:/a/b').is_absolute()
       True
       >>> PureWindowsPath('/a/b').is_absolute()
       False
       >>> PureWindowsPath('c:/').is_absolute()
       True
       >>> PureWindowsPath('c:').is_absolute()
       False
       >>> PureWindowsPath('//some/share').is_absolute()
       True
     #+END_EXAMPLE
**** PurePath. *is_reserved* ()
     是否为Windows系统下的保留路径名。对应PurePosixPath始终返回False。

     #+BEGIN_EXAMPLE python
       >>> PureWindowsPath('nul').is_reserved()
       True
       >>> PurePosixPath('nul').is_reserved()
       False
     #+END_EXAMPLE

**** PurePath. *joinpath* (*other)
     将当前路径与*OTHER结合：

     #+BEGIN_EXAMPLE python
       >>> PurePosixPath('/etc').joinpath('passwd')
       PurePosixPath('/etc/passwd')
       >>> PurePosixPath('/etc').joinpath(PurePosixPath('passwd'))
       PurePosixPath('/etc/passwd')
       >>> PurePosixPath('/etc').joinpath('init.d', 'apache2')
       PurePosixPath('/etc/init.d/apache2')
       >>> PureWindowsPath('c:').joinpath('Program Files')
       PureWindowsPath('c:Program Files')
       >>> PureWindowsPath('c:').joinpath('/Program Files')
       PureWindowsPath('c:/Program Files')
     #+END_EXAMPLE

**** PurePath. *match* (pattern)
     是否与glob风格的PATTERN匹配。

     如果PATTERN为相对路径，则即可为相对路径，也可为绝对路径：

     #+BEGIN_EXAMPLE python
       >>> PurePath('a/b.py').match('*.py')
       True
       >>> PurePath('a/b/c.py').match('b/*.py')
       True
       >>> PurePath('a/b/c.py').match('a/*.py')
       False
       >>> PurePath('a/b/c.py').match('a/**/*.py')
       True
     #+END_EXAMPLE

     如果PATTERN为绝对路径，则也需为绝对路径：

     #+BEGIN_EXAMPLE python
       >>> PurePath('/a.py').match('/*.py')
       True
       >>> PurePath('*/a.py').match('/*.py')
       False
     #+END_EXAMPLE

     是否区别大小写会自动识别：

     #+BEGIN_EXAMPLE
       >>> PureWindowsPath('*/a.py').match('*.PY')
       True
     #+END_EXAMPLE

**** PurePath. *relative_to* (*other)
     返回相对OTHER的路径：
     
     #+BEGIN_EXAMPLE python
       >>> p = PurePosixPath('/etc/passwd')
       >>> p.relative_to('/etc')
       PurePosixPath('passwd')
       >>> p.relative_to('/')
       PurePosixPath('etc/passwd')
       >>> p.relative_to('/usr')
       Traceback (most recent call last):
         File "<stdin>", line 1, in <module>
           File "/usr/lib/python3.5/pathlib.py", line 864, in relative_to
               .format(str(self), str(formatted)))
               ValueError: '/etc/passwd' does not start with '/usr'
     #+END_EXAMPLE

**** PurePath. *with_name* (name)
     替换文件名。如果没有文件名抛出ValueError错误：

     #+BEGIN_EXAMPLE python
       >>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')
       >>> p.with_name('setup.py')
       PureWindowsPath('c:/Downloads/setup.py')
       >>> p = PureWindowsPath('c:/Downloads/pathlib')
       >>> p.with_name('setup.py')
       PureWindowsPath('c:/Downloads/setup.py')
       >>> p = PurePosixPath('bar/baz')
       >>> p.with_name('test.txt')
       PurePosixPath('bar/test.txt')
       >>> p = PureWindowsPath('c:/')
       >>> p.with_name('setup.py')
       Traceback (most recent call last):
         File "<stdin>", line 1, in <module>
           File "/usr/lib/python3.5/pathlib.py", line 809, in with_name
               raise ValueError("%r has an empty name" % (self,))
               ValueError: PureWindowsPath('c:/') has an empty name
     #+END_EXAMPLE

**** PurePath. *with_suffix* (suffix)
     替换后缀名，如果没有后缀名，则添加此后缀：

     #+BEGIN_EXAMPLE python
       >>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')
       >>> p.with_suffix('.bz2')
       PureWindowsPath('c:/Downloads/pathlib.tar.bz2')
       >>> p = PureWindowsPath('c:/Downloads/')
       >>> p.with_suffix('.bz2')
       PureWindowsPath('c:/Downloads.bz2')
     #+END_EXAMPLE

** 具体路径（Concrete Path）
   
   具体路径为纯路径的子类，除上面纯路径的属性和方法外，还添加可调用操
   作系统的方法和属性。
   
*** 类
    有下面3个类创建具体路径。
**** class pathlib. *Path* (*pathsegments)
**** class pathlib. *PosixPath* (*pathsegments)
**** class pathlib. *WindowsPath* (*pathsegments)
     用法和参数同纯路径的对应类，只是只能使用系统对应的类创建对象：

     #+BEGIN_EXAMPLE python
       >>> import os
       >>> os.name
       'posix'
       >>> Path('setup.py')
       PosixPath('setup.py')
       >>> PosixPath('setup.py')
       PosixPath('setup.py')
       >>>
       >>> WindowsPath('setup.py')
       Traceback (most recent call last):
         File "<stdin>", line 1, in <module>
           File "/usr/lib/python3.5/pathlib.py", line 972, in __new__
               % (cls.__name__,))
               NotImplementedError: cannot instantiate 'WindowsPath' on your system
     #+END_EXAMPLE

*** 方法
    除纯路径方法外，具体路径实例还提供下面方法，其中大多数在系统调用失
    败时（如路径不存在）可抛出OSError错误。
    
**** classmethod Path. *cwd* ()
     返回表示当前路径的路径对象。

     #+BEGIN_EXAMPLE python
       >>> Path.cwd()
       PosixPath('/home/claudio')
     #+END_EXAMPLE

     与os.getcwd()返回值相同：

     #+BEGIN_EXAMPLE python
       >>> os.getcwd()
       '/home/claudio'
     #+END_EXAMPLE

**** classmethod Path. *home* ()
     返回表示家目录的路径对象。

     #+BEGIN_EXAMPLE python
       >>> Path.home()
       PosixPath('/home/claudio')
     #+END_EXAMPLE

     与os.path.expanduser('~')返回值相同：

     #+BEGIN_EXAMPLE python
       >>> os.path.expanduser('~')
       '/home/claudio'
     #+END_EXAMPLE
     
**** Path. *stat* ()
     与os.stat()返回值相似，返回路径对象的具体信息。

     #+BEGIN_EXAMPLE python
       >>> p = Path('dict.txt')
       >>> p.stat()
       os.stat_result(st_mode=33188, st_ino=23987801, st_dev=2049, st_nlink=1, st_uid=
       1000, st_gid=1000, st_size=472, st_atime=1495200610, st_mtime=1494496832, st_ct
       >>> p = Path('dict.txt')
       >>> p.stat()
       os.stat_result(st_mode=33188, st_ino=23987801, st_dev=2049, st_nlink=1, st_uid=
       1000, st_gid=1000, st_size=472, st_atime=1495200610, st_mtime=1494496832, st_ct
       ime=1494496832)
       >>> p.stat().st_gid
       1000
       >>> p.stat().st_size
       472
     #+END_EXAMPLE

**** Path. *chmod* (mode)
     更改文件模式和权限，类似于os.chmod()。

     #+BEGIN_EXAMPLE python
       >>> p = Path('dict.txt')
       >>> p.stat().st_mode
       33188
       >>> p.chmod(0o444)
       >>> p.stat().st_mode
       33060
     #+END_EXAMPLE

**** Path. *exists* ()
     当前路径是否指向一个存在的文件/文件夹：
     
     #+BEGIN_EXAMPLE python
       >>> Path('.').exists()
       True
       >>> Path('dict.txt').exists()
       True
       >>> Path('/etc').exists()
       True
       >>> Path('不存在').exists()
       False
     #+END_EXAMPLE

     #+BEGIN_QUOTE
     *注意* ：如果路径指向软链接，是否存在根据指向文件/文件夹是否存在
     判断。
     #+END_QUOTE
**** Path. *expanduser* ()
     返回扩展~和~user后的新路径对象。与os.path.expanduer()返回值相同。

     #+BEGIN_EXAMPLE python
       >>> p = PosixPath('~/dict.txt')
       >>> p.expanduser()
       PosixPath('/home/claudio/dict.txt')
     #+END_EXAMPLE

**** Path. *glob* (pattern)
     返回路径中匹配glob形式PATTERN的所有文件路径组成的链表。
     
     #+BEGIN_EXAMPLE python
       >>> sorted(Path('.').glob('*.txt'))
       [PosixPath('.phone-list.txt'), PosixPath('defaultdict.txt'), PosixPath('dict.tx
       t')]
     #+END_EXAMPLE

     可使用“**”匹配“当前文件夹和所有子文件夹”进行递归匹配。（在大型文
     件夹下会很耗时）

**** Path. *group* ()
     返回用户组名称。如果用户组gid不存在于系统数据库中，抛出KeyError错
     误。

     #+BEGIN_EXAMPLE python
       >>> Path('.').group()
       'claudio'
     #+END_EXAMPLE

**** Path. *is_dir* ()
     如果为文件夹，或为指向文件夹的软链接，返回True。

     如果不存在，或为已损坏的软链接，返回False；其他如权限错误会向上抛出。

**** Path. *is_file* ()
     如果为文件，或为指向文件的软链接，返回True。

     如果不存在，或为已损坏的软链接，返回False；其他如权限错误会向上抛
     出。

**** Path. *is_symlink* ()
     如果为软连接返回True，否则返回False。

     如果不存在，返回False；其他如权限错误会向上抛出。

**** Path. *is_socket* ()
     如果为Unix socket（或为指向Unix socket的软连接），则返回True，否
     则返回False。

     如果不存在，或为已损坏的软链接，返回False；其他如权限错误会向上抛
     出。

**** Path. *is_fifo* ()
     如果为FIFO（或为指向FIFO的软连接），则返回True，否则返回False。

     如果不存在，或为已损坏的软链接，返回False；其他如权限错误会向上抛
     出。

**** Path. *is_block_device* ()
     如果为块设备（或为指向块设备的软连接），则返回True，否则返回False。
     
     如果不存在，或为已损坏的软链接，返回False；其他如权限错误会向上抛
     出。
     
**** Path. *is_char_device* ()
     如果为字符设备（或为指向字符设备的软连接），则返回True，否则返回
     False。

     如果不存在，或为已损坏的软链接，返回False；其他如权限错误会向上抛
     出。
     
     #+BEGIN_SRC python :session
       from pathlib import *
       Path('/dev/cdrom').is_block_device()
       Path('/dev/tty1').is_char_device()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - True
     - True
     #+END_SRC

**** Path. *iterdir* ()
     当为文件夹时，返回其中内容组成的路径迭代对象：

     #+BEGIN_EXAMPLE python
       for child in Path('.').resolve().iterdir():
           print(child)
     #+END_EXAMPLE
     
**** Path. *lchmod* (mode)
     类似与Path.chmod()，不过如果为软连接，修改的为软连接的权限模式，
     而不是目标文件的权限模式。

**** Path. *lstat* ()
     类似于Path.lstat()，不过如果为软连接，返回该软链接的文件信息，而
     不是模板文件的信息。

**** Path. *mkdir* (mode=0o777,parents=False,exist_ok=False)
     创建新文件夹。如果指定MODE参数，则系统umask值结果决定文件夹权限。
     如果文件夹已存在，则抛出FileExistsError 错误。

     如果PARENTS参数为True，会自动创建不存在的父文件夹，但这些父文件夹
     的权限模式会使用系统默认值，忽视MODE参数。

     如果PARENTS参数为False（默认值），缺少父文件夹抛出
     FileNotFoundError错误。

     如果EXIST_OK参数为False（默认值），如果文件夹已存在，抛出
     FileExistsError错误。

**** Path. *open* (mode='r',buffering=-1,encoding=None,errors=None,newlines=None)
     与内置函数open类型。

     #+BEGIN_SRC python :session
       from pathlib import Path

       with Path('/etc/hostname').open() as fp:
           fp.readline()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> ... ... 'kali\n'
     #+END_SRC

**** Path. *owner* ()
     返回路径文件的拥有者用户名。如果对应uid不存在于系统数据库，抛出
     KeyError错误。

     #+BEGIN_EXAMPLE python
       >>> Path('dict.txt').owner()
       'claudio'
     #+END_EXAMPLE

**** Path. *read_bytes* ()
     将路径文件内容作为bytes对象返回。

     #+BEGIN_SRC python :session
       from pathlib import Path

       p = Path('~/dict').expanduser()
       p.write_bytes(b'banary-data')
       p.read_bytes()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> 11
     - b'banary-data'
     #+END_SRC

**** Path. *read_text* (encoding=None,errors=None)
     返回路径文件中解码有的内容。
     
     可选参数与open()函数含义相同。
     
     #+BEGIN_SRC python :session
       from pathlib import Path
       p = Path('~/dict.txt').expanduser()
       p.write_text('文本文件内容')
       p.read_bytes()
       p.read_text()
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> 6
     - b'\xe6\x96\x87\xe6\x9c\xac\xe6\x96\x87\xe4\xbb\xb6\xe5\x86\x85\xe5\xae\xb9'
     - '文本文件内容'
     #+END_SRC
     
**** Path. *rename* (target)
     将路径文件/文件夹重命名为TARGET。在Unix系统下，如果TARGET存在且为
     文件，并有权限，会无条件重命名。

     TARGET可为字符串，也可为另一个路径对象。

     #+BEGIN_SRC python :session
       from pathlib import Path

       p = Path('~/foo.txt').expanduser()
       target = Path('~/bar.txt').expanduser()
       p.write_text('1111')
       p.rename(target)
       p.exists()
       target.read_text()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> >>> 4
     - >>> False
     - '1111'
     #+END_SRC

**** Path. *replace* (target)
     重命名当前文件/文件夹路径。如果target指向已存在文件/文件夹，无条
     件替换。

     *？* ：与renmae有何区别？？？

     #+BEGIN_SRC python :session
       from pathlib import Path

       p = Path('~/foo.txt').expanduser()
       target = Path('~/bar.txt').expanduser()
       p.write_text('1111')
       p.replace(target)
       p.exists()
       target.read_text()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> >>> 4
     - >>> False
     - '1111'
     #+END_SRC
     
**** Path. *resolve* ()
     将路径转换为决定路径，如果为软连接返回指向目标文件/文件夹的路径。

     如果路径不存在，抛出FileNotFoundError错误；如果出现无限循环，抛出
     RunTimeError错误。

     #+BEGIN_SRC python :session
       from pathlib import Path

       p = Path('/dev/cdrom/')
       p.resolve()

       p = Path('/dev/cdrom/../cdrom')
       p.resolve()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> PosixPath('/dev/sr0')
     - >>> >>> PosixPath('/dev/sr0')
     #+END_SRC

**** Path. *rglob* (pattern)
     递归版本的path.glob()，相当于在前面添加了“**/”。

     #+BEGIN_EXAMPLE python
       sorted(Path().rglob('*.py'))
     #+END_EXAMPLE

**** Path. *rmdir* ()
     删除路径文件夹。文件夹必须为空文件夹。

**** Path. *samefile* (other_path)
     是否与OTHER_PATH为同一文件。OTHER_PATH可为字符串，也可为另一个路
     径对象。

     两个路径需同时存在。

**** Path. *symlink_to* (target,target_is_directory=False)
     创建软连接。将当前路径作为软连接指向TARGET。

     在Windows中，TARGET_IS_DIRECTORY需为True（默认为False），在POSIX
     中则会忽视此参数。

     #+BEGIN_EXAMPLE python
       In [7]: ls
       test.txt

       In [8]: p = Path('mylink')
     
       In [9]: p.symlink_to('test.txt')

       In [10]: p.resolve()
       Out[10]: PosixPath('/home/claudio/test/test.txt')
     #+END_EXAMPLE

**** Path. *touch* (mode=0o666,exist_ok=True)
     根据路径新建文件。如果有MODE参数，与系统umask值结合决定文件权限和
     模式。如果文件已存在，且EXIST_OK参数不为True，抛出FileExistsError
     错误。
     
**** Path. *unlink* ()
     删除路径表示的文件或软连接。如果为文件夹，使用Path.rmdir()。

**** Path. *write_bytes* (data)
     以二进制模式打开文件，写入DATA，最后关闭。

     #+BEGIN_SRC python :session
       from pathlib import Path
       p = Path('not-exists-file')
       p.write_bytes(b'123')
       p.read_bytes()
       p.unlink()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> 3
     - b'123'
     #+END_SRC

     如果文件已经存在，重写；如果不存在，则创建。

**** Path. *write_text* (data,encoding=None,errors=None)
     以文本模式打开文件，写入DATA，最后关闭文件。

     #+BEGIN_SRC python :session
       from pathlib import Path
       p = Path('not-exists-file')
       p.write_text('123')
       p.read_text()
       p.unlink()
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> 3
     - '123'
     #+END_SRC

     如果文件已经存在，重写；如果不存在，则创建。
* os.path - 常用路径名操作
** 模块函数
   此模块提供操作路径名的函数。如需读写文件，使用内置函数open()，操作
   文件系统使用os模块。函数的PATH参数可为字符串，也可为bytes对象。应用
   中首选Unicode形式字符串（默认）。但在Unix系统中，一些文件名不能用字
   符串表示，此时可使用bytes对象；在Windows系统中，bytes对象不能表示所
   有文件名，所以需使用字符串形式。
   
   不同于shell，Python不会自动扩张路径，如需扩张，可使用expanduser()和
   expandvars()函数，也可参考glob模块。
   
   #+BEGIN_QUOTE
   pathlib模块提供高阶的路径对象。
   #+END_QUOTE
   
   #+BEGIN_QUOTE
   *注意* ：此模块中的所有函数只能同时使用字符串和bytes对象中的一种作
   为参数，返回值与参数形式相同。
   #+END_QUOTE
   
   #+BEGIN_QUOTE
   *注意* ：不同的系统路径名规范不同，但os.path始终保存与当前操作系统
   兼容。如需在本地使用不同规范的路径模块，可参考（都有相同接口）：
   
   - posixpath： Unix
   - ntpath：Windows
   - macpath：老式MocOS
   #+END_QUOTE
   
*** os.path. *abspath* (path)
    将将PATH标准化为绝对路径。在绝大多数系统中，等价于
    normpath(join(os.getcwd(), path))。

    #+BEGIN_SRC python :session
      from os.path import abspath
      abspath('README.org')
      abspath('not-exists-file')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - '/home/claudio/Desktop/Python/python-standard-lib-notes/README.org'
    - '/home/claudio/Desktop/Python/python-standard-lib-notes/not-exists-file'
    #+END_SRC

*** os.path. *basename* (path)
    返回PATH的basename，与os.path.split()结果中的第二个元素值相同。

    *注意* ：不同于Unix的basename命令，如'/foo/bar/'，该命令的返回结果
    为'bar'，而此函数的返回值为空。

    #+BEGIN_SRC python :session
      from os.path import basename
      name = '~/data/test.db'
      print(basename('~/qwd/'))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>>
    #+END_SRC

*** os.path. *commonpath* (path)
    返回PATHS中最长的相同子路径。PATHS只能同时为绝对路径和相对路径中的
    一种，且不能为空，否则抛出ValueError错误。

    不同于commonprefix，此函数的返回值为有效路径。
    
    #+BEGIN_SRC python :session
      from os.path import commonpath
      commonpath(['/usr/lib', '/usr/local/lib'])
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - '/usr'
    #+END_SRC

    兼容：Unix、Windows

*** os.path. *commonprefix* (list)
    逐个字符比较，获取最长相同路径字符串，如果LIST为空，返回空。
    
    不同于commonpath函数，此函数返回值可能不是有效路径。

    #+BEGIN_SRC python :session
      from os.path import commonprefix
      commonprefix(['/usr/lib', '/usr/local/lib'])
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - '/usr/l'
    #+END_SRC

*** os.path. *dirname* (path)
    返回路径的文件夹，与os.path.split()返回值的第一个参数相同。

*** os.path. *exits* (path)
    如果PATH表示的路径为存在的文件/文件夹，或表示open file descriptor
    的整数，返回True。如果为被损坏的软连接，返回False。

    在一些系统中，如果没有足够权限执行os.stat()，即时文件存在，也会返
    回False。

    #+BEGIN_SRC python :session
      import os.path
      os.path.exists('~')
      os.path.exists(os.path.expanduser('~'))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - False
    - True
    #+END_SRC

*** os.path. *lexists* (path)
    如果系统上不能实现os.lstat()，等价于os.path.exists()。即即时时损坏
    的软连接也会返回True。

*** os.path. *expanduser* (path)
    在Unix和Windows系统上，返回最前面将~和~user替换为家目录后的结果。
    如果没有~符号，原样返回。

    在Unix系统中，如果设置了环境变量HOME，~使用该变量值代替；否则使用
    pwd模块获取当前用户的家目录代替。如果为，~usr会直接在password文件
    中查询。

    在Windows系统中，如果有设置，使用HOME和USERPROFILE；否则结合
    HOMEPATH和HOMEDRIVE。 An initial ~user is handled by stripping the
    last directory component from the created user path derived above.

    #+BEGIN_SRC python :session
      from os.path import expanduser
      expanduser('~')
      expanduser('~root')
      expanduser('~notexists')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - '/home/claudio'
    - '/root'
    - '~notexists'
    #+END_SRC

*** os.path. *expandvars* (path)
    将PATH中$name和${name}显示使用环境变量替换。如果不存在该环境变量，
    则保存不变。

    在Windows中，还可使用%name%形式。

    #+BEGIN_SRC python :session
      from os.path import expandvars

      expandvars('${PYTHONPATH}')
      expandvars('${pythonpath}')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> '/home/claudio/python:'
    - '${pythonpath}'
    #+END_SRC

*** os.path. *getatime* (path)
    
    返回PATH上次被访问时间。
    
    结果为自“January 1, 1970, 00:00:00 (UTC).” 开始的秒数。如果不存在
    或无访问权限，抛出OSError错误。
    
    如果os.stat_float_times()的返回结果为True，结果为浮点数。
    
    #+BEGIN_SRC python :session
      from os.path import getatime
      import pathlib
      path = 'files/emma.txt'

      print('起点时间：', getatime(path))
      with open(path) as fp:
          fp.readline()

      print('读取内容后：', getatime(path))

      pathlib.Path(path).chmod(0o666)
      print('修改权限后：', getatime(path))

      with open(path, 'a+') as fp:
          fp.write('10')

      print('写入内容后：', getatime(path))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> >>> 起点时间： 1495265725.0639217
    - ... ... '101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
    - 读取内容后： 1495265935.3199155
    - >>> >>> 修改权限后： 1495265935.3199155
    - >>> ... ... 2
    - 写入内容后： 1495265935.3199155
    #+END_SRC

*** os.path. *getmtime* (path)
    返回PATH上次被修改的时间。
    
    结果为自“January 1, 1970, 00:00:00 (UTC).” 开始的秒数。如果不存在
    或无访问权限，抛出OSError错误。
    
    如果os.stat_float_times()的返回结果为True，结果为浮点数。
    
    #+BEGIN_SRC python :session
      from os.path import getmtime
      import pathlib
      path = 'files/emma.txt'

      print('起点时间：', getmtime(path))
      with open(path) as fp:
          fp.readline()

      print('读取内容后：', getmtime(path))

      pathlib.Path(path).chmod(0o666)
      print('修改权限后：', getmtime(path))

      with open(path, 'a+') as fp:
          fp.write('10')

      print('写入内容后：', getmtime(path))
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> >>> 起点时间： 1495266106.8199103
    - ... ... ''
    - 读取内容后： 1495266106.8199103
    - >>> >>> 修改权限后： 1495266106.8199103
    - >>> ... ... 2
    - 写入内容后： 1495266124.2679098
    #+END_SRC
    
*** os.path. *getctime* (path)
    在Unix系统中，为PATH的metadata上次被修改的时间；在Windows中，为
    PATH创建时间。
    
    结果为自“January 1, 1970, 00:00:00 (UTC).” 开始的秒数。如果不存在
    或无访问权限，抛出OSError错误。
    
    如果os.stat_float_times()的返回结果为True，结果为浮点数。
    
    #+BEGIN_SRC python :session
      from os.path import getctime
      import pathlib
      path = 'files/emma.txt'

      print('起点时间：', getctime(path))
      with open(path) as fp:
          fp.readline()

      print('读取内容后：', getctime(path))

      pathlib.Path(path).chmod(0o666)
      print('修改权限后：', getctime(path))

      with open(path, 'a+') as fp:
          fp.write('10')

      print('写入内容后：', getctime(path))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> >>> 起点时间： 1495265993.2799137
    - ... ... '1010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
    - 读取内容后： 1495265993.2799137
    - >>> >>> 修改权限后： 1495265995.1919136
    - >>> ... ... 2
    - 写入内容后： 1495265995.2199137
    #+END_SRC

*** os.path. *getsize* (path)
    返回以byte数表示的文件大小。如果不存在或无访问权限，抛出OSError错
    误。

    #+BEGIN_SRC python :session
      from os.path import getsize
      getsize('files/emma.txt')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 2
    #+END_SRC

*** os.path. *isabs* (path)
    是否为决定路径。即在Unix系统中，以斜杠开头；在Windows中，去除驱动
    字符（如果有）后以反斜杠开头。

*** os.path. *isfile* (path)
    是否为存在的普通文件。会“跟随”软连接，所以如果为指向普通文件的软链
    接也会返回True。

    #+BEGIN_SRC python :session
      from os.path import isfile
      isfile('/etc/localtime')
      isfile('/dev/cdrom')
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - True
    - False
    #+END_SRC

*** os.path. *isdir* (path)
    是否为存在的文件夹。会“跟随”软连接，所有为指向存在文件夹的软连接也
    会返回True。

    #+BEGIN_SRC python :session
      from os.path import isdir
      isdir('/etc/localtime')
      isdir('files')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - False
    - True
    #+END_SRC

*** os.path. *islink* (path)
    是否为软连接。在不支持软连接的运行环境中，始终返回False。

    #+BEGIN_SRC python :session
      from os.path import islink
      islink('/etc/localtime')
      islink('/dev/cdrom')
      # islink('files/emma.txt')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - True
    - True
    #+END_SRC

*** os.path. *ismount* (path)
    是否为挂载点：当前文件系统中，不同文件系统的的位置。在POSIX中，
    On POSIX, the function checks whether path‘s parent, path/.., is
    on a different device than path, or whether path/.. and path point
    to the same i-node on the same device — this should detect mount
    points for all Unix and POSIX variants. On Windows, a drive letter
    root and a share UNC are always mount points, and for any other
    path GetVolumePathName is called to see if it is different from
    the input path.
    
    #+BEGIN_SRC python :session
      from os.path import ismount
      ismount('/run/user/1000')
      ismount('files/emma.txt')
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - True
    - False
    #+END_SRC

*** os.path. *join* (path, *paths)
    拼接路径。将PATH和*PATH使用os.sep拼接。自动去除多余的斜杠和空字符
    串。当最后一个元素后有斜杠，或为空时，返回结果才以斜杠接受。如果有
    一个元素第一个字符为斜杠（即绝对路径），前面的内容被忽略，从当前开
    始拼接。

    Windows：（待续）

    #+BEGIN_SRC python :session
      import os.path

      os.path.join('~')
      os.path.join('/', 'etc')
      os.path.join('/', 'etc/')
      os.path.join('files', 'emma.txt')
      os.path.join('files/', 'emma.txt', '')
      os.path.join('files/', '', 'emma.txt', '')
      os.path.join('files/', '', '/emma.txt', '')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> '~'
    - '/etc'
    - '/etc/'
    - 'files/emma.txt/'
    - 'files/emma.txt/'
    - 'files/emma.txt/'
    - '/emma.txt/'
    #+END_SRC

*** os.path. *normcase* (path)
    在不忽略大小写的系统上，原样返回；在忽略大小写的系统上，全部转换为
    小写。在Windows中，将斜杠转换为反斜杠。如果PATH不为字符串或bytes对
    象，抛出TypeError错误。

*** os.path. *normpath* (path)
    去除多余相对路径原点和斜杠。在Windows中，会将斜杠转换为反斜杠。

    *注意* ：如果PATH为软链接，可能会改变其含义。

    #+BEGIN_SRC python :session
      from os.path import normpath
      normpath('A//B')
      normpath('A/B/')
      normpath('A/./B')
      normpath('A/foo/../B/')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 'A/B'
    - 'A/B'
    - 'A/B'
    - 'A/B'
    #+END_SRC

*** os.path. *realpath* (path)
    将PATH转换为标准路径，如果为存在的软连接，返回指向目标。

    #+BEGIN_SRC python :session
      from os.path import realpath
      realpath('/dev/cdrom')
      realpath('.')
      realpath('~')
      realpath('not-exists')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - '/dev/sr0'
    - '/home/claudio/Desktop/Python/python-standard-lib-notes'
    - '/home/claudio/Desktop/Python/python-standard-lib-notes/~'
    - '/home/claudio/Desktop/Python/python-standard-lib-notes/not-exists'
    #+END_SRC

*** os.path. *relpath* (path,start=os.curdir)
    返回PATH相对于START（默认值为当前文件夹）的路径。

    仅仅是路径计算：不会访问文件系统判断PATH或START是否真实存在。

    #+BEGIN_SRC python :session
      from os.path import relpath
      relpath('/home')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - '../../../../../hom'
    #+END_SRC
*** os.path. *samefile* (path1,path2)
    如果path1和path2指向同一文件/文件夹，返回True。判断依据为“设备编
    号”（device number）和i-node值。如果对其中任意一个调用os.stat()失
    败，则抛出错误。

    #+BEGIN_SRC python :session
      from os.path import samefile
      samefile('files/emma.txt', 'files/../files/emma.txt')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - True
    #+END_SRC

    兼容：Unix，Windows

*** os.path. *sameopenfile* (fp1,fp2)？？？
    如果FP1和FP2“文件描述符”（file descriptor）指向同一文件，返回True。

    兼容：Unix，Windows
*** os.path. *samestat* (stat1,stat2)
    如果元组STAT1和STAT2指向同一文件，返回True。STAT1和STAT2可为
    os.fstat()、os.lstat()、os.stat()的返回结果。
    
    samefile()和sameopenfile()内部就是使用此函数进行的比较。
    
    兼容：Unix，Windows
    
*** os.path. *split* (path)
    将路径PATH分割为(head, tail)形式。其中tail为路径最后一部分，head为
    前面所有内容。

    tail部分不会有任何斜杠，如果PATH以斜杠结束，则tail为空；如果PATH中
    无任何斜杠，则head为空。

    除非为根目录，head中最后一个斜杠被自动去除。

    所有情况下，os.path.join(head, trail)的结果都与PATH含义一样，可能
    在字符串上有区别。

    #+BEGIN_SRC python :session
      import os.path

      os.path.split('~/Desktop/Python/test.py')
      os.path.split('~/Desktop/Python/')
      os.path.split('test.py')
      os.path.split('/')
      os.path.split('')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> ('~/Desktop/Python', 'test.py')
    - ('~/Desktop/Python', '')
    - ('', 'test.py')
    - ('/', '')
    - ('', '')
    #+END_SRC

*** os.path. *splitdrive* (path)
    将PATH分割为(drive, tail)，其中drive为挂载点或空字符串。在不支持驱
    动路径名的系统上，drive始终为空。所有情况下，drive+tail的结果都为
    PATH。

    如果PATH中有驱动名，则drive为冒号和之前的所有内容，如
    splitdrive('c:/dir')的结果为('c:', '/dir')。

    如果PATH为UNC路径，drive会包含主机名和共享文件夹名，如
    splitdrive('//host/share/dir')的结果为('//host/share', '/dir')。

*** os.path. *splitext* (path)
    将PATH分割为(root, ext)，且root+ext==PATH。ext为空或最多包含一个点
    的字符串。basename中最前面的点会被忽视。

    #+BEGIN_SRC python :session
      from os.path import splitext
      splitext('.emacs')
      splitext('.emacs/custom.el')
      splitext('emacs/custom.el')
      splitext('emacs/custom..el')
      splitext('emacs/custom')
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - ('.emacs', '')
    - ('.emacs/custom', '.el')
    - ('emacs/custom', '.el')
    - ('emacs/custom.', '.el')
    - ('emacs/custom', '')
    #+END_SRC

*** os.path. *splitunc* (path)
    *注意* ：自从3.1版本就废除，使用splitdrive。
*** os.path. *supports_unicode_filenames*
    是否支持任意Unicode字符串作为文件名。

    #+BEGIN_SRC python :session
      from os.path import supports_unicode_filenames
      print(supports_unicode_filenames)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - False
    #+END_SRC

* fileinput - 迭代多个输入流中的行
** fileinput. *input* (files=None,inplace=False,backup='',bufsize=0,mode='r',openhook=none)
   创建一个FileInput类的实例。此实例被用作此模块中所有函数的全局状态，
   and is also returned to use during iteration。参数会全部传递给
   FileInput类的构造器。
   
   可使用with语句上下文管理器，即时处理文件时抛出错误，with语句退出时
   也会自动关闭文件：
   
   #+BEGIN_EXAMPLE python
     with fileinput.input(files=('spam.txt', 'eggs.txt')) as f:
          for line in f:
              process(line)
   #+END_EXAMPLE
   
   #+BEGIN_SRC python :session
      import fileinput
      with fileinput.input(files=('files/a.txt', 'files/b.txt')) as f:
          for line in f:
              print(line)
   #+END_SRC
   
   #+RESULTS:
   #+BEGIN_SRC org
   - ... ... ... 1
   - 2
   - 3
   - a
   - b
   - c
   #+END_SRC
   
   下面为使用fileinput.input()创建全局状态的函数。如果还没有调用
   fileinput.input()，抛出RuntimeError错误。
   
   #+BEGIN_SRC python :session
     import fileinput
     fileinput.filename()
   #+END_SRC
   
   #+RESULTS:
   #+BEGIN_SRC org
   - Traceback (most recent call last):
   -   File "<stdin>", line 1, in <module>
   -   File "/usr/lib/python3.5/fileinput.py", line 127, in filename
   -     raise RuntimeError("no active input()")
   - RuntimeError: no active input()
   #+END_SRC
   
*** fileinput. *filename* ()
    返回当前处理的文件名。如果还没开始读取，返回None。
    
    #+BEGIN_SRC python :session
      import fileinput
      with fileinput.input(files=('files/a.txt', 'files/b.txt')) as f:
          print(fileinput.filename())
          for line in f:
              print(fileinput.filename() + ' -> ' + line)
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - ... ... ... ... None
    - files/a.txt -> 1
    - files/a.txt -> 2
    - files/a.txt -> 3
    - files/b.txt -> a
    - files/b.txt -> b
    - files/b.txt -> c
    #+END_SRC

*** fileinput. *fileno* ()
    返回整数表示的当前文件“文件描述符”。如果没有文件被打开，返回-1。

    #+BEGIN_QUOTE
    文件描述符：第一次打开为3，以后每次打开增加1。？？？
    #+END_QUOTE

    #+BEGIN_SRC python :session
      import fileinput
      files = ('files/a.txt', 'files/b.txt')
      with fileinput.input(files=files) as f:
          print(fileinput.fileno())
          for line in f:
              print(fileinput.fileno(), ' -> ', line)
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> ... ... ... ... -1
    - 3  ->  1
    - 3  ->  2
    - 3  ->  3
    - 3  ->  a
    - 3  ->  b
    - 3  ->  c
    #+END_SRC

*** fileinput. *lineno* ()
    返回当前所有文件总共的处理函数。如果还没开始读取文件，返回0；如果
    已处理完所有行，返回最后一行的行数。

    #+BEGIN_SRC python :session
      import fileinput
      files = ('files/a.txt', 'files/b.txt')
      with fileinput.input(files=files) as f:
          print(fileinput.lineno())
          for line in f:
              print(fileinput.lineno(), ' -> ', line)
          print(fileinput.lineno())
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> ... ... ... ... ... 0
    - 1  ->  1
    - 2  ->  2
    - 3  ->  3
    - 4  ->  a
    - 5  ->  b
    - 6  ->  c
    - 6
    #+END_SRC

*** fileinput. *filelineno* ()
    返回当前文件所在行数。如果还没读取任何行，返回0；如果已读取最后一
    个文件的最后一行，返回最后一个文件最后一行的行数。

    #+BEGIN_SRC python :session
      import fileinput
      files = ('files/a.txt', 'files/b.txt')
      with fileinput.input(files=files) as f:
          print(fileinput.filelineno())
          for line in f:
              print(fileinput.filelineno(), ' -> ', line)
          print(fileinput.filelineno())
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> ... ... ... ... ... 0
    - 1  ->  1
    - 2  ->  2
    - 3  ->  3
    - 1  ->  a
    - 2  ->  b
    - 3  ->  c
    - 3
    #+END_SRC

*** fileinput. *isfirstline* ()
    如果时当前文件的第一行返回True，否则返回False。

    #+BEGIN_SRC python :session
      import fileinput
      files = ('files/a.txt', 'files/b.txt')
      with fileinput.input(files=files) as f:
          print(fileinput.isfirstline())
          for line in f:
              print('YES' if fileinput.isfirstline() else 'NO', ' -> ', line)
          print(fileinput.isfirstline())
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> ... ... ... ... ... False
    - YES  ->  1
    - NO  ->  2
    - NO  ->  3
    - YES  ->  a
    - NO  ->  b
    - NO  ->  c
    - False
    #+END_SRC
    
*** fileinput. *isstdin* ()
    如果上一行读取自sys.stdin返回True。

*** fileinput. *nextfile* ()
    关闭当前处理文件，读取下一个文件（如果有）。总共读取的函数lineno()
    根据实际读取行数递增。直到下一个文件的第一行读取，filename()不会变。

    在第一个文件的第一行读取前，以及在最后一个文件的最后一行读取后，此
    函数没有任何效果。

    #+BEGIN_SRC python :session
      import fileinput
      files = ('files/a.txt', 'files/b.txt')
      with fileinput.input(files=files) as f:
          print(f.readline())
          print(fileinput.fileno())
          print('共读取行数：', fileinput.lineno())
          fileinput.nextfile()
          print(f.readline())
          print('共读取行数：', fileinput.lineno())
          print(fileinput.filename())
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> ... ... ... ... ... ... ... ... 1
    - 3
    - 共读取行数： 1
    - a
    - 共读取行数： 2
    - files/b.txt
    #+END_SRC

*** fileinput. *close* ()
    关闭文件序列。
** class fileinput. *FileInput* *input* (files=None,inplace=False,backup='',bufsize=0,mode='r',openhook=none)
** 钩子函数
*** fileinput. *hook_compressed* (filename, mode)
*** fileinput. *hook_encoded* (encoding)
* stat - 转换系统stat命令结果
* filcmp - 文件和文件夹对比
* tempfile - 创建临时文件/文件夹
* glob - Unix风格路径扩张
* fnmatch - Unix文件名模式匹配
* linecache - 随机操作文本行
* shutil - 高阶文件操作
* macpath - “Mac OS 9”路径处理函数 （待续）
