# Author: Claudio <3261958605@qq.com>
# Created: 2017-05-02 15:22:30
# Commentary:
#+TITLE: 数据类型

除Python内置的数据类型：dict、list、set、frozenset、tuple、str和
bytes/bytearray外（其中str类型用于存储Unicode字符串，bytes用于存储二进
制数据。）。本章介绍一些特殊的数据类型，如dates和times，类型固定的数组，
队列和集合。

* datetime - 基本日期和时间类型

** 模块常量
*** datetime. *MINYEAR*
*** datetime. *MAXYEAR*
    date和datetime对象中允许的最大/小年数。

    #+BEGIN_SRC python :session
      import datetime
      datetime.MINYEAR
      datetime.MAXYEAR
    #+END_SRC

    #+RESULTS:
    :
    : >>> 1
    : 9999

** 可用类型
** timedelta对象
** date对象
** datetime对象
** time对象
** tzinfo对象
** timezone 对象
** strftime()和strptime()
* calendar - 日历相关函数
* collections - 容器类型
  此模块对内置类型dict、list、set和tuple实现了容器包装。
  
  | namedtuple  | 命名式元组工厂函数                     |
  | deque       | 类链表容器，可快速在两端添加和删除元素 |
  | ChainMap    | 类字典类，利用多个映射创建单个view     |
  | Counter     | 字典子类，计数可哈希对象               |
  | OrderedDict | 字典子类，可记录添加元素的顺序         |
  | defaultdict | 字典子类，调用工厂函数添加消失值       |
  | UserDict    | 字典对象包装器，方便创建字典子类       |
  | UserList    | 链表对象包装器，方便创建链表子类       |
  | UserString  | 字符串对象包装器，方便创建字符串子类   |
  
** ChainMap对象
   将多个映射对象结合，作为单个对象。比创建新字典对象，然后使用字典的
   update()方法快。
   
*** class collections. *ChainMap* (*maps)
    ChainMap将多个字典或映射对象集合到一起，创建一个新的，可更新的view。
    如果没有MAP参数，则将空字典传递给此构建函数。
    
    #+BEGIN_SRC python :session
      from collections import ChainMap
      books = {'A': 10, 'B': 11}
      persons = {'Mike': 23, 'Lily': 27}
      mix = ChainMap(books, persons)
      print(mix)
      ChainMap()
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> >>> ChainMap({'A': 10, 'B': 11}, {'Lily': 27, 'Mike': 23})
    - ChainMap({})
    #+END_SRC
    
    ChainMap内部用链表集中各个映射对象，各元素映射对象可使用MAP的属性
    获取或跟新。此外无其他任何状态：
    
    #+BEGIN_SRC python :session
      mix['Lily'] = 100
      print(mix)
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - ChainMap({'A': 10, 'Lily': 100, 'B': 11}, {'Lily': 27, 'Mike': 23})
    #+END_SRC
    
    除查找外，重新赋值、跟新和删除都只在第一个映射对象中进行：
    
    #+BEGIN_SRC python :session
      mix['Lily']
      mix['A']
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - 100
    - 10
    #+END_SRC
    
    ChainMap中的元素实际上是原映射的索引，即改变原来映射，其中的元素也
    随之改变：
    
    #+BEGIN_SRC python :session
      del persons['Mike']
      print(persons)
      print(mix)
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - {'Lily': 27}
    - ChainMap({'A': 10, 'Lily': 100, 'B': 11}, {'Lily': 27})
    #+END_SRC
    
    除字典常用方法外，ChainMap还支持下面属性和方法：
    
**** maps
     返回可更新的字典链表。修改其中的元素即可修改ChainMap本身，也可修
     改原来的字典对象。
     
     #+BEGIN_SRC python :session
       mix.maps
       mix.maps[0]['A'] = -1
       print(mix)
       print(books)
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - [{'A': -1, 'Lily': 100, 'B': 11}, {'Lily': 27}]
     - >>> ChainMap({'A': -1, 'Lily': 100, 'B': 11}, {'Lily': 27})
     - {'A': -1, 'Lily': 100, 'B': 11}
     #+END_SRC

**** new_child(m=None)
     返回新的ChainMap对象，其中第一个元素为M，后面为当前对象的所有maps。
     如果M参数缺省，则默认为空字典。此方法可用来更新第一个字典，而不影
     响所有原来的字典。

     下面两种方式等级：

     #+BEGIN_SRC python :eval never
       d.new_child()
       ChainMap({}, *d.maps)
     #+END_SRC
     
     更新除第一个以外的字典会影响原来ChainMap，以及字典对象：

     #+BEGIN_SRC python :session
       submix = mix.new_child()
       print('submix: ', submix)
       print('mix: ', mix)
       print('books: ', books)
       submix.maps[1]['A'] = -100
       print('submix after change: ', submix)
       print('mix after change: ', mix)
       print('books after change: ', books)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - submix:  ChainMap({}, {'A': -1, 'Lily': 100, 'B': 11}, {'Lily': 27})
     - mix:  ChainMap({'A': -1, 'Lily': 100, 'B': 11}, {'Lily': 27})
     - books:  {'A': -1, 'Lily': 100, 'B': 11}
     - >>> submix after change:  ChainMap({}, {'A': -100, 'Lily': 100, 'B': 11}, {'Lily': 27})
     - mix after change:  ChainMap({'A': -100, 'Lily': 100, 'B': 11}, {'Lily': 27})
     - books after change:  {'A': -100, 'Lily': 100, 'B': 11}
     #+END_SRC

**** parents
     返回新ChainMap对象，元素含除第一个字典外的所有元素。可用于在搜索
     时跳过第一个字典。
     
     #+BEGIN_SRC python :session
       mix.parents
       submix.parents
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - ChainMap({'Lily': 27})
     - ChainMap({'A': -100, 'Lily': 100, 'B': 11}, {'Lily': 27})
     #+END_SRC
     
*** ChainMap应用举例
    
** Counter对象
** deque对象
*** deque应用举例
** defaultdict对象
*** defaultdict应用举例
** namedtuple() - 元组工厂函数
** OrderedDict对象
*** OrderedDict应用举例
** UserDict对象
** UserList对象
** UserString对象

* collections.abc - 容器类型抽象基础类（Abstract Base Classes for Containers）
* heapq - 堆排序算法
* bisect - 数组二叉树搜索算法
* array - 高效数字数组
  此模块为精简表示基本数据类型的数组：字符型、整型和浮点型。array类型
  与链表类型十分相似，只是存储其中的数据类型有约束。

  *注意* ：适用于链表的方法也适用于array。

  类型名以单个字母表示（与struct模块中，相同的格式字符含义相同；但最小值
  与struct中标准值不同）：

  | 类型字符串 | 对应C类型          | Python类型        | 最小byte数 | 注意点 |
  |------------+--------------------+-------------------+------------+--------|
  | b          | signed char        | int               |          1 |        |
  | B          | unsigned char      | int               |          1 |        |
  | u          | Py_UNICODE         | Unicode character |          2 | (1)    |
  | h          | short              | int               |          2 |        |
  | H          | unsigned short     | int               |          2 |        |
  | i          | int                | int               |          2 |        |
  | I          | unsigned int       | int               |          2 |        |
  | l          | long               | int               |          4 |        |
  | L          | unsigned long      | int               |          4 |        |
  | q          | long long          | int               |          8 | (2)    |
  | Q          | unsigned long long | int               |          8 | (2)    |
  | f          | float              | float             |          4 |        |
  | d          | double             | float             |          8 |        |

  注意点：

  1. 'u'类型代码将废除，不建议使用。
  2. 'q'和'Q'类型代码仅限的有效情况为：编译Python的C编译器支持C语言的
     “long long”类型，或Windows系统，或__int64。？？？

  各类型代码表示的真实值取值范围取决于C实现，可使用itemsize属性获取。

** 此模块定义的类型有
*** class array. *array* (typecode[,initializer])
    INITIALIZER参数可选，须为“类bytes对象”，或类型合适的iterable对象。

    如果数组元素类型与第一个参数（类型参数）不一致，则报错：

    #+BEGIN_SRC python :session
      import array
      a = array.array('l')
      b = array.array('i', [123, 456, 789])
      print(a)
      print(b)

      c = array.array('i', [1.2])
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> array('l')
    : array('i', [123, 456, 789])
    : >>> Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : TypeError: integer argument expected, got float

    INITIALIZER为“类bytes”对象：

    #+BEGIN_SRC python :session
      from array import array

      # bytes
      a = array('b', b'abc')
      print(a)

      # bytearray
      a = array('b', bytearray(b'abc'))
      print(a)

      # array.array
      a = array('b', a)
      print(a)

      # memoryview
    #+END_SRC
    
    #+RESULTS:
    :
    : >>> ... >>> array('b', [97, 98, 99])
    : >>> ... >>> array('b', [97, 98, 99])
    : >>> ... >>> array('b', [97, 98, 99])

    为类型合适的iterable对象：

    #+BEGIN_SRC python :session
      from array import array

      # range
      a = array('i', range(3))
      print(a)

      # 链表
      a = array('i', [1, 2, 3])
      print(a)

      # 元组
      a = array('i', (1, 2, 3))
      print(a)

      # set
      a = array('i', {1, 2, 3})
      print(a)

      # 字典
      a = array('i', {1: 'a', 2: 'b', 3: 'c'})
      print(a)

      # 字符串
      a = array('u', 'abc')
      print(a)
    #+END_SRC

    #+RESULTS:
    :
    : >>> ... >>> array('i', [0, 1, 2])
    : >>> ... >>> array('i', [1, 2, 3])
    : >>> ... >>> array('i', [1, 2, 3])
    : >>> ... >>> array('i', [1, 2, 3])
    : >>> ... >>> array('i', [1, 2, 3])
    : >>> ... >>> array('u', 'abc')

    如果INITIALIZER为链表，或字符串（'u'类型代码），实际上是调用了
    array的fromlist()、frombytes()或fromunicode()方法将新元素添加到数
    组中；如其它情况则是使用extend()方法将INITIALIZER中的元素添加到数
    组中。

** 此模块定义的方法有
*** array. *typecodes*
    返回所有可用的类型代码。

    #+BEGIN_SRC python :session
      import array
      array.typecodes
    #+END_SRC

    #+RESULTS:
    :
    : 'bBuhHiIlLqQfd'

*** array. *typecode*
    
    #+BEGIN_SRC python :session
      from array import array
      l = array('l')
      l.typecode
    #+END_SRC
    
    #+RESULTS:
    :
    : >>> 'l'
    
*** array. *itemsize*

    数组中单个元素所占byte数。

    #+BEGIN_SRC python :session
      from array import array

      a = array('b', b'abc')
      a.itemsize

      b = array('l', [1, 2, 3])
      b.itemsize
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> 1
    : >>> >>> 8

*** array. *append* (x)
    追加元素。

    #+BEGIN_SRC python :session
      from array import array

      a = array('i', [1, 2, 3])
      a.append(4)
      print(a)
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> >>> array('i', [1, 2, 3, 4])

*** array. *buffer_info* ()
    返回数组的内存地址，以及元素个数，可使用array.buffer_info()[1] *
    a.itemsize获取数组所在内存大小：

    #+BEGIN_SRC python :session
      from array import array

      a = array('d', range(3))
      print(a)
      print(a.buffer_info())
      a.buffer_info()[1] * a.itemsize
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> array('d', [0.0, 1.0, 2.0])
    : (93900589887952, 3)
    : 24

    *注意* ：此方法为向后兼容方法，不建议使用。

    如需获取内存大小，可使用len函数：

    #+BEGIN_SRC python :session
      from array import array

      a = array('l', [1, 2, 3])
      len(a) * a.itemsize
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> 24

*** array. *byteswap* () ？？？
    对数组中内个元素进行byte交换。即最低位byte与最高位交换，倒数第2位
    byte与第二位交换。？？？

    #+BEGIN_SRC python :session
      from array import array

      a = array('i', [255])
      print(a)

      a.byteswap()
      print(a)

      bin(255)
      bin(-1677216)
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> array('i', [255])
    : >>> >>> array('i', [-16777216])
    : >>> '0b11111111'
    : '-0b110011001011110100000'

    *？* ：不知道有啥卵用。
    [[http://stackoverflow.com/questions/27506474/how-to-byte-swap-a-32-bit-integer-in-python]]

*** array. *count* (x)
    返回数组中X的个数。

    #+BEGIN_SRC python :session
      from array import array
      a = array('i', [1, 2, 1, 2, 1])
      a.count(1)
      a.count(10)
    #+END_SRC

    #+RESULTS:
    :
    : >>> 3
    : 0

*** array. *extend* (iterable)
    将ITERABLE中的内容追加到ARRAY后。如果ITERABLE也是数组，须有相同的
    类型代码；如果不为数组，则其元素类型必须适合原数组。

    #+BEGIN_SRC python :session
      from array import array
      a = array('i', [1, 2, 3])
      a.extend([4, 5, 6, 7, 8])
      print(a)
      print(a.typecode, a.itemsize)
      a.extend(array('i', [9, 10]))
      print(a)
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> array('i', [1, 2, 3, 4, 5, 6, 7, 8])
    : i 4
    : >>> array('i', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

*** array. *frombytes* (s)
    与fromfile方法相似，只是将将字符串的所有内容读入数组中。

    #+BEGIN_SRC python :session
      from array import array
      a = array('B', [100])
      a.frombytes(b'abcdef')
      print(a)
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> array('B', [100, 97, 98, 99, 100, 101, 102])

*** array. *fromfile* (f, n)
    从文件对象F中逐个读取N个数组中元素大小一样的对象，添加到数组后。

    如果F中的内容不足，会返回EOFError错误，不过会将所有能读取的内容读
    取到数组中。

    *注意* ：F须以二进制形式访问。F须为真实的内置文件对象。

    #+BEGIN_EXAMPLE emma.txt
      a b c d e f g h i j k l m n o p q r s t u v w x y z
    #+END_EXAMPLE

    #+BEGIN_SRC python :eval never
      from array import array

      a = array('b')

      with open('files/emma.txt', 'br') as fp:
          a.fromfile(fp, 10)
          print(a)
          a.fromfile(fp, 100)
          print(a)

      print(a)
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> >>> >>> ... ... ... ... ... array('b', [97, 32, 98, 32, 99, 32, 100, 32, 101, 32])
    : Traceback (most recent call last):
    :   File "<stdin>", line 4, in <module>
    : EOFError: read() didn't return enough bytes
    : array('b', [97, 32, 98, 32, 99, 32, 100, 32, 101, 32, 102, 32, 103, 32, 104, 32, 105, 32, 106, 32, 107, 32, 108, 32, 109, 32, 110, 32, 111, 32, 112, 32, 113, 32, 114, 32, 115, 32, 116, 32, 117, 32, 118, 32, 119, 32, 120, 32, 121, 32, 122, 10])

*** array. *fromlist* (list)
    将链表LIST中的元素逐个添加到ARRAY末尾。相当于：

    #+BEGIN_SRC python :eval never
      for x in list:
          a.append(x)
    #+END_SRC

    #+BEGIN_SRC python :session
      from array import array
      a = array('i', [1, 2, 3])
      b = array('i', [1, 2, 3])

      a.fromlist([4, 5, 6])
      for i in [4, 5, 6]:
          b.append(i)

      print(a)
      print(b)
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> >>> >>> ... ... >>> array('i', [1, 2, 3, 4, 5, 6])
    : array('i', [1, 2, 3, 4, 5, 6])

*** array. *fromstring* ()
    已废弃。改名为frombytes。
*** array. *fromunicode* (s)
    将Unicode字符串中的数据添加到数组后，数组必须为'u'类型数组，否则会
    返回ValueError错误。

    #+BEGIN_SRC python :session
      from array import array
      a = array('u', 'abc')
      a.fromunicode('def一')
      print(a)

      # 不为'u'类型数组
      b = array('i', [1, 2, 3])
      b.fromunicode('abc')
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> array('u', 'abcdef一')
    : >>> >>> Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : ValueError: fromunicode() may only be called on unicode type arrays

*** array. *index* (x)
    返回ARRAY中最先出现X的索引，如果不含X，则返回ValueError错误。

    #+BEGIN_SRC python :session
      from array import array
      a = array('b', b'abc')
      a.index(98)
      print(a)
      a.index(100)
    #+END_SRC

    #+RESULTS:
    :
    : >>> 1
    : array('b', [97, 98, 99])
    : >>> Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : ValueError: array.index(x): x not in list

*** array. *insert* (i, x)
    将X添加到数组索引I前，如果大于最大索引添加到最后，如果为负数则相对
    于最后一个元素索引。

    #+BEGIN_SRC python :session
      from array import array

      a = array('i', [1, 2, 3])
      a.insert(0, 100)
      print(a)

      # 大于最大索引
      a.insert(100, 0)
      print(a)

      # 负数
      a.insert(-1, -100)              # ？？？
      print(a)
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> >>> array('i', [100, 1, 2, 3])
    : >>> ... >>> array('i', [100, 1, 2, 3, 0])
    : >>> ... >>> array('i', [100, 1, 2, 3, -100, 0])

*** array. *pop* ([i])
    索引为I的元素从数组中移除，并返回被移除的元素。I默认为-1，即移除最
    后一个元素。

    #+BEGIN_SRC python :session
      from array import array
      a = array('i', [1, 2, 3])
      a.pop()
      print(a)

      a.pop(0)
      print(a)

      for i in range(10):
          a.pop()
    #+END_SRC

    #+RESULTS:
    :
    : >>> 3
    : array('i', [1, 2])
    : >>> 1
    : array('i', [2])
    : >>> ... ... 2
    : Traceback (most recent call last):
    :   File "<stdin>", line 2, in <module>
    : IndexError: pop from empty array

*** array. *remove* (x)
    删除数组中第一个X元素，如果无，则返回ValueError错误。

    #+BEGIN_SRC python :session
      from array import array

      a = array('i', [1, 10, 1, 20])
      a.remove(1)
      print(a)

      a.remove(1000)
      print(a)
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> >>> array('i', [10, 1, 20])
    : >>> Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : ValueError: array.remove(x): x not in list
    : array('i', [10, 1, 20])

*** array. *reverse* ()
    将数组中所有元素所有元素逆序。

    #+BEGIN_SRC python :session
      from array import array

      a = array('i', [1, 2, 3])
      a.reverse()
      print(a)
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> >>> array('i', [3, 2, 1])

*** array. *tobytes* ()
    将数组中的元素转换为byte表示。

    #+BEGIN_SRC python :session
      from array import array

      a = array('b', [1, 2, 3])
      a.tobytes()
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> b'\x01\x02\x03'

*** array. *tofile* ()
    与tobytes方法相似，只是将内容写入文件。

    #+BEGIN_SRC python :eval never
      from array import array

      a = array('b', b'abcd\ne\n')

      with open('files/emma.txt', 'wb') as fp:
          a.tofile(fp)
    #+END_SRC

*** array. *tolist* ()
    将数组转换为普通链表。

    #+BEGIN_SRC python :session
      from array import array

      a = array('i', [1, 2, 3])
      a.tolist()
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> [1, 2, 3]

*** array. *tostring* ()
    已废除，新名为tobytes()。

    #+BEGIN_SRC python :session
      from array import array
      a = array('i', [1, 2, 3])
      a.tostring()
    #+END_SRC

    #+RESULTS:
    :
    : >>> b'\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'

*** array. *tounicode* ()
    将数组转换为Unicode字符串，数组的类型代码须为'u'，否则返回
    ValueError错误。

    #+BEGIN_SRC python :session
      from array import array
      a = array('u', '我有一个梦想！')
      a.tounicode()
    #+END_SRC

    #+RESULTS:
    :
    : >>> '我有一个梦想！'

* weakref
* types - 内置类型动态创建和命名
* copy - 浅层复制和深层复制
* pprint - 数据美化显示
* reprlib - 另一个repr()实现
* enum - 枚举支持
