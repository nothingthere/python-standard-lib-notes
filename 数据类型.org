# Author: Claudio <3261958605@qq.com>
# Created: 2017-05-02 15:22:30
# Commentary:
#+TITLE: 数据类型

除Python内置的数据类型：dict、list、set、frozenset、tuple、str和
bytes/bytearray外（其中str类型用于存储Unicode字符串，bytes用于存储二进
制数据。）。本章介绍一些特殊的数据类型，如dates和times，类型固定的数组，
队列和集合。

* datetime - 基本日期和时间类型 （待续）
** 模块常量
*** datetime. *MINYEAR*
*** datetime. *MAXYEAR*
    date和datetime对象中允许的最大/小年数。

    #+BEGIN_SRC python :session
      import datetime
      datetime.MINYEAR
      datetime.MAXYEAR
    #+END_SRC

    #+RESULTS:
    :
    : >>> 1
    : 9999

** 可用类型
** timedelta对象
** date对象
** datetime对象
** time对象
** tzinfo对象
** timezone 对象
** strftime()和strptime()
* calendar - 日历相关函数 （待续）
* collections - 容器类型
  此模块对内置类型dict、list、set和tuple实现了容器包装。

  | namedtuple  | 命名式元组工厂函数                     |
  | deque       | 类链表容器，可快速在两端添加和删除元素 |
  | ChainMap    | 类字典类，利用多个映射创建单个view     |
  | Counter     | 字典子类，计数可哈希对象               |
  | OrderedDict | 字典子类，可记录添加元素的顺序         |
  | defaultdict | 字典子类，调用工厂函数添加消失值       |
  | UserDict    | 字典对象包装器，方便创建字典子类       |
  | UserList    | 链表对象包装器，方便创建链表子类       |
  | UserString  | 字符串对象包装器，方便创建字符串子类   |

** ChainMap对象
   将多个映射对象结合，作为单个对象。比创建新字典对象，然后使用字典的
   update()方法快。

*** class collections. *ChainMap* (*maps)
    ChainMap将多个字典或映射对象集合到一起，创建一个新的，可更新的view。
    如果没有MAP参数，则将空字典传递给此构建函数。

    #+BEGIN_SRC python :session
      from collections import ChainMap
      books = {'A': 10, 'B': 11}
      persons = {'Mike': 23, 'Lily': 27}
      mix = ChainMap(books, persons)
      print(mix)
      ChainMap()
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> >>> ChainMap({'A': 10, 'B': 11}, {'Lily': 27, 'Mike': 23})
    - ChainMap({})
    #+END_SRC

    ChainMap内部用链表集中各个映射对象，各元素映射对象可使用MAP的属性
    获取或跟新。此外无其他任何状态：

    #+BEGIN_SRC python :session
      mix['Lily'] = 100
      print(mix)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - ChainMap({'A': 10, 'Lily': 100, 'B': 11}, {'Lily': 27, 'Mike': 23})
    #+END_SRC
    
    除查找外，重新赋值、跟新和删除都只在第一个映射对象中进行：
    
    #+BEGIN_SRC python :session
      mix['Lily']
      mix['A']
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - 100
    - 10
    #+END_SRC
    
    ChainMap中的元素实际上是原映射的指针，即改变原来映射，其中的元素也
    随之改变：
    
    #+BEGIN_SRC python :session
      del persons['Mike']
      print(persons)
      print(mix)
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - {'Lily': 27}
    - ChainMap({'A': 10, 'Lily': 100, 'B': 11}, {'Lily': 27})
    #+END_SRC
    
    除字典常用方法外，ChainMap还支持下面属性和方法：
    
**** maps
     返回可更新的字典链表。修改其中的元素即可修改ChainMap本身，也可修
     改原来的字典对象。
     
     #+BEGIN_SRC python :session
       mix.maps
       mix.maps[0]['A'] = -1
       print(mix)
       print(books)
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - [{'A': 10, 'Lily': 100, 'B': 11}, {'Lily': 27}]
     - >>> ChainMap({'A': -1, 'Lily': 100, 'B': 11}, {'Lily': 27})
     - {'A': -1, 'Lily': 100, 'B': 11}
     #+END_SRC
     
**** new_child(m=None)
     返回新的ChainMap对象，其中第一个元素为M，后面为当前对象的所有maps。
     如果M参数缺省，则默认为空字典。此方法可用来更新第一个字典，而不影
     响所有原来的字典。
     
     下面两种方式等级：
     
     #+BEGIN_SRC python :eval never
       d.new_child()
       ChainMap({}, *d.maps)
     #+END_SRC
     
     更新除第一个以外的字典会影响原来ChainMap，以及字典对象：
     
     #+BEGIN_SRC python :session
       submix = mix.new_child()
       print('submix: ', submix)
       print('mix: ', mix)
       print('books: ', books)
       submix.maps[1]['A'] = -100
       print('submix after change: ', submix)
       print('mix after change: ', mix)
       print('books after change: ', books)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - submix:  ChainMap({}, {'A': -1, 'Lily': 100, 'B': 11}, {'Lily': 27})
     - mix:  ChainMap({'A': -1, 'Lily': 100, 'B': 11}, {'Lily': 27})
     - books:  {'A': -1, 'Lily': 100, 'B': 11}
     - >>> submix after change:  ChainMap({}, {'A': -100, 'Lily': 100, 'B': 11}, {'Lily': 27})
     - mix after change:  ChainMap({'A': -100, 'Lily': 100, 'B': 11}, {'Lily': 27})
     - books after change:  {'A': -100, 'Lily': 100, 'B': 11}
     #+END_SRC

**** parents
     返回新ChainMap对象，元素含除第一个字典外的所有元素。可用于在搜索
     时跳过第一个字典。
     
     #+BEGIN_SRC python :session
       mix.parents
       submix.parents
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - ChainMap({'Lily': 27})
     - ChainMap({'A': -100, 'Lily': 100, 'B': 11}, {'Lily': 27})
     #+END_SRC
     
*** ChainMap应用举例
**** 模仿Python的内部查找链
     
     #+BEGIN_SRC python :session
       import collections
       import builtins
       collections.ChainMap(locals(), globals(), vars(builtins))
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> ChainMap({'persons': {'Lily': 27}, 'books': {'A': -100, 'Lily': 100, 'B': 11}, 's2': <__main__.Student object at 0x7fd899977f98>, '__spec__': None, 'basetwo': functools.partial(<class 'int'>, base=2), 'add': <built-in function add>, '__pyfile': <codecs.StreamReaderWriter object at 0x7fd899974e10>, 'Decimal': <class 'decimal.Decimal'>, 'A': <function A at 0x7fd898edbd90>, 'nothing': <function nothing at 0x7fd898edb598>, 'partial': <class 'functools.partial'>, 'partialmethod': <class 'functools.partialmethod'>, '__PYTHON_EL_get_completions': <function __PYTHON_EL_get_completions at 0x7fd899ac0f28>, 'reduce': <built-in function reduce>, 'my_decorator': <function my_decorator at 0x7fd898eedb70>, 'mix': ChainMap({'A': -100, 'Lily': 100, 'B': 11}, {'Lily': 27}), '__FFAP_get_module_path': <function __FFAP_get_module_path at 0x7fd89925b048>, '__name__': '__main__', 'wraps': <function wraps at 0x7fd8999aad90>, 'B': <function B at 0x7fd898edba60>, '__PYDOC_get_help': <function __PYDOC_get_help at 0x7fd89925b0d0>, '_': <function _ at 0x7fd898edb048>, 'Student': <class '__main__.Student'>, 'collections': <module 'collections' from '/usr/lib/python3.5/collections/__init__.py'>, '__builtins__': <module 'builtins' (built-in)>, 'c2': <__main__.Cell object at 0x7fd898ec2b38>, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, 'Cell': <class '__main__.Cell'>, 'fun': <function fun at 0x7fd898edb2f0>, 'example': <function example at 0x7fd898eeda60>, 'fun_dispatch': <function fun_dispatch at 0x7fd898eed9d8>, '__package__': None, 's1': <__main__.Student object at 0x7fd89926d0b8>, '__builtin__': <module 'builtins' (built-in)>, 'builtins': <module 'builtins' (built-in)>, 'total_ordering': <function total_ordering at 0x7fd89993bb70>, 'c1': <__main__.Cell object at 0x7fd898ec2ac8>, 'fun_diapatch': <function fun_diapatch at 0x7fd898edb400>, 'codecs': <module 'codecs' from '/usr/lib/python3.5/codecs.py'>, 'functools': <module 'functools' from '/usr/lib/python3.5/functools.py'>, 'readline': <module 'readline' from '/usr/lib/python3.5/lib-dynload/readline.cpython-35m-x86_64-linux-gnu.so'>, 'rlcompleter': <module 'rlcompleter' from '/usr/lib/python3.5/rlcompleter.py'>, 'ChainMap': <class 'collections.ChainMap'>, 'submix': ChainMap({}, {'A': -100, 'Lily': 100, 'B': 11}, {'Lily': 27}), 'singledispatch': <function singledispatch at 0x7fd8999ad6a8>, '__code': b"def __PYDOC_get_help(obj):\n    try:\n        import inspect\n        if hasattr(obj, 'startswith'):\n            obj = eval(obj, globals())\n        doc = inspect.getdoc(obj)\n        if not doc and callable(obj):\n            target = None\n            if inspect.isclass(obj) and hasattr(obj, '__init__'):\n                target = obj.__init__\n                objtype = 'class'\n            else:\n                target = obj\n                objtype = 'def'\n            if target:\n                args = inspect.formatargspec(\n                    *inspect.getargspec(target)\n                )\n                name = obj.__name__\n                doc = '{objtype} {name}{args}'.format(\n                    objtype=objtype, name=name, args=args\n                )\n        else:\n            doc = doc.splitlines()[0]\n    except:\n        doc = ''\n    try:\n        exec('print doc')\n    except SyntaxError:\n        print(doc)", '__doc__': None, 'os': <module 'os' from '/usr/lib/python3.5/os.py'>}, {'persons': {'Lily': 27}, 'books': {'A': -100, 'Lily': 100, 'B': 11}, 's2': <__main__.Student object at 0x7fd899977f98>, '__spec__': None, 'basetwo': functools.partial(<class 'int'>, base=2), 'add': <built-in function add>, '__pyfile': <codecs.StreamReaderWriter object at 0x7fd899974e10>, 'Decimal': <class 'decimal.Decimal'>, 'A': <function A at 0x7fd898edbd90>, 'nothing': <function nothing at 0x7fd898edb598>, 'partial': <class 'functools.partial'>, 'partialmethod': <class 'functools.partialmethod'>, '__PYTHON_EL_get_completions': <function __PYTHON_EL_get_completions at 0x7fd899ac0f28>, 'reduce': <built-in function reduce>, 'my_decorator': <function my_decorator at 0x7fd898eedb70>, 'mix': ChainMap({'A': -100, 'Lily': 100, 'B': 11}, {'Lily': 27}), '__FFAP_get_module_path': <function __FFAP_get_module_path at 0x7fd89925b048>, '__name__': '__main__', 'wraps': <function wraps at 0x7fd8999aad90>, 'B': <function B at 0x7fd898edba60>, '__PYDOC_get_help': <function __PYDOC_get_help at 0x7fd89925b0d0>, '_': <function _ at 0x7fd898edb048>, 'Student': <class '__main__.Student'>, 'collections': <module 'collections' from '/usr/lib/python3.5/collections/__init__.py'>, '__builtins__': <module 'builtins' (built-in)>, 'c2': <__main__.Cell object at 0x7fd898ec2b38>, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, 'Cell': <class '__main__.Cell'>, 'fun': <function fun at 0x7fd898edb2f0>, 'example': <function example at 0x7fd898eeda60>, 'fun_dispatch': <function fun_dispatch at 0x7fd898eed9d8>, '__package__': None, 's1': <__main__.Student object at 0x7fd89926d0b8>, '__builtin__': <module 'builtins' (built-in)>, 'builtins': <module 'builtins' (built-in)>, 'total_ordering': <function total_ordering at 0x7fd89993bb70>, 'c1': <__main__.Cell object at 0x7fd898ec2ac8>, 'fun_diapatch': <function fun_diapatch at 0x7fd898edb400>, 'codecs': <module 'codecs' from '/usr/lib/python3.5/codecs.py'>, 'functools': <module 'functools' from '/usr/lib/python3.5/functools.py'>, 'readline': <module 'readline' from '/usr/lib/python3.5/lib-dynload/readline.cpython-35m-x86_64-linux-gnu.so'>, 'rlcompleter': <module 'rlcompleter' from '/usr/lib/python3.5/rlcompleter.py'>, 'ChainMap': <class 'collections.ChainMap'>, 'submix': ChainMap({}, {'A': -100, 'Lily': 100, 'B': 11}, {'Lily': 27}), 'singledispatch': <function singledispatch at 0x7fd8999ad6a8>, '__code': b"def __PYDOC_get_help(obj):\n    try:\n        import inspect\n        if hasattr(obj, 'startswith'):\n            obj = eval(obj, globals())\n        doc = inspect.getdoc(obj)\n        if not doc and callable(obj):\n            target = None\n            if inspect.isclass(obj) and hasattr(obj, '__init__'):\n                target = obj.__init__\n                objtype = 'class'\n            else:\n                target = obj\n                objtype = 'def'\n            if target:\n                args = inspect.formatargspec(\n                    *inspect.getargspec(target)\n                )\n                name = obj.__name__\n                doc = '{objtype} {name}{args}'.format(\n                    objtype=objtype, name=name, args=args\n                )\n        else:\n            doc = doc.splitlines()[0]\n    except:\n        doc = ''\n    try:\n        exec('print doc')\n    except SyntaxError:\n        print(doc)", '__doc__': None, 'os': <module 'os' from '/usr/lib/python3.5/os.py'>}, {'FutureWarning': <class 'FutureWarning'>, 'Warning': <class 'Warning'>, 'SystemError': <class 'SystemError'>, 'hash': <built-in function hash>, 'LookupError': <class 'LookupError'>, 'UnicodeError': <class 'UnicodeError'>, 'next': <built-in function next>, 'str': <class 'str'>, '__spec__': ModuleSpec(name='builtins', loader=<class '_frozen_importlib.BuiltinImporter'>), 'issubclass': <built-in function issubclass>, 'IsADirectoryError': <class 'IsADirectoryError'>, 'staticmethod': <class 'staticmethod'>, 'FileExistsError': <class 'FileExistsError'>, 'copyright': Copyright (c) 2001-2017 Python Software Foundation.
     - All Rights Reserved.
     - Copyright (c) 2000 BeOpen.com.
     - All Rights Reserved.
     - Copyright (c) 1995-2001 Corporation for National Research Initiatives.
     - All Rights Reserved.
     - Copyright (c) 1991-1995 Stichting Mathematisch Centrum, Amsterdam.
     - All Rights Reserved., 'id': <built-in function id>, 'ImportWarning': <class 'ImportWarning'>, 'ArithmeticError': <class 'ArithmeticError'>, 'all': <built-in function all>, 'ZeroDivisionError': <class 'ZeroDivisionError'>, 'OverflowError': <class 'OverflowError'>, 'help': Type help() for interactive help, or help(object) for help about object., 'Ellipsis': Ellipsis, 'BrokenPipeError': <class 'BrokenPipeError'>, 'globals': <built-in function globals>, 'DeprecationWarning': <class 'DeprecationWarning'>, 'BufferError': <class 'BufferError'>, 'chr': <built-in function chr>, 'len': <built-in function len>, 'UnicodeTranslateError': <class 'UnicodeTranslateError'>, 'classmethod': <class 'classmethod'>, 'bin': <built-in function bin>, 'sorted': <built-in function sorted>, '_': None, 'ConnectionResetError': <class 'ConnectionResetError'>, 'UnboundLocalError': <class 'UnboundLocalError'>, 'bytes': <class 'bytes'>, 'frozenset': <class 'frozenset'>, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, 'StopIteration': <class 'StopIteration'>, 'ValueError': <class 'ValueError'>, 'bytearray': <class 'bytearray'>, '__package__': '', 'BytesWarning': <class 'BytesWarning'>, 'license': Type license() to see the full license text, 'SyntaxError': <class 'SyntaxError'>, 'MemoryError': <class 'MemoryError'>, 'repr': <built-in function repr>, 'input': <built-in function input>, 'TabError': <class 'TabError'>, 'RecursionError': <class 'RecursionError'>, 'dict': <class 'dict'>, 'UnicodeWarning': <class 'UnicodeWarning'>, 'BaseException': <class 'BaseException'>, 'hex': <built-in function hex>, 'sum': <built-in function sum>, 'None': None, 'ConnectionAbortedError': <class 'ConnectionAbortedError'>, 'RuntimeError': <class 'RuntimeError'>, '__import__': <built-in function __import__>, 'delattr': <built-in function delattr>, 'NotImplemented': NotImplemented, 'TypeError': <class 'TypeError'>, 'RuntimeWarning': <class 'RuntimeWarning'>, 'exec': <built-in function exec>, 'max': <built-in function max>, 'tuple': <class 'tuple'>, 'NotImplementedError': <class 'NotImplementedError'>, 'locals': <built-in function locals>, 'slice': <class 'slice'>, 'FloatingPointError': <class 'FloatingPointError'>, 'EOFError': <class 'EOFError'>, 'IndentationError': <class 'IndentationError'>, 'map': <class 'map'>, 'iter': <built-in function iter>, 'AttributeError': <class 'AttributeError'>, 'list': <class 'list'>, 'True': True, 'False': False, 'compile': <built-in function compile>, 'NameError': <class 'NameError'>, 'any': <built-in function any>, 'round': <built-in function round>, 'OSError': <class 'OSError'>, 'SystemExit': <class 'SystemExit'>, 'FileNotFoundError': <class 'FileNotFoundError'>, 'SyntaxWarning': <class 'SyntaxWarning'>, 'TimeoutError': <class 'TimeoutError'>, 'dir': <built-in function dir>, 'StopAsyncIteration': <class 'StopAsyncIteration'>, 'format': <built-in function format>, 'complex': <class 'complex'>, 'min': <built-in function min>, 'ConnectionError': <class 'ConnectionError'>, 'isinstance': <built-in function isinstance>, 'eval': <built-in function eval>, 'getattr': <built-in function getattr>, 'EnvironmentError': <class 'OSError'>, 'abs': <built-in function abs>, 'ord': <built-in function ord>, '__name__': 'builtins', 'reversed': <class 'reversed'>, 'exit': Use exit() or Ctrl-D (i.e. EOF) to exit, 'KeyboardInterrupt': <class 'KeyboardInterrupt'>, 'super': <class 'super'>, 'filter': <class 'filter'>, 'ProcessLookupError': <class 'ProcessLookupError'>, 'hasattr': <built-in function hasattr>, 'IOError': <class 'OSError'>, 'set': <class 'set'>, 'ResourceWarning': <class 'ResourceWarning'>, 'ChildProcessError': <class 'ChildProcessError'>, 'setattr': <built-in function setattr>, 'callable': <built-in function callable>, 'print': <built-in function print>, 'divmod': <built-in function divmod>, 'bool': <class 'bool'>, '__debug__': True, 'type': <class 'type'>, 'PendingDeprecationWarning': <class 'PendingDeprecationWarning'>, 'AssertionError': <class 'AssertionError'>, 'UserWarning': <class 'UserWarning'>, 'pow': <built-in function pow>, 'IndexError': <class 'IndexError'>, 'UnicodeEncodeError': <class 'UnicodeEncodeError'>, 'ascii': <built-in function ascii>, 'GeneratorExit': <class 'GeneratorExit'>, '__build_class__': <built-in function __build_class__>, 'memoryview': <class 'memoryview'>, 'open': <built-in function open>, 'credits':     Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands
     -     for supporting Python development.  See www.python.org for more information., 'PermissionError': <class 'PermissionError'>, 'NotADirectoryError': <class 'NotADirectoryError'>, 'object': <class 'object'>, 'quit': Use quit() or Ctrl-D (i.e. EOF) to exit, 'oct': <built-in function oct>, 'ImportError': <class 'ImportError'>, 'ReferenceError': <class 'ReferenceError'>, 'float': <class 'float'>, 'Exception': <class 'Exception'>, 'InterruptedError': <class 'InterruptedError'>, 'range': <class 'range'>, 'enumerate': <class 'enumerate'>, 'int': <class 'int'>, 'KeyError': <class 'KeyError'>, 'zip': <class 'zip'>, 'vars': <built-in function vars>, 'UnicodeDecodeError': <class 'UnicodeDecodeError'>, 'BlockingIOError': <class 'BlockingIOError'>, 'property': <class 'property'>, 'ConnectionRefusedError': <class 'ConnectionRefusedError'>, '__doc__': "Built-in functions, exceptions, and other objects.\n\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices."})
     #+END_SRC

**** 将命令行参数覆盖系统变量，系统变量覆盖默认值

     #+BEGIN_SRC python :session
       import os
       import argparse
       import collections
       defaults = {'color': 'green', 'user': 'guest'}

       parser = argparse.ArgumentParser()
       parser.add_argument('-u', '--user')
       parser.add_argument('-c', '--color')
       namespace = parser.parse_args('-u claudio'.split())
       command_line_args = {k: v for k, v in vars(namespace).items() if v}
       combined = collections.ChainMap(command_line_args, os.environ, defaults)
       print(combined)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> >>> >>> >>> _StoreAction(option_strings=['-u', '--user'], dest='user', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - _StoreAction(option_strings=['-c', '--color'], dest='color', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
     - >>> >>> >>> ChainMap({'user': 'claudio'}, environ({'NODE_PATH': '/usr/lib/nodejs:/usr/lib/node_modules:/usr/share/javascript', 'QT_IM_MODULE': 'fcitx', 'XDG_SESSION_ID': '3', 'COLUMNS': '151', 'LANG': 'en_HK.UTF-8', 'DISPLAY': ':0', 'TERMCAP': '', 'LOGNAME': 'claudio', 'XDG_SESSION_DESKTOP': 'default', 'XDG_DATA_DIRS': '/usr/share/gnome:/usr/local/share/:/usr/share/', 'DBUS_SESSION_BUS_ADDRESS': 'unix:path=/run/user/1000/bus', 'SSH_AUTH_SOCK': '/run/user/1000/keyring/ssh', 'SSH_AGENT_PID': '1055', 'GTK_IM_MODULE': 'fcitx', 'PS4': '$LINENO + ', 'XDG_VTNR': '2', 'USERNAME': 'claudio', 'PWD': '/home/claudio/Desktop/Python/python-standard-lib-notes', 'SHLVL': '1', 'PATH': '/home/claudio/tools:/home/claudio/bin:/home/claudio/.local/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games', 'LS_COLORS': 'rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:', 'HOME': '/home/claudio', 'DESKTOP_SESSION': 'default', 'QT_QPA_PLATFORMTHEME': 'qgnomeplatform', 'XMODIFIERS': '@im=fcitx', 'PYTHONPATH': '/home/claudio/python:', 'TERM': 'dumb', '_': '/usr/bin/emacs24', 'XDG_RUNTIME_DIR': '/run/user/1000', 'SESSION_MANAGER': 'local/kali:@/tmp/.ICE-unix/970,unix/kali:/tmp/.ICE-unix/970', 'EMACS': 't', 'XDG_CURRENT_DESKTOP': 'GNOME', 'QT_ACCESSIBILITY': '1', 'JOURNAL_STREAM': '8:16293', 'XDG_MENU_PREFIX': 'gnome-', 'QT_LINUX_ACCESSIBILITY_ALWAYS_ON': '1', 'COLORTERM': 'truecolor', 'PYTHONUNBUFFERED': '1', 'XDG_SEAT': 'seat0', 'USER': 'claudio', 'GDM_LANG': 'en_HK.UTF-8', 'XDG_SESSION_TYPE': 'x11', 'GPG_AGENT_INFO': '/run/user/1000/gnupg/S.gpg-agent:0:1', 'QT4_IM_MODULE': 'fcitx', 'VTE_VERSION': '4601', 'CLUTTER_IM_MODULE': 'xim', 'GNOME_DESKTOP_SESSION_ID': 'this-is-deprecated', 'SHELL': '/bin/bash', 'WINDOWPATH': '2', 'WINDOWID': '27262982', 'XAUTHORITY': '/run/user/1000/gdm/Xauthority', 'GTK_MODULES': 'gail:atk-bridge', 'DESKTOP_AUTOSTART_ID': '101650a80580e95109149442005843100200000009700001', 'GDMSESSION': 'default', 'INSIDE_EMACS': '24.5.1,comint'}), {'color': 'green', 'user': 'guest'})
     #+END_SRC

**** 模仿嵌套上下文

     #+BEGIN_SRC python :eval never
       from collections import ChainMap

       c = ChainMap()                    # 创建根上下文
       d = c.new_child()                 # 创建嵌套子上下文
       e = c.new_child()                 # 嵌套子上下文，独立于c
       e.maps[0]                         # 当前上下文字典--相当于Python的locals()
       e.maps[-1]                        # 根上下文--相当于Python的globals()
       e.parents                         # 相当于Python的nonlocals

       d['x']                            # 获取整个上下文中的key
       d['x'] = 1                        # 设置当前上下文的值
       del d['x']                        # 删除当前上下文的值
       list(d)                           # 所有嵌套key
       k in d                            # 检查包含
       d.items()                         # 所有嵌套元素
       dict(d)                           # 转换为普通字典
     #+END_SRC

**** 深层赋值和删除
     默认情况下，ChainMap的删除和赋值都在第一个字典中进行，只有查找在
     所有字典中进行。如需进行深层赋值和删除，可通过子类实现：
     
     #+BEGIN_SRC python :session
       from collections import ChainMap

       class DeepChainMap(ChainMap):
           '''允许在所有元素字典中赋值和删除的ChainMap子类.'''
           def __setitem__(self, key, val):
               for mapping in self.maps:
                   if key in mapping:
                       mapping[key] = val
                       return
               self.maps[0][key] = val
           def __delitem__(self, key):
               for mapping in self.maps:
                   if key in mapping:
                       del mapping[key]
                       return
               raise KeyError(key)

       d = DeepChainMap({'zebra': 'black'}, {'elephant': 'blue'}, {'lion': 'yellow'})
       d['lion'] = 'orange'
       print(d)
       d['snake'] = 'blue'
       print(d)
       del d['zebra']
       print(d)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> ... ... ... ... ... ... ... ... ... ... ... ... ... ... >>> >>> >>> DeepChainMap({'zebra': 'black'}, {'elephant': 'blue'}, {'lion': 'orange'})
     - >>> DeepChainMap({'zebra': 'black', 'snake': 'blue'}, {'elephant': 'blue'}, {'lion': 'orange'})
     - >>> DeepChainMap({'snake': 'blue'}, {'elephant': 'blue'}, {'lion': 'orange'})
     #+END_SRC

** Counter对象
   方便快速获取对象“尾部”。比如找到文本中出现频率最高的单词：
   
   #+BEGIN_SRC python :session
     import re
     from collections import Counter
     words = re.findall(r'\w+', open('files/emma.txt').read().lower())
     Counter(words).most_common(4)
   #+END_SRC
   
   #+RESULTS:
   #+BEGIN_SRC org
   - >>> >>> [('to', 5292), ('the', 5265), ('and', 4930), ('of', 4337)]
   #+END_SRC
   
   如记录单词出现次数：
   
   #+BEGIN_SRC python :session
     from collections import Counter
     cnt = Counter()
     for word in 'red blue red green blue blue'.split():
         cnt[word] += 1

     print(cnt)
   #+END_SRC
   
   #+RESULTS:
   #+BEGIN_SRC org
   - >>> ... ... >>> Counter({'blue': 3, 'red': 2, 'green': 1})
   #+END_SRC
   
*** class collections. *Counter* ([iterable-or-mapping])
    Counter是dict的子类，用于计数可哈希对象。为无序集合，key值为可哈希
    元素，value值为元素个数（可为负数和0）。

    参数可为iterable或其他映射对象：

    #+BEGIN_SRC python :session
      from collections import Counter
      Counter()
      Counter('gallanhad')
      Counter({'blue': 4, 'green': 2})
      Counter(cats=2, dogs=8)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - Counter()
    - Counter({'a': 3, 'l': 2, 'n': 1, 'g': 1, 'd': 1, 'h': 1})
    - Counter({'blue': 4, 'green': 2})
    - Counter({'dogs': 8, 'cats': 2})
    #+END_SRC

    对于不存在的元素，默认个数为0：

    #+BEGIN_SRC python :session
      from collections import Counter
      Counter()['a']
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 0
    #+END_SRC
    
    将个数设置为0并不能将元素从对象中删除，还得用del：
    
    #+BEGIN_SRC python :session
      from collections import Counter
      cnt = Counter('abcabc')
      print(cnt)
      cnt['a'] = 0
      print(cnt)
      del cnt['a']
      print(cnt)
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> Counter({'c': 2, 'a': 2, 'b': 2})
    - >>> Counter({'c': 2, 'b': 2, 'a': 0})
    - >>> Counter({'c': 2, 'b': 2})
    #+END_SRC
    
**** 在dict类型上新增的方法
***** elements()
      返回含所有元素个数>0的元素组成的iterable对象，其如果有N个“X”，则
      含N个“X”元素（顺序不定）：
      
      #+BEGIN_SRC python :session
        from collections import Counter
        c = Counter(a=4, b=2, c=0, d=-2)
        c.elements()
        sorted(c.elements())
      #+END_SRC
      
      #+RESULTS:
      #+BEGIN_SRC org
      - >>> <itertools.chain object at 0x7fdbe62242b0>
      - ['a', 'a', 'a', 'a', 'b', 'b']
      #+END_SRC
      
***** most_common([n])
      返回元素个数最多的前N个元素及其个数组成的链表，如果缺省N参数，则
      返回全部元素。默认从大到小排序：
      
      #+BEGIN_SRC python :session
        from collections import Counter
        Counter('abracadabra').most_common(2)
      #+END_SRC
      
      #+RESULTS:
      #+BEGIN_SRC org
      - [('a', 5), ('b', 2)]
      #+END_SRC
      
***** subtract([iterable-mapping])
      将元素个数与另一个映射对象中的对应元素个数相减。都可为负数或0：

      #+BEGIN_SRC python :session
        from collections import Counter
        c1 = Counter(a=4, b=2, c=0, d=-2, e=3)
        c2 = Counter(a=1, b=2, c=3, d=4, f=3)
        c1.subtract(c2)
        print(c1)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> >>> >>> Counter({'e': 3, 'a': 3, 'b': 0, 'f': -3, 'c': -3, 'd': -6})
      #+END_SRC

**** 与dict类型有差异的方法
***** fromkeys(iterable)
      Counter对象无此方法。

***** update([iterable-or-mapping])
      ITERABLE-OR-MAPPING不为(key, value)形式的集合，而是单个元素组成
      的集合。

      #+BEGIN_SRC python :session
        from collections import Counter
        cnt = Counter('abca')
        cnt.update('bce')
        cnt
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> >>> Counter({'c': 2, 'a': 2, 'b': 2, 'e': 1})
      #+END_SRC
      
**** 常用操作
     
     #+BEGIN_SRC python :eval never
       sum(c.values())                 # 所有元素个数
       c.clear()                       # 清空
       list(c)                         # 转换为没有元素重复的链表
       set(c)                          # 转换为集合
       dict(c)                         # 转换为普通链表
       c.items()                       # 转换为(elem, cnt)形式的链表
       Counter(dict(list_of_pairs))    # 将(elem,cnt)形式的链表转换为Counter对象
       c.most_comman()[:-n - 1:-1]     # 获取个数最少的N个元素
       +c                              # 将个数<=0的元素去除
     #+END_SRC
     
     “|”和“&”操作分别为获取两者个数最多或最少的元素，加和减则是可数的
     加减。都去除个数<=0的元素：

     #+BEGIN_SRC python :session
       from collections import Counter
       c = Counter(a=3, b=1)
       d = Counter(a=1, b=2)
       c + d
       c - d
       c & d                           # 个数最少的元素
       c | d                           # 个数最多的元素
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> Counter({'a': 4, 'b': 3})
     - Counter({'a': 2})
     - Counter({'a': 1, 'b': 1})
     - Counter({'a': 3, 'b': 2})
     #+END_SRC

     单个加/减操作相当于与空Counter对象加/减，并去除个数<=0的元素：

     分别为去掉元素大于等于0/小于等于0的元素。

     #+BEGIN_SRC python :session
       from collections import Counter
       c = Counter(a=2, b=-4, c=0)
       c2 = Counter()
       c + c2, +c
       c - c2, -c
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> (Counter({'a': 2}), Counter({'a': 2}))
     - (Counter({'a': 2}), Counter({'b': 4}))
     #+END_SRC

** deque对象
*** class collections. *deque* ([iterable[,maxlen]])
    将ITERABLE中的元素从左到右使用append()方法初始化到新的deque对象中。
    如果缺省ITERABLE参数，返回空的deque对象。

    Deque对象为“堆（stack）”和“队列（queue）”的结合体，为
    “doubled-enabled queue”的缩写。在其两端添加和删除元素的效率都为
    O(1)，且线程安全（thread-safe），内存效率高。

    尽管list类型也支持相同操作，但只对定长链表有性能优化。在首尾删除和
    添加元素的效率为O(n)。

    如果MAXLEN参数为None，deque对象可增长为任意长度。否则，当填满元素
    后再向其中添加元素，相反方向的元素会被自动去除。类似于Unix中的tail
    命令。
**** 方法
***** append(x)
      将X添加到最右边。

      #+BEGIN_SRC python :session
        from collections import deque
        d = deque([1,2])
        d.append(10)
        print(d)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> >>> deque([1, 2, 10])
      #+END_SRC

***** appendleft(x)
      将X添加到最左边。

      #+BEGIN_SRC python :session
        from collections import deque
        d = deque([1, 2])
        d.appendleft(10)
        print(d)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> >>> deque([10, 1, 2])
      #+END_SRC

***** clear()
      删除所有元素。

      #+BEGIN_SRC python :session
        from collections import deque
        d = deque('abc')
        print(d)
        d.clear()
        print(d)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> deque(['a', 'b', 'c'])
      - >>> deque([])
      #+END_SRC

***** copy()
      浅层复制。

      #+BEGIN_SRC python :session
        from collections import deque

        d1 = deque([[1, 2], [3, 4]])
        d2 = d1.copy()
        d2[0][0] = 10
        d1, d2
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> >>> >>> >>> (deque([[10, 2], [3, 4]]), deque([[10, 2], [3, 4]]))
      #+END_SRC

***** count(x)
      返回元素中等于X的个数。

      #+BEGIN_SRC python :session
        from collections import deque
        d = deque('abcda')
        d.count('a')
        d.count('A')

        l = list('abcda')
        l.count('a')
        l.count('A')
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> 2
      - 0
      - >>> >>> 2
      - 0
      #+END_SRC

***** extend(iterable)
      将ITERABLE中的元素添加到后面。

      #+BEGIN_SRC python :session
        from collections import deque
        d = deque('abcd')
        d.extend('ef')
        print(d)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> >>> deque(['a', 'b', 'c', 'd', 'e', 'f'])
      #+END_SRC

***** extendleft(iterable)
      将ITERABLE中的元素添加到前面。
      
      *注意* ：添加后会逆序ITERABLE。
      
      #+BEGIN_SRC python :session
        from collections import deque
        d = deque('abcd')
        d.extendleft('ef')
        print(d)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> >>> deque(['f', 'e', 'a', 'b', 'c', 'd'])
      #+END_SRC

***** index(x[,start[,stop]])
      返回X在的索引，可设置START和END指定搜索范围。如果没找到，抛出
      ValueError错误。

      #+BEGIN_SRC python :session
        from collections import deque
        d = deque(b'abc')
        print(d)
        d.index(ord('b'))
        d.index(1000)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> deque([97, 98, 99])
      - 1
      - Traceback (most recent call last):
      -   File "<stdin>", line 1, in <module>
      - ValueError: 1000 is not in deque
      #+END_SRC

***** insert(i,x)
      将X插入，使其索引为I。
      
      *注意* ：如果使deque的中的元素超出maxlen，抛出IndexError错误。

      #+BEGIN_SRC python :session
        from collections import deque
        d = deque('abc')
        d.insert(0, 'A')
        print(d)

        d = deque('abc', 3)
        d.insert(0, 'A')
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> >>> deque(['A', 'a', 'b', 'c'])
      - >>> >>> Traceback (most recent call last):
      -   File "<stdin>", line 1, in <module>
      - IndexError: deque already at its maximum size
      #+END_SRC

***** pop()
      将deque的最后一个元素删除，并返回。如果其中没有元素，抛出
      IndexError错误。

      #+BEGIN_SRC python :session
        from collections import deque
        d = deque('abc')
        print(d.pop())
        print(d)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> c
      - deque(['a', 'b'])
      #+END_SRC

***** popleft()
      将最左边的元素删除并返回。如果没有元素，抛出IndexError错误。

      #+BEGIN_SRC python :session
        from collections import deque
        d = deque('abc')
        print(d)
        print(d.popleft())
        print(d)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> deque(['a', 'b', 'c'])
      - a
      - deque(['b', 'c'])
      #+END_SRC

***** remove(value)
      删除从左到右第一个出现的VALUE，如果没有，抛出ValueError错误。

      #+BEGIN_SRC python :session
        from collections import deque
        d = deque('abcad')
        print(d)
        d.remove('a')
        print(d)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> deque(['a', 'b', 'c', 'a', 'd'])
      - >>> deque(['b', 'c', 'a', 'd'])
      #+END_SRC

***** reverse()
      逆序当前对象，并返回None。

      #+BEGIN_SRC python :session
        from collections import deque
        d = deque('abc')
        print(d)
        print(d.reverse())
        print(d)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> deque(['a', 'b', 'c'])
      - None
      - deque(['c', 'b', 'a'])
      #+END_SRC

***** rotate(n)？？？
      交换元素顺序。

      #+BEGIN_SRC python :session
        from collections import deque

        d = deque('abcdef')
        d.rotate(1)
        print(d)

        d = deque('abcdef')
        d.rotate(-1)
        print(d)

        d = deque('abcdef')
        d.rotate(2)
        print(d)

        d = deque('abcdef')
        d.rotate(-2)
        print(d)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> >>> >>> deque(['f', 'a', 'b', 'c', 'd', 'e'])
      - >>> >>> >>> deque(['b', 'c', 'd', 'e', 'f', 'a'])
      - >>> >>> >>> deque(['e', 'f', 'a', 'b', 'c', 'd'])
      - >>> >>> >>> deque(['c', 'd', 'e', 'f', 'a', 'b'])
      #+END_SRC
      
**** 属性
***** maxlen
      只读属性。如果创建deque对象时有maxlen参数，则返回该值；如果无，
      则返回None。

      #+BEGIN_SRC python :session
        from collections import deque

        d = deque('abc')
        print(d.maxlen)

        d = deque('abc', maxlen=2)
        print(d.maxlen)

        d.maxlen = 3
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> >>> None
      - >>> >>> 2
      - >>> Traceback (most recent call last):
      -   File "<stdin>", line 1, in <module>
      - AttributeError: attribute 'maxlen' of 'collections.deque' objects is not writable
      #+END_SRC

**** 其他
     *注意* ：访问deque对象的首位元素效率为O(1)，访问中间元素效率为
     O(n)。所以如果时随机访问元素，建议使用链表。
     
     除上面的方法外，deque对象还支持的操作有：
     
     - iteration
     - len(d)
     - reversed(d)
     - copy.copy(d)
     - copy.deepcopy(d)
     - in操作
     - 下标访问：d[-1]
       
*** deque应用举例
    
    - 默认Unix的tail命令：
      
      #+BEGIN_SRC python :session
        from collections import deque

        def tail(filename, n=10):
            '返回文件的后面N行.'
            with open(filename) as fp:
                return deque(fp, n)

        tail('files/emma.txt', 2)
      #+END_SRC
      
      #+RESULTS:
      #+BEGIN_SRC org
      - >>> >>> ... ... ... ... >>> deque(['\n', 'End of The Project Gutenberg Etext of Emma, by Jane Austen\n'], maxlen=2)
      #+END_SRC

    - 模仿 [[http://en.wikipedia.org/wiki/Moving_average][Moving_average]] ：

      #+BEGIN_SRC python :session
        from itertools import islice
        from collections import deque

        def moving_average(iterable, n=3):
            it = iter(iterable)
            d = deque(islice(it, n - 1))
            # print(list(it))
            d.appendleft(0)
            s = sum(d)
            # print(s)
            for elem in it:
                s += elem - d.popleft()
                # print(s)
                d.append(elem)
                yield s / n

        print(list(moving_average([40, 30, 50, 46, 39, 44])))
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> >>> ... ... ... ... ... ... ... ... ... ... ... ... >>> [40.0, 42.0, 45.0, 43.0]
      #+END_SRC

    - 只有python代码实现del d[n]：

      #+BEGIN_SRC python :eval never
        from collections import deque

        def delete_nth(d, n):
            d.rotate(-n)
            d.popleft()
            d.rotate(n)
      #+END_SRC

** defaultdict对象
*** class collections. *defaultdict* ([default_factory[,...]])
    返回一个新的类字典对象。default为内置dict类的子类，支持dict类型的
    所有用法。

    第一个参数DEFAULT_FACTORY为新建对象同名属性，默认为None。剩余所有
    你参数都被视作创建dict对象时的参数。

**** __missing__(key)
     在dict类型上新增的操作。

     如果default_factory属性为None，不管KEY是否存在于当前实例上，都会
     抛出KeyError错误。

     如果如果default_factory不为，不管KEY是否存在于当前实例上，调用不
     带参数的default_factory函数，将其作为KEY对应值。

     如果调用default_factory时抛出任何错误，不做任何修改向上冒泡。

     当KEY不存在时，此方法由dict类的__getitem__()方法调用。任何返回值
     或错误抛出都由__getitem__()函数返回或抛出。

     此方法只由__getitem__()方法调用。所有使用get()方法时与普通字典相
     同，即如果不存在指定key，则返回默认值（默认为None），而不会调用
     default_factory。

**** default_factory
     可写属性，供__missing__()方法使用。为不带参数的可调用对象，默认值
     为None。

*** defaultdict应用举例
**** 构建链表字典

     #+BEGIN_SRC python :session
       from collections import defaultdict

       s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
       d = defaultdict(list)
       for k, v in s:
           d[k].append(v)

       print(sorted(d.items()))
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> >>> ... ... >>> [('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]
     #+END_SRC

     当第一次遇见K时，使用default_factory指定的函数list创建空链表，再
     使用链表的append()方法将对应元素添加带链表中。如果再遇见相同K，则
     与普通字典查找方式相同。

     此方法比使用dict.setdefault()方法快：

     #+BEGIN_SRC python :session
       d = {}
       s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
       for k, v in s:
           d.setdefault(k, []).append(v)

       print(sorted(d.items()))
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> ... ... >>> [('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]
     #+END_SRC

**** 历遍计数
     由于不带参数的int()函数始终返回0，所以当K不存在时将对应值设置为0，
     再与当前值相加。

     #+BEGIN_SRC python :session
       from collections import defaultdict
       s = 'mississippi'
       d = defaultdict(int)
       for k in s:
           d[k] += 1

       print(sorted(d.items()))
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> ... ... >>> [('i', 4), ('m', 1), ('p', 2), ('s', 4)]
     #+END_SRC

**** 与lambda连用
     如上例使用int设置默认值为常量的形式，如果使用lambda构建常量函数更
     灵活，且速度更快。使用lambda改写上例为：
     
     #+BEGIN_SRC python :session
       from collections import defaultdict

       def constant_factory(value):
           return lambda: value

       d = defaultdict(constant_factory(0))
       for k in 'mississippi':
           d[k] += 1

       print(sorted(d.items()))
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> ... ... >>> >>> >>> ... ... >>> [('i', 4), ('m', 1), ('p', 2), ('s', 4)]
     #+END_SRC

     再如：
     
     #+BEGIN_SRC python :session
       d = defaultdict(constant_factory('<missing>'))
       d.update(name='john', action='ran')
       print('{name}s {action}s to {object}s'.format(**d))
       print(d.items())
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> johns rans to <missing>s
     - dict_items([('action', 'ran'), ('name', 'john'), ('object', '<missing>')])
     #+END_SRC
     
**** 构建集合字典
     
     #+BEGIN_SRC python :session
       from collections import defaultdict
       d = defaultdict(set)
       s = [('red', 1), ('blue', 2), ('red', 3), ('blue', 4), ('red', 1), ('blue', 4)]
       for k, v in s:
           d[k].add(v)

       print(d.items())
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> ... ... >>> dict_items([('blue', {2, 4}), ('red', {1, 3})])
     #+END_SRC

** namedtuple() - 元组工厂函数
   为元组每个元素添加“域名（field name）”，增加可读性。支持元组的所有
   操作，并添加用域名获取元素的功能。
   
*** collections. *namedtuple* (typename,filed_names,verbose=False,rename=False)
    返回以TYPENAME命名的元组子类。可使用域名访问元素，也可使用下标访问
    元素进行历遍。
    
    FILED_NAMES可为单个字符串，各域名由空格或/和逗号隔开的字符串，如'x
    y'或'x, y'。也可为字符串链表，如['x', 'y']。
    
    除关键字如class、for等，以下划线开始的识别符外，任何有效Python识别
    符都可作为TYPENAME。
    
    如果RENAME参数为True，无效的FIELD_NAME会自动转换为位置名称：
    
    #+BEGIN_SRC python :session
      from collections import namedtuple
      X = namedtuple('X', ['abc', 'def', 'ghi', 'abc'], rename=True)
      print(X(1, 2, 3, 4))
    #+END_SRC
    
    如果VERBOSE参数为True，创建namedtuple对象后，会打印定义该
    namedtuple的源码。（将废除，可使用_source属性获取。）
    
    #+BEGIN_SRC python :eval never
      print(X._source)
    #+END_SRC
    
    *注意* ：namedtuple对象内部没有实现字典，所以与普通元组一样轻量。
    
    基本示例：
    
    #+BEGIN_SRC python :session
      from collections import namedtuple
      Point = namedtuple('Point', 'x y')
      p = Point(1, y=2)               # 使用位置参数和关键字参数创建实例
      print(p[0] + p[1])              # 同普通元组一样可使用数字下标
      x, y = p                        # 同普通元组一样结构
      print(x, y)
      p.x + p.y                       # 使用域名获取元素
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> 3
    - >>> 1 2
    - 3
    #+END_SRC
    
    namedtuple特别适合于将csv和sqlite3的返回值赋值给元素：
    
    #+BEGIN_SRC python :eval never
      from collections import namedtuple
      EmployeeRecord = namedtuple(
          'Employeerecord', 'name, age, title, department, paygrade')

      import csv
      for emp in map(EmployeeRecord._make, csv.reader(open('employees.csv', 'rb'))):
          print(emp.name, emp.title)

      import sqlite3
      conn = sqlite3.connect('/companydata')
      cursor = conn.cursor()
      cursor.execute('SELECT name, age, title, department, paygrade FROM employees')
      for emp in map(EmployeeRecord._make, cursor.fetchall()):
          print(emp.name, emp.title)
    #+END_SRC
    
    除普通元组的方法和属性外，namedtuple还添加了下面3个方法和2个属性。
    为避免与域名重名，都以下划线开头：
    
**** classmethod somenamedtuple._make(iterable)
     模块函数，使用ITERABLE序列或iterable对象创建新对象。

     #+BEGIN_SRC python :session
       from collections import namedtuple
       Point = namedtuple('Point', 'x, y')
       t = [11, 22]
       p1 = Point._make(t)
       print(p1)
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> >>> Point(x=11, y=22)
     #+END_SRC

**** somenamedtuple._asdict()
     将namedtuple对象返回为OrderedDict对象：

     #+BEGIN_SRC python :session
       from collections import namedtuple
       P = namedtuple('P', 'x, y')
       p1 = P._make([11, 22])
       print(p1._asdict())
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> OrderedDict([('x', 11), ('y', 22)])
     #+END_SRC

**** somenamedtuple._replace(kwargs)
     替换KWARGS指定的元素和值，返回新的namedtuple对象：
     
     #+BEGIN_SRC python :session
       from collections import namedtuple
       Point = namedtuple('Point', 'x, y')
       p1 = Point(1, 2)
       p2 = p1._replace(x=100)
       print(p1, p2)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> >>> Point(x=1, y=2) Point(x=100, y=2)
     #+END_SRC

**** somenamedtuple._source
     返回构建namedtuple类的源码。可由于exec()函数执行，可保存到文件
     import。

**** somenamedtuple._fields
     返回由域名组成的元组。可用于查看，或利用已有的namedtuple创建新的
     namedtuple。

     #+BEGIN_SRC python :session
       from collections import namedtuple
       Color = namedtuple('Color', 'red green, blue')
       Point = namedtuple('Point', 'x y')
       Pixel = namedtuple('Pixel', Point._fields + Color._fields)
       print(Color._fields)
       print(Point._fields)
       print(Pixel._fields)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> >>> ('red', 'green', 'blue')
     - ('x', 'y')
     - ('x', 'y', 'red', 'green', 'blue')
     #+END_SRC
     
*** 举例
    可使用getattr()获取域名对应值：
    
    #+BEGIN_SRC python :session
      from collections import namedtuple
      Point = namedtuple('Point', 'x y')
      p = Point(1, 2)
      getattr(p, 'x')
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> 1
    #+END_SRC
    
    利用字典初始化实例：
    
    #+BEGIN_SRC python :session
      d = {'x': 11, 'y': 22}
      print(Point(**d))
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - Point(x=11, y=22)
    #+END_SRC
    
    由于namedtuple本身为一般的Python类，所以可通过声明子类添加和更改功
    能。
    
    #+BEGIN_SRC python :session
      from collections import namedtuple

      class Point(namedtuple('Point', 'x y')):
          __slots__ = ()
          @property
          def hypot(self):
              return (self.x**2 + self.y**2) ** 0.5
          def __str__(self):
              return 'Point: x={:6.3f} y={:6.3f} hypot={:6.3f}'.format(self.x, self.y, self.hypot)

      for p in Point(3, 4), Point(14, 5 / 7):
          print(p)
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> ... ... ... ... ... ... ... >>> >>> ... ... Point: x= 3.000 y= 4.000 hypot= 5.000
    - Point: x=14.000 y= 0.714 hypot=14.018
    #+END_SRC
    
    *注意* ：上例将__slots__属性设置为空元组目的是防止创建实例字典，减
    少内存消耗。
    
    如果要添加域名，使用__fields属性不创建子类更有用：

    #+BEGIN_SRC python :eval never
      Point3D = namedtuple('Point3D', Point_fileds + ('Z',))
    #+END_SRC

    可定制实例及其域名的__doc__属性。（可以help(Book)查看结果）：

    #+BEGIN_SRC python :eval never
      from collections import namedtuple
      Book = namedtuple('Book', 'id title authors')
      Book.__doc__ += '：预售书籍'
      Book.id.__doc__ = '13位ISBN编号'
      Book.title.__doc__ = '第一版书名'
      Book.authors.__doc__ = '由于所有作者名组成的链表'
      # help(Book)
    #+END_SRC

    可创建原型实例实现默认值，再使用_replace()方法定制：

    #+BEGIN_SRC python :session
      from collections import namedtuple
      Account = namedtuple('Account', 'owner balance transaction_count')
      default_account = Account('<owner name>', 0.0, 0)
      johns_account = default_account._replace(owner='John')
      janes_account = default_account._replace(owner='Janes')
      print(default_account)
      print(johns_account)
      print(janes_account)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> >>> >>> Account(owner='<owner name>', balance=0.0, transaction_count=0)
    - Account(owner='John', balance=0.0, transaction_count=0)
    - Account(owner='Janes', balance=0.0, transaction_count=0)
    #+END_SRC

** OrderedDict对象
   OrderedDict只是在dict的基础上，添加记忆元素参数位置的功能。遍历时，
   返回元素顺序与第一次插入时一样。
   
*** class collections. *OrderedDict* ([items])
    返回dict子类实例，支持dict的一般方法。OrderedDict会记录key第一次插
    入的位置。如果重写已存在的key，不会改变位置；如果删除再插入key，则
    会添加到最后。
    
**** popitem(last=True)
     返回并删除键值对。如果LAST为True，顺序为LIFO；如果为False，顺序为
     FIFO。

     #+BEGIN_SRC python :session
       from collections import OrderedDict
       d = OrderedDict.fromkeys('abcd')
       d.popitem()
       d.popitem(False)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> ('d', None)
     - ('a', None)
     #+END_SRC

**** move_to_end(key,last=True)
     将已存在的key移动到两端。如果LAST参数为True，移动到最后；如果为
     False，则移动到最前。
     
     #+BEGIN_SRC python :session
       from collections import OrderedDict
       d = OrderedDict.fromkeys('abcd')
       d.move_to_end('b')
       print(''.join(d.keys()))
       d.move_to_end('b', last=False)
       print(''.join(d.keys()))
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> acdb
     - >>> bacd
     #+END_SRC
     
**** 其他
     除普通的dict映射方法外，OrderedDict还支持reversed()操作。

     OrderedDict之间的相等比较会考虑元素顺序，与普通dict之间的相等比较
     不会考虑顺序。

     *注意* ：当OrderedDict和update()使用关键字参数创建和更新
     OrderedDict实例时，不会记忆元素顺序。因为如果参数为关键字参数，实
     际上是将参数传递给普通dict。
     
     OrderedDict的键、值和键值对view也支持reversed()操作。

*** OrderedDict应用举例
    由于可记录元素顺序，可利用sorted将字典转换为排序版本：
    
    #+BEGIN_SRC python :session
      from collections import OrderedDict
      d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2}

      # 按key排序
      OrderedDict(sorted(d.items(), key=lambda x: x[0]))
      # 按value排序
      OrderedDict(sorted(d.items(), key=lambda x: x[1]))
      # 按key字符串的长度排序
      OrderedDict(sorted(d.items(), key=lambda x: len(x[0])))
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> ... OrderedDict([('apple', 4), ('banana', 3), ('orange', 2), ('pear', 1)])
    - ... OrderedDict([('pear', 1), ('orange', 2), ('banana', 3), ('apple', 4)])
    - ... OrderedDict([('pear', 1), ('apple', 4), ('orange', 2), ('banana', 3)])
    #+END_SRC
    
    当key被删除后，其他key的顺序保持不变；当新增key时，添加到末尾，会
    破坏顺序。
    
    通过子类可实现：插入key时，不管是否已存在，将其添加到最后。

    #+BEGIN_SRC python :eval never
      from collections import OrderedDict
      class LastUpdatedOrderedDict(OrderedDict):
          '不管是否已存在，插入key时都添加到最后。'
          def __setitem__(self, key, value):
              if key in self:
                  del self[key]
              OrderedDict.__setitem__(self, key, value)
    #+END_SRC

    与Counter类一起使用，使Counter对象记录元素插入顺序：？？？

    #+BEGIN_SRC python :session
      from collections import Counter, OrderedDict

      class OrderedCounter(Counter, OrderedDict):
          def __repr__(self):
              return '{!s}({!r})'.format(self.__class__.__name__, OrderedDict(self))
          def __reduce__(self):
              return self.__class__, (OrderedDict(self),)

      x = OrderedCounter('mississippi')
      print(x)
      x.__reduce__()
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> ... ... ... ... ... >>> >>> >>> OrderedCounter(OrderedDict([('m', 1), ('i', 4), ('s', 4), ('p', 2)]))
    - (<class '__main__.OrderedCounter'>, (OrderedDict([('m', 1), ('i', 4), ('s', 4), ('p', 2)]),))
    #+END_SRC

** UserDict对象
   UserDict相当于普通字典的包装器。可通过子类声明的方法取代这个类型；
   不过UserDict对象上可使用data属性获取原来字典对象，使用起来更容易。
   
*** class collections. *UserDict* ([initial-data])
    模仿dict的类。实例内容保存在普通字典内，可通过data属性获取。如果
    有INITIAL-DATA参数，则data属性初始化为该值。

    *注意* ：不会保存INITIAL-DATA的指针，使其可用于其他操作。
    
    #+BEGIN_SRC python :session
      from collections import UserDict

      d = {'a': [1, 2, 3], 'b': 'ABC'}
      ud = UserDict(d)
      print(ud)

      # 更改通过指针传递的value会改变原来对象
      ud['a'].append(4)
      print(d)

      # 添加键值对不会改变原来对象
      ud['c'] = 'XYZ'
      print(ud)
      print(d)

      d['Z'] = 'abc'
      print(ud)

    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> >>> {'b': 'ABC', 'a': [1, 2, 3]}
    - >>> ... >>> {'b': 'ABC', 'a': [1, 2, 3, 4]}
    - >>> ... >>> {'c': 'XYZ', 'b': 'ABC', 'a': [1, 2, 3, 4]}
    - {'b': 'ABC', 'a': [1, 2, 3, 4]}
    - >>> >>> >>> {'c': 'XYZ', 'b': 'ABC', 'a': [1, 2, 3, 4]}
    #+END_SRC
    
    除普通的字典操作外，UserDict对象还添加了data属性：

**** data
     用于存储UserDict内容的真正字典。

** UserList对象 （待续）
** UserString对象 （待续）
* collections.abc - 容器类型抽象基础类（Abstract Base Classes for Containers）
  此模块提供的所有抽象类可用于检测特点类是否提供某个接口。比如是否可哈
  希或是否是映射对象：
  
  #+BEGIN_SRC python :session
    from collections import abc
    isinstance(1, abc.Hashable)
    isinstance({'a': 1}, abc.Mapping)
    isinstance(1, abc.Mapping)
  #+END_SRC
  
  #+RESULTS:
  #+BEGIN_SRC org
  - True
  - True
  - False
  #+END_SRC
  
** 抽象类
   下表为abc模块提供的所有抽象类：
   
   | ABC             | 继承自          | 抽象方法                 | 混入方法                                            |
   |-----------------+-----------------+--------------------------+-----------------------------------------------------|
   | Container       |                 | __contains__             |                                                     |
   | Hashable        |                 | __hash__                 |                                                     |
   | Iterable        |                 | __iter__                 |                                                     |
   | Iterator        | Iterable        | __next__                 | __iter__                                            |
   | Generator       | Iterator        | send,throw               | close,__iter__,__next__                             |
   | Sized           |                 | __len__                  |                                                     |
   | Callable        |                 | __call__                 |                                                     |
   | Sequence        | Sized,Iterable, | __getitem__,__len__      | __contains__,__iter__,__reversed__,index和count     |
   |                 | Container       |                          |                                                     |
   | MutableSequence | Sequence        | __getitem__,__setitem__  | 所有Sequence混入的方法，再加上：                    |
   |                 |                 | __delitem__,__len__      | append,reverse,extend,pop,remove和__iadd__          |
   |                 |                 | insert                   |                                                     |
   | ByteString      | Sequence        | __getitem__,__len__      | 所有Sequence混入的方法，再加上                      |
   | Set             | Sized,Iterable, | __contains__,__iter__,   | __le__,__lt__,__eq__,__ne__,__gt__,__ge__,          |
   |                 | Container       | __len__                  | __and__,__or__,__sub__,__xor__和isdisjoint          |
   | MutableSet      | Set             | __contains___,_iter__,   | 所有Set的混入方法，再加上：                         |
   |                 |                 | __len__,add和discard     | clear,pop,remove,__ior__,iand__,__ixor__,和__isub__ |
   | Mapping         | Sized,Iterable, | __getitem__,__iter__,    | __contains__,keys,items,values,get,__eq__和__ne__   |
   |                 | Container       | __len__                  |                                                     |
   | MutableMapping  | Mapping         | __getitem__,__setitem__, | 所有Mapping混入的方法，再加上：                     |
   |                 |                 | __delitem__,__iter__,    | pop,popitem,clear,update和setdefault                |
   |                 |                 | __len__                  |                                                     |
   | MappingView     | Sized           |                          | __len__                                             |
   | ItemsVies       | MappingView,Set |                          | __contains__,__iter__                               |
   | KeysView        | MappingView,Set |                          | __contains__,__iter__                               |
   | ValuesView      | MappingView     |                          | __contains__,__iter__                               |
   | Awaitable       |                 | __await__                |                                                     |
   | Coroutine       | Awaitable       | send,throw               | close                                               |
   | AsyncIterable   |                 | __aiter__                |                                                     |
   | AsyncIterator   | AsyncIterable   | __anext__                | __aiter__                                           |
   
   #+BEGIN_QUOTE
   *？* ：新建类时，是否只要继承自ABC，手动实现所有“抽象方法”，就会自
   动添加“混入方法”。
   #+END_QUOTE
   
*** class collections.abc. *Container*
*** class collections.abc. *Hashable*
*** class collections.abc. *Sized*
*** class collections.abc. *Callable*

    #+BEGIN_SRC python :session
      from collections import abc

      class ListCallable(abc.Callable, abc.Sequence):
          def __init__(self, iterable):
              self.elements = lst = []
              for x in iterable:
                  lst.append(x)
          def __call__(self, index):
              return self.elements[index]
          def __getitem__(self, index):
              return self.__call__(index)
          def __len__(self):
              return len(self.elements)

      l = ListCallable('abcefabd')
      # 利用__call__，使用函数方式获取元素
      l(1)
      # 利用自动混入的__contains__方法判断元素包含
      'e' in l
      # 利用自动混入的__iter__方法历遍
      for x in l:
          print(x, end=' ')

      print()
      # 利用自动混入的__reversed__方法逆序
      list(reversed(l))
      # 利用自动混入的index和count操作支持
      l.index('b')
      l.count('b')
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> ... ... ... ... ... ... ... ... ... ... ... >>> >>> >>> ... 'b'
    - ... True
    - ... ... ... a b c e f a b d >>>
    - ... ['d', 'b', 'a', 'f', 'e', 'c', 'b', 'a']
    - ... 1
    - 2
    #+END_SRC
*** 待续
** 举例

   #+BEGIN_SRC python :session
     from collections import abc

     class ListBasedSet(abc.Set):
         def __init__(self, iterable):
             self.elements = lst = []
             for value in iterable:
                 if value not in lst:
                     lst.append(value)
         def __iter__(self):
             return iter(self.elements)
         def __contains__(self, value):
             return value in self.elements
         def __len__(self):
             return len(self.elements)

     ls1 = ListBasedSet('mississippi')
     ls2 = ListBasedSet('miss')
     print(list(ls1))
     print(list(ls1 & ls2))
     print(list(ls1 | ls2))
   #+END_SRC

   #+RESULTS:
   #+BEGIN_SRC org
   - >>> >>> ... ... ... ... ... ... ... ... ... ... ... ... >>> >>> >>> >>> ['m', 'i', 's', 'p']
   - ['m', 'i', 's']
   - ['m', 'i', 's', 'p']
   #+END_SRC

* heapq - 堆排序算法
  此模块提供“优先队列（Priority Queue）”算法实现。
  
  在二叉树堆上，所有父节点的值都<=其子节点的值。此实现使用数组，且任意
  索引为k的元素，都有heap[k] <= heap[2*k+1]，且heap[k] <= heap[2*k+2]。
  为方便比较，任何不存在的元素当做无穷大。整个堆上最小的元素为根节点，
  即heap[0]。
  
  初始化二叉树堆可使用[]，或将链表参数传递给heapify()函数。
  
  #+BEGIN_SRC python :session
    import heapq
    lst = [9, 1, 3]
    heapq.heapify(lst)
    for i in range(3):
        print(heapq.heappop(lst))
  #+END_SRC
  
  #+RESULTS:
  #+BEGIN_SRC org
  - >>> >>> ... ... 1
  - 3
  - 9
  #+END_SRC
  
** 函数
*** heapq. *heappush* (heap,item)
    向堆上添加元素，保持排序顺序不变。

    #+BEGIN_SRC python :session
      import heapq
      lst = [9, 1, 3]
      heapq.heapify(lst)
      print(lst)
      heapq.heappush(lst, 2)
      print(lst)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> [1, 9, 3]
    - >>> [1, 2, 3, 9]
    #+END_SRC

*** heapq. *heappop* (heap)
    Pop并返回HEAP上最下的元素，保证排序顺序不变。如果HEAP为空，则抛出
    IndexError错误。如需获取最小元素而不Pop，可使用heap[0]：
    
    #+BEGIN_SRC python :session
      from heapq import *
      lst = [2, 21, 3, 2, 1, 3, 243, 24]
      heapify(lst)
      lst[0] == heappop(lst) == 1
      print(lst)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> True
    - [2, 2, 3, 24, 21, 3, 243]
    #+END_SRC

*** heapq. *heappushpop* (heap,item)
    先将ITEM push到堆上，再返回堆上最下的元素。比先使用heappush()再使用
    heappop()效率高。
    
    #+BEGIN_SRC python :session
      from heapq import *
      lst = [12, 123, 12, 23, 1, 1, 2]
      heapify(lst)
      heappushpop(lst, 100)
      print(lst)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> 1
    - [1, 23, 2, 100, 123, 12, 12]
    #+END_SRC

*** heapq. *heapify* (x)
    将链表直接转换为二叉树堆。耗时为线性增长。

*** heapq. *heapreplace* (heap,item)
    先Pop并返回最小值元素，再添加ITEM。整个堆的元素个数不变，如果堆为空，
    抛出IndexError错误。

    比先使用heappop()，再使用heappush()效率高，适合于定长堆。

    返回值可能比ITEM大，如需返回值小于ITEM，可使用heappushpop()。
    
    #+BEGIN_SRC python :session
      from heapq import *
      lst = [3, 23, 23, 4, 3]
      heapify(lst)
      heapreplace(lst, 1)
      print(lst)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> 3
    - [1, 3, 23, 4, 23]
    #+END_SRC

*** 通用函数
    此模块还提供了下面3个基于二叉树堆的通用函数：
    
**** heapq. *merge* (*iterables,key=None,reverse=False)
     将已排序好的*ITERABLES排序为单个iterator，并返回。

     类似于sorted(itertools.chain(*iterables))，但并不会一下将所有数据
     拉入内存，且假定所有ITERABLES都已排序好。

     KEY参数指定比较函数，必须为关键字参数。

     REVERSE参数为布尔值，假定*ITERABLES是否本来为逆序排列。
     
     #+BEGIN_SRC python :session
       from heapq import merge
       x = merge((1, 2, 3), b'abc', [100, 200, 300])
       print(list(x))
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> [1, 2, 3, 97, 98, 99, 100, 200, 300]
     #+END_SRC

**** heapq. *nlargest* (n,iterable,key=None)
     将ITERABLE中最小的N个元素组成链表返回。KEY为比较函数。
     key=str.lower时，等价于sorted(iterable,key=key,revese=True)[:n]。
     
     #+BEGIN_SRC python :session
       from heapq import nlargest
       nlargest(2, [2123, 12, 22, 222222])
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - [222222, 2123]
     #+END_SRC
     
**** heapq. *nsmallest* (n,iterable,key=None)
     与nlargest用法相同。
     
     #+BEGIN_SRC python :session
       from heapq import nsmallest
       nsmallest(2, [122, 12, 2, 12, 121, 1])
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - [1, 2]
     #+END_SRC
     
     nlargest和nsmallest函数只有在N值较小时性能最佳。如果元素过多，使
     用sorted()函数性能更佳。如果N为1，使用min()和max()函数性能最佳。
     如果需重复使用者两个函数，可尝试将ITERABLE转换为整整的二叉树堆。
     
** 基本示例
   利用heapq排序，可现将元素历遍添加到heap上，然后再使用heappop从最小
   的元素逐个取出：
   
   #+BEGIN_SRC python :session
     import heapq

     def heapsort(iterable):
         h = []
         for value in iterable:
             heapq.heappush(h, value)
         return [heapq.heappop(h) for i in range(len(h))]

     heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])
   #+END_SRC

   #+RESULTS:
   #+BEGIN_SRC org
   - >>> >>> ... ... ... ... ... >>> >>> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
   #+END_SRC

   与sorted(iterable)类似，但实现并不稳定。？？？

   元素可为元组，因此可用来比较权限值，并附带记录信息：

   #+BEGIN_SRC python :session
     from heapq import heappush, heappop
     h = []
     heappush(h, (5, '写代码'))
     heappush(h, (7, '发布产品'))
     heappush(h, (1, '编写规范'))
     heappush(h, (3, '创建测试'))
     heappop(h)
   #+END_SRC

   #+RESULTS:
   #+BEGIN_SRC org
   - >>> >>> >>> >>> >>> (1, '编写规范')
   #+END_SRC

** 优先队列（Priority Queue）实现注意点（待续）
** 原理 （待续）
* bisect - 数组二分查找算法
  利用此模块可实现每次插入元素时都不破坏链表排序。对于元素量大，元素间
  比较消耗大的链表，可大大提高效率。
  
  模块名为bisect的原因为采用了二分查找算法。[[https://hg.python.org/cpython/file/3.5/Lib/bisect.py][模块源码]] 可作为此算法的例
  子。
** 函数
*** bisect. *bisect_left* (a,x,lo=0,hi=len(a))
    返回假定在A中插入X元素并保持排序的索引。LO和HI参数用于指定链表A的
    计算区域，默认为整个链表。如果X已经在A中，则返回该元素前面一个索引。
    返回值可用于list.insert()方法。

    对于返回索引值i，都有：

    #+BEGIN_SRC python :eval never
      all(val < x for val in a[lo:i])
      all(val >= x for val in a[i:hi])
    #+END_SRC

*** bisect. *bisect_right* (a,x,lo=0,hi=len(a))
*** bisect. *bisect* (a,x,lo=0,hi=len(a))
    类似与bisect_left，不过当A中存在元素X时，返回该元素后面一个索引。

    对于返回索引值，都有：

    #+BEGIN_SRC python :eval never
      all(val <= x for val in a[lo:i])
      all(val > x for val in a[i:hi])
    #+END_SRC

    #+BEGIN_SRC python :session
      from bisect import *
      lst = [1, 2, 3]
      x = 2
      bisect_left(lst, x)
      bisect_right(lst, x)
      bisect(lst, x)
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> 1
    - 2
    - 2
    #+END_SRC

*** bisect. *insort_left* (a,x,lo=0,hi=len(a))
    将X插入A中，保持排序不变。等价于：

    #+BEGIN_SRC python :eval never
      a.insert(bisect.bisect_left(a, x, lo, hi), x)
    #+END_SRC

*** bisect. *insort_right* (a,x,lo=0,hi=len(a))
*** bisect. *insort* (a,x,lo=0,hi=len(a))
    类似于isort_left，只是如果X存在与A中，则插入到原来元素的右边。

    #+BEGIN_SRC python :session
      from bisect import *
      data = [1, 2, 3]
      insort_left(data, 2)
      print(data)
      insort_right(data, 2)
      print(data)
      insort(data, 2)
      print(data)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> [1, 2, 2, 3]
    - >>> [1, 2, 2, 2, 3]
    - >>> [1, 2, 2, 2, 2, 3]
    #+END_SRC

** 在已排序链表中查找
   如需查找插入位置，上面的函数很有用，但完成常规搜索任务时用起来挺复
   杂。下面就利用这些函数实现了对已排序链表的搜索实现：
   
   #+BEGIN_SRC python :eval never
     def index(a, x):
         '定位最左边等于X的元素。'
         i = bisect_left(a, x)
         if i != len(a) and a[i] == x:
             return i
         raise ValueError

     def find_lt(a, x):
         '获取<X的最右边的元素。'
         i = bisect_left(a, x)
         if i != 0:
             return a[i - 1]
         raise ValueError

     def find_le(a, x):
         '获取<=X的最右边的元素。'
         i = bisect_right(a, x)
         if i != 0:
             return a[i - 1]
         raise ValueError

     def find_gt(a, x):
         '获取>X的最左边的元素。'
         i = bisect_right(a, x)
         if i != len(x):
             return a[i]
         raise ValueError

     def find_ge(a, x):
         '获取>=X最左边的元素。'
         i = bisect_left(a, x)
         if i != len(a):
             return a[i]
         raise ValueError
   #+END_SRC

** 其他例子
   根据得分判断等级：
   
   #+BEGIN_SRC python :session
     from bisect import bisect

     def grade(score, breakpoints=[60, 70, 80, 90], grade='FDCBA'):
         i = bisect(breakpoints, score)
         return grade[i]

     [grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]
   #+END_SRC
   
   #+RESULTS:
   #+BEGIN_SRC org
   - >>> ... ... ... >>> ['F', 'A', 'C', 'C', 'B', 'A', 'A']
   #+END_SRC
   
   为不影响实现效率，bisect模块的函数并不像sorted()函数一样可传递key和
   reverse参数。不过可提前计算出不同数据类型的key排序：
   
   #+BEGIN_SRC python :session
     from bisect import bisect_left as lt
     data = [('red', 5), ('blue', 1), ('yellow', 8), ('black', 0)]
     data.sort(key=lambda x: x[1])
     keys = [x[1] for x in data]
     data[lt(keys, 0)]
     data[lt(keys, 1)]
     data[lt(keys, 5)]
     data[lt(keys, 8)]
   #+END_SRC
   
   #+RESULTS:
   #+BEGIN_SRC org
   - >>> >>> >>> ('black', 0)
   - ('blue', 1)
   - ('red', 5)
   - ('yellow', 8)
   #+END_SRC
   
* array - 高效数字数组
  此模块为精简表示基本数据类型的数组：字符型、整型和浮点型。array类型
  与链表类型十分相似，只是存储其中的数据类型有约束。

  *注意* ：适用于链表的方法也适用于array。

  类型名以单个字母表示（与struct模块中，相同的格式字符含义相同；但最小值
  与struct中标准值不同）：

  | 类型字符串 | 对应C类型          | Python类型        | 最小byte数 | 注意点 |
  |------------+--------------------+-------------------+------------+--------|
  | b          | signed char        | int               |          1 |        |
  | B          | unsigned char      | int               |          1 |        |
  | u          | Py_UNICODE         | Unicode character |          2 | (1)    |
  | h          | short              | int               |          2 |        |
  | H          | unsigned short     | int               |          2 |        |
  | i          | int                | int               |          2 |        |
  | I          | unsigned int       | int               |          2 |        |
  | l          | long               | int               |          4 |        |
  | L          | unsigned long      | int               |          4 |        |
  | q          | long long          | int               |          8 | (2)    |
  | Q          | unsigned long long | int               |          8 | (2)    |
  | f          | float              | float             |          4 |        |
  | d          | double             | float             |          8 |        |

  注意点：

  1. 'u'类型代码将废除，不建议使用。
  2. 'q'和'Q'类型代码仅限的有效情况为：编译Python的C编译器支持C语言的
     “long long”类型，或Windows系统，或__int64。？？？

  各类型代码表示的真实值取值范围取决于C实现，可使用itemsize属性获取。

** 此模块定义的类型有
*** class array. *array* (typecode[,initializer])
    INITIALIZER参数可选，须为“类bytes对象”，或类型合适的iterable对象。

    如果数组元素类型与第一个参数（类型参数）不一致，则报错：

    #+BEGIN_SRC python :session
      import array
      a = array.array('l')
      b = array.array('i', [123, 456, 789])
      print(a)
      print(b)

      c = array.array('i', [1.2])
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> array('l')
    : array('i', [123, 456, 789])
    : >>> Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : TypeError: integer argument expected, got float

    INITIALIZER为“类bytes”对象：

    #+BEGIN_SRC python :session
      from array import array

      # bytes
      a = array('b', b'abc')
      print(a)

      # bytearray
      a = array('b', bytearray(b'abc'))
      print(a)

      # array.array
      a = array('b', a)
      print(a)

      # memoryview
    #+END_SRC
    
    #+RESULTS:
    :
    : >>> ... >>> array('b', [97, 98, 99])
    : >>> ... >>> array('b', [97, 98, 99])
    : >>> ... >>> array('b', [97, 98, 99])

    为类型合适的iterable对象：

    #+BEGIN_SRC python :session
      from array import array

      # range
      a = array('i', range(3))
      print(a)

      # 链表
      a = array('i', [1, 2, 3])
      print(a)

      # 元组
      a = array('i', (1, 2, 3))
      print(a)

      # set
      a = array('i', {1, 2, 3})
      print(a)

      # 字典
      a = array('i', {1: 'a', 2: 'b', 3: 'c'})
      print(a)

      # 字符串
      a = array('u', 'abc')
      print(a)
    #+END_SRC

    #+RESULTS:
    :
    : >>> ... >>> array('i', [0, 1, 2])
    : >>> ... >>> array('i', [1, 2, 3])
    : >>> ... >>> array('i', [1, 2, 3])
    : >>> ... >>> array('i', [1, 2, 3])
    : >>> ... >>> array('i', [1, 2, 3])
    : >>> ... >>> array('u', 'abc')

    如果INITIALIZER为链表，或字符串（'u'类型代码），实际上是调用了
    array的fromlist()、frombytes()或fromunicode()方法将新元素添加到数
    组中；如其它情况则是使用extend()方法将INITIALIZER中的元素添加到数
    组中。

** 此模块定义的方法有
*** array. *typecodes*
    返回所有可用的类型代码。

    #+BEGIN_SRC python :session
      import array
      array.typecodes
    #+END_SRC

    #+RESULTS:
    :
    : 'bBuhHiIlLqQfd'

*** array. *typecode*
    
    #+BEGIN_SRC python :session
      from array import array
      l = array('l')
      l.typecode
    #+END_SRC
    
    #+RESULTS:
    :
    : >>> 'l'
    
*** array. *itemsize*

    数组中单个元素所占byte数。

    #+BEGIN_SRC python :session
      from array import array

      a = array('b', b'abc')
      a.itemsize

      b = array('l', [1, 2, 3])
      b.itemsize
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> 1
    : >>> >>> 8

*** array. *append* (x)
    追加元素。

    #+BEGIN_SRC python :session
      from array import array

      a = array('i', [1, 2, 3])
      a.append(4)
      print(a)
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> >>> array('i', [1, 2, 3, 4])

*** array. *buffer_info* ()
    返回数组的内存地址，以及元素个数，可使用array.buffer_info()[1] *
    a.itemsize获取数组所在内存大小：

    #+BEGIN_SRC python :session
      from array import array

      a = array('d', range(3))
      print(a)
      print(a.buffer_info())
      a.buffer_info()[1] * a.itemsize
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> array('d', [0.0, 1.0, 2.0])
    : (93900589887952, 3)
    : 24

    *注意* ：此方法为向后兼容方法，不建议使用。

    如需获取内存大小，可使用len函数：

    #+BEGIN_SRC python :session
      from array import array

      a = array('l', [1, 2, 3])
      len(a) * a.itemsize
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> 24

*** array. *byteswap* () ？？？
    对数组中内个元素进行byte交换。即最低位byte与最高位交换，倒数第2位
    byte与第二位交换。？？？

    #+BEGIN_SRC python :session
      from array import array

      a = array('i', [255])
      print(a)

      a.byteswap()
      print(a)

      bin(255)
      bin(-1677216)
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> array('i', [255])
    : >>> >>> array('i', [-16777216])
    : >>> '0b11111111'
    : '-0b110011001011110100000'

    *？* ：不知道有啥卵用。
    [[http://stackoverflow.com/questions/27506474/how-to-byte-swap-a-32-bit-integer-in-python]]

*** array. *count* (x)
    返回数组中X的个数。

    #+BEGIN_SRC python :session
      from array import array
      a = array('i', [1, 2, 1, 2, 1])
      a.count(1)
      a.count(10)
    #+END_SRC

    #+RESULTS:
    :
    : >>> 3
    : 0

*** array. *extend* (iterable)
    将ITERABLE中的内容追加到ARRAY后。如果ITERABLE也是数组，须有相同的
    类型代码；如果不为数组，则其元素类型必须适合原数组。

    #+BEGIN_SRC python :session
      from array import array
      a = array('i', [1, 2, 3])
      a.extend([4, 5, 6, 7, 8])
      print(a)
      print(a.typecode, a.itemsize)
      a.extend(array('i', [9, 10]))
      print(a)
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> array('i', [1, 2, 3, 4, 5, 6, 7, 8])
    : i 4
    : >>> array('i', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

*** array. *frombytes* (s)
    与fromfile方法相似，只是将将字符串的所有内容读入数组中。

    #+BEGIN_SRC python :session
      from array import array
      a = array('B', [100])
      a.frombytes(b'abcdef')
      print(a)
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> array('B', [100, 97, 98, 99, 100, 101, 102])

*** array. *fromfile* (f, n)
    从文件对象F中逐个读取N个数组中元素大小一样的对象，添加到数组后。

    如果F中的内容不足，会返回EOFError错误，不过会将所有能读取的内容读
    取到数组中。

    *注意* ：F须以二进制形式访问。F须为真实的内置文件对象。

    #+BEGIN_EXAMPLE emma.txt
      a b c d e f g h i j k l m n o p q r s t u v w x y z
    #+END_EXAMPLE

    #+BEGIN_SRC python :eval never
      from array import array

      a = array('b')

      with open('files/emma.txt', 'br') as fp:
          a.fromfile(fp, 10)
          print(a)
          a.fromfile(fp, 100)
          print(a)

      print(a)
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> >>> >>> ... ... ... ... ... array('b', [97, 32, 98, 32, 99, 32, 100, 32, 101, 32])
    : Traceback (most recent call last):
    :   File "<stdin>", line 4, in <module>
    : EOFError: read() didn't return enough bytes
    : array('b', [97, 32, 98, 32, 99, 32, 100, 32, 101, 32, 102, 32, 103, 32, 104, 32, 105, 32, 106, 32, 107, 32, 108, 32, 109, 32, 110, 32, 111, 32, 112, 32, 113, 32, 114, 32, 115, 32, 116, 32, 117, 32, 118, 32, 119, 32, 120, 32, 121, 32, 122, 10])

*** array. *fromlist* (list)
    将链表LIST中的元素逐个添加到ARRAY末尾。相当于：

    #+BEGIN_SRC python :eval never
      for x in list:
          a.append(x)
    #+END_SRC

    #+BEGIN_SRC python :session
      from array import array
      a = array('i', [1, 2, 3])
      b = array('i', [1, 2, 3])

      a.fromlist([4, 5, 6])
      for i in [4, 5, 6]:
          b.append(i)

      print(a)
      print(b)
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> >>> >>> ... ... >>> array('i', [1, 2, 3, 4, 5, 6])
    : array('i', [1, 2, 3, 4, 5, 6])

*** array. *fromstring* ()
    已废弃。改名为frombytes。
*** array. *fromunicode* (s)
    将Unicode字符串中的数据添加到数组后，数组必须为'u'类型数组，否则会
    返回ValueError错误。

    #+BEGIN_SRC python :session
      from array import array
      a = array('u', 'abc')
      a.fromunicode('def一')
      print(a)

      # 不为'u'类型数组
      b = array('i', [1, 2, 3])
      b.fromunicode('abc')
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> array('u', 'abcdef一')
    : >>> >>> Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : ValueError: fromunicode() may only be called on unicode type arrays

*** array. *index* (x)
    返回ARRAY中最先出现X的索引，如果不含X，则返回ValueError错误。

    #+BEGIN_SRC python :session
      from array import array
      a = array('b', b'abc')
      a.index(98)
      print(a)
      a.index(100)
    #+END_SRC

    #+RESULTS:
    :
    : >>> 1
    : array('b', [97, 98, 99])
    : >>> Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : ValueError: array.index(x): x not in list

*** array. *insert* (i, x)
    将X添加到数组索引I前，如果大于最大索引添加到最后，如果为负数则相对
    于最后一个元素索引。

    #+BEGIN_SRC python :session
      from array import array

      a = array('i', [1, 2, 3])
      a.insert(0, 100)
      print(a)

      # 大于最大索引
      a.insert(100, 0)
      print(a)

      # 负数
      a.insert(-1, -100)              # ？？？
      print(a)
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> >>> array('i', [100, 1, 2, 3])
    : >>> ... >>> array('i', [100, 1, 2, 3, 0])
    : >>> ... >>> array('i', [100, 1, 2, 3, -100, 0])

*** array. *pop* ([i])
    索引为I的元素从数组中移除，并返回被移除的元素。I默认为-1，即移除最
    后一个元素。

    #+BEGIN_SRC python :session
      from array import array
      a = array('i', [1, 2, 3])
      a.pop()
      print(a)

      a.pop(0)
      print(a)

      for i in range(10):
          a.pop()
    #+END_SRC

    #+RESULTS:
    :
    : >>> 3
    : array('i', [1, 2])
    : >>> 1
    : array('i', [2])
    : >>> ... ... 2
    : Traceback (most recent call last):
    :   File "<stdin>", line 2, in <module>
    : IndexError: pop from empty array

*** array. *remove* (x)
    删除数组中第一个X元素，如果无，则返回ValueError错误。

    #+BEGIN_SRC python :session
      from array import array

      a = array('i', [1, 10, 1, 20])
      a.remove(1)
      print(a)

      a.remove(1000)
      print(a)
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> >>> array('i', [10, 1, 20])
    : >>> Traceback (most recent call last):
    :   File "<stdin>", line 1, in <module>
    : ValueError: array.remove(x): x not in list
    : array('i', [10, 1, 20])

*** array. *reverse* ()
    将数组中所有元素所有元素逆序。

    #+BEGIN_SRC python :session
      from array import array

      a = array('i', [1, 2, 3])
      a.reverse()
      print(a)
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> >>> array('i', [3, 2, 1])

*** array. *tobytes* ()
    将数组中的元素转换为byte表示。

    #+BEGIN_SRC python :session
      from array import array

      a = array('b', [1, 2, 3])
      a.tobytes()
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> b'\x01\x02\x03'

*** array. *tofile* ()
    与tobytes方法相似，只是将内容写入文件。

    #+BEGIN_SRC python :eval never
      from array import array

      a = array('b', b'abcd\ne\n')

      with open('files/emma.txt', 'wb') as fp:
          a.tofile(fp)
    #+END_SRC

*** array. *tolist* ()
    将数组转换为普通链表。
    
    #+BEGIN_SRC python :session
      from array import array

      a = array('i', [1, 2, 3])
      a.tolist()
    #+END_SRC

    #+RESULTS:
    :
    : >>> >>> [1, 2, 3]

*** array. *tostring* ()
    已废除，新名为tobytes()。

    #+BEGIN_SRC python :session
      from array import array
      a = array('i', [1, 2, 3])
      a.tostring()
    #+END_SRC

    #+RESULTS:
    :
    : >>> b'\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'

*** array. *tounicode* ()
    将数组转换为Unicode字符串，数组的类型代码须为'u'，否则返回
    ValueError错误。

    #+BEGIN_SRC python :session
      from array import array
      a = array('u', '我有一个梦想！')
      a.tounicode()
    #+END_SRC

    #+RESULTS:
    :
    : >>> '我有一个梦想！'

* weakref
  
  [[http://stackoverflow.com/questions/1507566/how-and-when-to-appropriately-use-weakref-in-python]]
  
** 函数
*** class weakref. *ref* (object[,callback])
    
    #+BEGIN_SRC python :session
      from weakref import ref
      s = {1, 2, 3}
      s_ref = ref(s, lambda x: print(x, 'deleted'))
      print(s_ref)
      del s
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> <weakref at 0x7ff1f4bea318; to 'set' at 0x7ff1f4c5ef28>
    - <weakref at 0x7ff1f4bea318; dead> deleted
    #+END_SRC
    
**** __callback__
*** weakref. *proxy* (object[,callback])
** Weak Reference对象
** 举例
** Finalizer对象
** finalizers与__del__方法
* types - 内置类型动态创建和命名
* copy - 浅层复制和深层复制
* pprint - 数据美化显示
* reprlib - 另一个repr()实现
* enum - 枚举支持
