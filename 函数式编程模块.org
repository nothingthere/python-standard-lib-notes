# Author: Claudio <3261958605@qq.com>
# Created: 2017-05-06 21:13:47
# Commentary:
#+TITLE: 函数式编程模块

* itertools - 创建高效逆变iterator的函数
  - 返回无限循环iterator的函数：

    | 函数    | 参数         | 结果                                | 举例                               |
    |---------+--------------+-------------------------------------+------------------------------------|
    | count() | start[,step] | start,start+step, start+2*step,...  | count(10) --> 10 11 12 ...         |
    | cycle() | p            | p0,p1,...plast,p0,p1,...            | cycle('ABCD') --> A B C D A B C... |
    | repeat  | elem[,n]     | elem,elem,elem,...无限循环或循环N次 | repeat(10, 3) -> 10 10 10          |
    
  - 耗尽最短序列结束的函数：

    | 函数                  | 参数                   | 结果                                 | 举例                                                     |
    |-----------------------+------------------------+--------------------------------------+----------------------------------------------------------|
    | accumulate()          | p[,func]               | p0,p0+p1,p0+p1+p2,...                | accumulate([1,2,3]) --> 1 3 6                            |
    | chain()               | q,q...                 | p0,p1,...plast,q0,q1,...             | chain('ABC', 'DEF') --> A B C D E F                      |
    | chain.from_iterable() | iterable               | p0,p1,...q0,q1,...                   | chain.from_iterable(['ABC','DEF']) --> A B C D E F       |
    | compress()            | data,selectors         | (d[0] if s[0]),(d[1] if s[1]),...    | compress('ABCD', [1,0,1,0,1,1]) --> A C                  |
    | dropwhile()           | pred,seq               | seq[n],seq[n+1],从pred返回false开始  | dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1          |
    | filterfalse()         | pred,seq               | 过滤掉不满足pred的元素               | filterfalse(lambda x: x%2!=0, range(10)) --> 0 2 4 6 8   |
    | groupby()             | iterable[,keyfun]      | 按KEYFUN组成的子迭代器               |                                                          |
    | islice()              | seq,[start]stop[,step] | seq[start:stop:step]                 | islice('ABCDEFD', 2, None) -->  C D E F G                |
    | startmap()            | func,seq               | func(*seq[0]),func(*seq[1])...       | startmap(pow, [(2,5),[3,2],(10,3)]) --> 32 9 1000        |
    | takewhile()           | pred,seq               | seq[0],seq[1],...直到pred返回False   | tabewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4            |
    | tee()                 | it,n                   | it1,it2,..itn。将it分割为N给副本？？ |                                                          |
    | zip_longest()         | p,q...                 | (p0,q0), (p1,q1)                     | zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D- |
    
  - 排列组合式函数：
    
    | 函数                                     | 参数              | 结果                                            |
    |------------------------------------------+-------------------+-------------------------------------------------|
    | product()                                | p,q,...[repeat=1] | 笛卡尔乘积。等价于多个嵌套历遍                  |
    | permutations()                           | p[,r]             | R长度元组。所有可能顺序。无元素重复             |
    | combinations()                           | p,r               | R长度元组。按原来顺序。如元素重复               |
    | combinations_with_replacement()          | p,r               | R长度元组。按原来顺序。有元素重复               |
    | product('ABCD', repeat=2)                |                   | AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD |
    | permutations('ABCD', 2)                  |                   | AB AC AD BA BC BD CA CB CD DA DB DA             |
    | combinations('ABCD', 2)                  |                   | AB AC AD BC BD CD                               |
    | combinations_with_replacement('ABCD', 2) |                   | AA AB AC AD BB BC BD CC CD DD                   |
    
** itertool函数
   下面的模块函数都为构建并返回迭代器（iterators）。其中一些返回无限长
   度的stream，所以只可被截断stream的函数或循环体使用。

*** itertools. *accumulate* (iterable[,func])
    返回将元素逐个使用FUNC（默认为相加）操作结果组成的迭代器。如果提供
    FUNC参数，需为接受两个与ITERABLE中元素类型相同的参数，比如如果为默
    认的相加，则参数类型应为整数或浮点数，或其他接受可相加的对象。如果
    ITERABLE为空，则返回的迭代器也为空。

    #+BEGIN_SRC python :session
      from itertools import accumulate
      from operator import mul
      list(accumulate([1, 2, 3, 4, 5]))
      list(accumulate([1, 2, 3, 4, 5], mul))
      list(accumulate(['a', 'b', 'c']))
      list(accumulate([]))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> [1, 3, 6, 10, 15]
    - [1, 2, 6, 24, 120]
    - ['a', 'ab', 'abc']
    - []
    #+END_SRC

    基本上等价于：

    #+BEGIN_SRC python :session
      import operator
      def my_accumulate(iterable, func=operator.add):
          it = iter(iterable)
          try:
              total = next(it)
          except StopIteration:
              return
          yield total
          for element in it:
              total = func(total, element)
              yield total

      list(my_accumulate([1, 2, 3]))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - ... ... ... ... ... ... ... ... ... ... >>> [1, 3, 6]
    #+END_SRC

    FUNC的用法有多种，如：

    - min()和max()求最大/小值。

      #+BEGIN_SRC python :session
        from itertools import accumulate
        data = [2, 3, 4, 32, 3, 23, 2, 2, 3]
        list(accumulate(data, max))
        list(accumulate(data, min))
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> [2, 3, 4, 32, 32, 32, 32, 32, 32]
      - [2, 2, 2, 2, 2, 2, 2, 2, 2]
      #+END_SRC

    - 使用operator.mul迭代乘积：

      #+BEGIN_SRC python :session
        import operator
        list(accumulate(data, operator.mul))
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - [2, 6, 24, 768, 2304, 52992, 105984, 211968, 635904]
      #+END_SRC

    - 计算分期付款：

      #+BEGIN_SRC python :session
        cashflow = [1000, -90, -90, -90]
        list(accumulate(cashflow, lambda bal, pmt: bal * 1.05 + pmt))
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - [1000, 960.0, 918.0, 873.9000000000001]
      #+END_SRC

    - [[https://en.wikipedia.org/wiki/Recurrence_relation][recurrence relations]] ？？？

      #+BEGIN_SRC python :session
        from itertools import accumulate, repeat

        def logistic_map(x, _): return r * x * (1 - x)

        r, x0 = 3.8, 0.4
        inputs = repeat(x0, 36)
        [format(x, '.2f') for x in accumulate(inputs, logistic_map)]
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> ... >>> >>> >>> ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60']
      #+END_SRC

      functools.reduce()的原理相同，只是返回增量结果的最后一个值。

*** itertools. *chain* (*iterables)
    将ITERABLES中的每个迭代器中的每个元素逐个添加到新的迭代器中，直到
    消耗完毕，最后返回：

    #+BEGIN_SRC python :session
      from itertools import chain
      list(chain([1, 2, 3], 'abc', (100, 200)))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - [1, 2, 3, 'a', 'b', 'c', 100, 200]
    #+END_SRC

    基本上等价于：

    #+BEGIN_SRC python :eval never
      def my_chain(*iterables):
          for it in iterables:
              for element in it:
                  yield element
    #+END_SRC

*** classmethod chain. *from_iterable* (iterable)
    chain()的另一个构造器。从单个迭代参数中获取链式输入并“懒执行
    （evaluated lazily）”：

    #+BEGIN_SRC python :session
      from itertools import chain
      list(chain.from_iterable([[1, 2, 3], 'abc', (100, 200)]))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - [1, 2, 3, 'a', 'b', 'c', 100, 200]
    #+END_SRC

    基本上等价于：

    #+BEGIN_SRC python :eval never
      def from_iterable(iterables):
          for it in iterables:
              for element in it:
                  yield element
    #+END_SRC

*** itertools. *combinations* (iterable,r)
    返回ITERABLE中长度为R的子序列组成的迭代器，其中子序列为元组。

    结合按ITERABLE中元素的顺序进行。所以，如果ITERABLE以排序，则各元组
    也排序好。

    每个元素以其在ITERABLE中的位置区分，而非其值。所以，如果每个元素没
    有重复，则返回值中的每个元组中也没重复。

    #+BEGIN_SRC python :session
      from itertools import combinations
      list(combinations('abc', 2))
      list(combinations('abc', 3))

      list(combinations(range(4), 3))
      list(combinations(range(4), 4))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - [('a', 'b'), ('a', 'c'), ('b', 'c')]
    - [('a', 'b'), ('a', 'c'), ('b', 'a'), ('b', 'c'), ('c', 'a'), ('c', 'b')]
    - [('a', 'b', 'c')]
    - >>> [(0, 1, 2), (0, 1, 3), (0, 2, 3), (1, 2, 3)]
    - [(0, 1, 2, 3)]
    #+END_SRC

    基本上等价于：？？？

    #+BEGIN_SRC python :eval never
      def combinations(iterable, r):
          pool = tuple(iterable)
          n = len(pool)
          if r > n:
              return
          indices = list(range(r))
          yield tuple(pool[i] for i in indices)
          while True:
              for i in reversed(range(r)):
                  if indices[i] != i + n - r:
                      break
              else:
                  return
              indices[i] += 1
              for j in range(i + 1, r):
                  indices[j] = indices[j - 1] + 1
              yield tuple(pool[i] for i in indices)
    #+END_SRC

    也等价于去除permutations()结果中没按原来元素排序的元素：

    #+BEGIN_SRC python :session
      from itertools import combinations, permutations
      list(combinations('abc', 2))
      list(permutations('abc', 2))

      def my_combinations(iterable, r):
          pool = tuple(iterable)
          n = len(pool)
          for indices in permutations(range(n), r):
              if sorted(indices) == list(indices):
                  yield tuple(pool[i] for i in indices)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - [('a', 'b'), ('a', 'c'), ('b', 'c')]
    - [('a', 'b'), ('a', 'c'), ('b', 'a'), ('b', 'c'), ('c', 'a'), ('c', 'b')]
    #+END_SRC

*** itertools. *combinations_with_replacement* (iterable, r)
    返回ITERABLE长度为R的子序列，所有子序列都应按ITERABLE原来的顺序排
    列。与combinations()方法不同的是，自身元素可重复。
    
    #+BEGIN_SRC python :session
      from itertools import combinations_with_replacement
      list(combinations_with_replacement('abc', 2))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - [('a', 'a'), ('a', 'b'), ('a', 'c'), ('b', 'b'), ('b', 'c'), ('c', 'c')]
    #+END_SRC

    相当于自身重复R次笛卡尔乘积结果去除不按原来元素顺序排列的结果：

    #+BEGIN_SRC python :eval never
      from itertools import product

      def combinations_with_replacement(iterable, r):
          pool = tuple(iterable)
          n = len(pool)
          for indices in product(range(n), repeat=r):
              if sorted(indices) == list(indices):
                  yield tuple(pool[i] for i in indices)
    #+END_SRC

*** itertools. *compress* (data,selectors)
    返回DATA中的元素，只有元素在SELECTORS中对应位置的元素为True时才包
    含。直到DATA或SELECTORS中有一个的元素消耗完为止：

    #+BEGIN_SRC python :session
      from itertools import compress
      list(compress('ABCDEF', [1, 0, 1, 0, 1, 0, 1, 0, 1, 1]))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - ['A', 'C', 'E']
    #+END_SRC

    大致相当于：

    #+BEGIN_SRC python :eval never
      def compress(data, selectors):
          return (d for d, s in zip(data, selectors) if s)
    #+END_SRC

*** itertools. *count* (star=0,step=1)
    返回以START开始，步数为STEP的数字迭代器。可迭代出无限个数字。可为
    浮点数。

    #+BEGIN_SRC python :session
      from itertools import count
      cnt = count(step=10)
      for i in range(10):
          print(next(cnt), end=' ')

      print()
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> ... ... 0 10 20 30 40 50 60 70 80 90 >>>
    #+END_SRC

    大致等价于：

    #+BEGIN_SRC python :eval never
      def count(start=0, step=1):
          n = start
          while True:
              yield n
              n += step
    #+END_SRC

*** itertools. *cycle* (iterable)
    将ITERABLE模仿为循环结构：

    #+BEGIN_SRC python :session
      from itertools import cycle
      c = cycle('abc')
      for i in range(10):
          print(next(c), end=' ')

      print()
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> ... ... a b c a b c a b c a >>>
    #+END_SRC

    *注意* ：很耗内存。

*** itertools. *dropwhile* (predicate,iterable)
    从左到右去除ITERABLE中元素，直到PREDICT调用为True。
    
    *注意* ： 直到找到为False的值或ITERABLE耗尽时才返回，所以会有等待。
    
    #+BEGIN_SRC python :session
      from itertools import dropwhile, takewhile
      lst = [1, 4, 6, 7, 1]
      list(dropwhile(lambda x: x < 6, lst))
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> [6, 7, 1]
    #+END_SRC
    
    大致相当于：
    
    #+BEGIN_SRC python :eval never
      def dropwhile(predict, iterable):
          it = iter(iterable)
          for x in iterable:
              if not predict(x):
                  yield x
                  break
          for x in iterable:
              yield x
    #+END_SRC

*** itertools. *filterfalse* (predicate,iterable)
    过滤PREDICT调用ITERABLE中元素为False的元素，如果PREDICT为None，则
    为ITERABLE中元素为false的元素：

    #+BEGIN_SRC python :session
      from itertools import filterfalse
      list(filterfalse(lambda x: x % 2, range(10)))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - [0, 2, 4, 6, 8]
    #+END_SRC

    大致相当于：

    #+BEGIN_SRC python :eval never
      def filterfalse(predict, iterable):
          if predict is None:
              predict = bool
          for x in iterable:
              if not predict(x):
                  yield x
    #+END_SRC

*** itertools. *groupby* (iterable,key=None)
    返回迭代器中的每个元素元组第一个元素为ITERABLE的一个元素，第二个元
    素为该元素相邻请调用KEY参数与第一个元素值相同元素组成的迭代器。如
    果KEY为None，相当于“lambda x: x”。
    
    通常情况下，应该相对于KEY已经排序好。类似于Unix的uniq命令。
    
    #+BEGIN_SRC python :session
      from itertools import groupby
      data = 'AAABBBXXDAABB'
      # data = ''.join(sorted(list(data), key=lambda x: x.lower()))
      # print(list(groupby(data)))
      [k for k, g in groupby(data)]
      [list(g) for k, g in groupby(data)]
      list(groupby(data))
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> ... <itertools.groupby object at 0x7f3ab90bb3b8>
    - ['A', 'B', 'X', 'D', 'A', 'B']
    - [['A', 'A', 'A'], ['B', 'B', 'B'], ['X', 'X'], ['D'], ['A', 'A'], ['B', 'B']]
    - [('A', <itertools._grouper object at 0x7f3ab90bd198>), ('B', <itertools._grouper object at 0x7f3ab90bd080>), ('X', <itertools._grouper object at 0x7f3ab90bd160>), ('D', <itertools._grouper object at 0x7f3ab90bd0b8>), ('A', <itertools._grouper object at 0x7f3ab90bd1d0>), ('B', <itertools._grouper object at 0x7f3ab90bd208>)]
    #+END_SRC
    
*** itertools. *islice* (iterable,stop)
*** itertools. *islice* (iterable,start,stop[,step])
    类似于range的用法，不过各个参数都不能为负数。

    如果START为None，默认为0,；如果STEP为None，默认为1；如果STOP为None，
    直到消耗完整个ITERABLE。

    #+BEGIN_SRC python :session
      from itertools import islice

      data = 'ABCDEFG'
      list(islice(data, 2))
      list(islice(data, 2, 4))
      list(islice(data, 0, None, 2))
      list(islice(data, 2, None))
      list(islice(data, 0, None, 2))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> ['A', 'B']
    - ['C', 'D']
    - ['A', 'C', 'E', 'G']
    - ['C', 'D', 'E', 'F', 'G']
    - ['A', 'C', 'E', 'G']
    #+END_SRC

*** itertools. *permutation* (iterable,r=None)
    返回ITERABLE中长度为R的所有排列组合方式组成的迭代器，其中每个元素
    为元素。如果R为None，则所有元素长度都与ITERABLE长度相同。

    结合按ITERABLE中元素的顺序进行。所以，如果ITERABLE以排序，则各元组
    也排序好。

    每个元素以其在ITERABLE中的位置区分，而非其值。所以，如果每个元素没
    有重复，则返回值中的每个元组中也没重复。

    #+BEGIN_SRC python :session
      from itertools import permutations
      list(permutations('abc', 2))
      list(permutations('abc'))
      list(permutations(range(3)))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - [('a', 'b'), ('a', 'c'), ('b', 'a'), ('b', 'c'), ('c', 'a'), ('c', 'b')]
    - [('a', 'b', 'c'), ('a', 'c', 'b'), ('b', 'a', 'c'), ('b', 'c', 'a'), ('c', 'a', 'b'), ('c', 'b', 'a')]
    - [(0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0), (2, 0, 1), (2, 1, 0)]
    #+END_SRC

*** itertools. *product* (*iterables,repeat=1)
    返回ITERABLES中元素 [[http://baike.baidu.com/item/%25E7%25AC%259B%25E5%258D%25A1%25E5%25B0%2594%25E4%25B9%2598%25E7%25A7%25AF][笛卡尔乘积]] 的组合形式。每个元素为元组。如果要
    返回ITERABLE自身的笛卡尔乘积，可使用REPEAT参数。大致相当于：

    #+BEGIN_SRC python :eval never
      ((x, y) for x in A y in B)
    #+END_SRC

    如：

    #+BEGIN_SRC python :session
      from itertools import product
      list(product('ABCD', 'xy'))
      list(product(range(2), repeat=2))
      list(product('A', repeat=4))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - [('A', 'x'), ('A', 'y'), ('B', 'x'), ('B', 'y'), ('C', 'x'), ('C', 'y'), ('D', 'x'), ('D', 'y')]
    - [(0, 0), (0, 1), (1, 0), (1, 1)]
    - [('A', 'A', 'A', 'A')]
    #+END_SRC

    再如打印九九乘法表：

    #+BEGIN_SRC python :session
      from itertools import product
      from functools import reduce
      from operator import mul

      num = range(1, 10)
      mul_table = product(num, num)

      for pair in mul_table:
          print(format(reduce(mul, pair), '3d'), end=' ')
          if(pair[1] % 9 == 0):
              print()
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> >>> >>> >>> >>> ... ... ... ...   1   2   3   4   5   6   7   8   9
    -   2   4   6   8  10  12  14  16  18
    -   3   6   9  12  15  18  21  24  27
    -   4   8  12  16  20  24  28  32  36
    -   5  10  15  20  25  30  35  40  45
    -   6  12  18  24  30  36  42  48  54
    -   7  14  21  28  35  42  49  56  63
    -   8  16  24  32  40  48  56  64  72
    -   9  18  27  36  45  54  63  72  81
    #+END_SRC

    大致相当于：

    #+BEGIN_SRC python :eval never
      def product(*args, repeat=1):
          pools = [tuple(pool) for pool in args] * repeat
          result = [[]]
          for pool in pools:
              result = [x + [y] for x in result for y in pool]
          for prod in result:
              yield tuple(prod)
    #+END_SRC

*** itertools. *repeat* (object[,times])
    返回迭代对象，不断重复OBJECT。如果有参数TIMES，则重复TIMES次。常与
    map和zip函数一起使用：
    
    #+BEGIN_SRC python :session
      from itertools import repeat
      list(map(pow, range(10), repeat(2)))
      list(map(pow, range(10), repeat(2, 2)))
      list(zip(range(10), repeat(pow)))
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
    - [0, 1]
    - [(0, <built-in function pow>), (1, <built-in function pow>), (2, <built-in function pow>), (3, <built-in function pow>), (4, <built-in function pow>), (5, <built-in function pow>), (6, <built-in function pow>), (7, <built-in function pow>), (8, <built-in function pow>), (9, <built-in function pow>)]
    #+END_SRC
    
    大致相当于：
    
    #+BEGIN_SRC python :eval never
      def repeat(object, times=None):
          if times is None:
              while True:
                  yield object
              else:
                  for i in times:
                      yield object
    #+END_SRC
    
    *注意* ：执行list(repeat(1))足够让机器卡死。！！！
    
*** itertools. *startmap* (function,iterable)
    与map的区别为：

    1. 只能有ITERABLE一个迭代器。
    2. FUNCTION的参数为ITERABLE中每个元素的元素个数一样。

    #+BEGIN_SRC python :session
      from itertools import starmap
      list(starmap(pow, [(2, 5), (3, 2), (10, 3)]))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - [32, 9, 1000]
    #+END_SRC

*** itertools. *takewhile* (predicate,iterable)
    返回迭代器中包含PREDICT调用每个元素直到返回False的元素。

    #+BEGIN_SRC python :session
      from itertools import dropwhile, takewhile
      lst = [1, 4, 6, 7, 8]

      def predict(x): return x < 5

      list(takewhile(predict, lst))
      list(dropwhile(predict, lst))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> ... >>> [1, 4]
    - [6, 7, 8]
    #+END_SRC

*** itertools. *tee* (iterable,n=2)？？？
    使用ITERABLE生成N个独立的迭代器。
    
    #+BEGIN_SRC python :session
      from itertools import tee
      data = [1, 2, 3, 4, 2, 3]
      x, y = tee(data, 2)
      print(list(x))
      print(list(y))
      data[-1]=100
      print(list(x))
      print(list(y))
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> [1, 2, 3, 4, 2, 3]
    - [1, 2, 3, 4, 2, 3]
    - >>> []
    - []
    #+END_SRC

*** itertools. *zip_longest* (*iterables,fillvalue=None)
    与zip()的区别为：直到消耗完最长的ITERABLE，长度不够的使用FILLVALUE
    代替。

    #+BEGIN_SRC python :session
      from itertools import zip_longest, repeat

      list(zip_longest('abc', [1, 2, 3, 4]))
      list(zip('abc', [1, 2, 3, 4]))
      list(zip_longest('abc', [1, 2, 3, 4], fillvalue='Z'))
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> [('a', 1), ('b', 2), ('c', 3), (None, 4)]
    - [('a', 1), ('b', 2), ('c', 3)]
    - [('a', 1), ('b', 2), ('c', 3), ('Z', 4)]
    #+END_SRC

    *注意* ：

    如果其中一个iterable为无限结构，需限制调用次数，如使用islice或
    takewhile。不然将机器卡死。

    #+BEGIN_SRC python :session
      from itertools import repeat, zip_longest, islice
      x = zip_longest('abc', repeat(1))
      list(islice(x, 0, 10))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> [('a', 1), ('b', 1), ('c', 1), (None, 1), (None, 1), (None, 1), (None, 1), (None, 1), (None, 1), (None, 1)]
    #+END_SRC

** itertools用法举例
   下面的扩展工具具有相同的高性能。每次只处理一个元素，而不是将整个迭
   代对象一次抛到内存中，从而减少内存开销。每个函数代码量少，以此减少
   中间变量，并遵循了“函数式”风格。
   
* functools - 操作可调用对象的高阶函数
  此模块提供操作函数或返回函数的高阶函数。对此模块而言，任何可被调用的
  对象都可作函数对待。
  
** 函数
*** functools. *cmp_to_key* (func)
    将传统的比较函数（接受两个参数，返回大于、小于或等于0作为大小比较），
    转换为key函数（接受单个参数，使用返回值作比较）。

    将比较函数转换为key函数可基本实现为：

    #+BEGIN_SRC python :eval never
      def cmp_to_key(mycmp):
          'Convert a cmp= function into a key= function'
          class K:
              def __init__(self, obj, *args):
                  self.obj = obj

              def __lt__(self, other):
                  return mycmp(self.obj, other.obj) < 0

              def __gt__(self, other):
                  return mycmp(self.obj, other.obj) > 0

              def __eq__(self, other):
                  return mycmp(self.obj, other.obj) == 0

              def __le__(self, other):
                  return mycmp(self.obj, other.obj) <= 0

              def __ge__(self, other):
                  return mycmp(self.obj, other.obj) >= 0

              def __ne__(self, other):
                  return mycmp(self.obj, other.obj) != 0

          return K
    #+END_SRC
    
*** @functools. *lru_cache* (maxsize=128,typed=False)
    装饰器函数，用于缓存函数对象，缓存最近最多MAXSIZE大小的调用结果。
    一般使用在周期性多次调用同一参数的函数上，如fib函数和多次打开相同
    文件的函数。
    
    由于缓存结果用字典存储，所有被包装的函数参数都需为可哈希对象。
    
    当MAXSIZE参数为None时，可无限制缓存；当为2的次方数时，可发挥最佳的
    性能优化功能。
    
    如果TYPED参数为True，不同类型的参数会分开缓存，如f(3)和f(3.0)会区
    别对待。
    
    为帮助测试效率，调试MAXSIZE参数，被包装的函数被添加了cache_info()
    函数，返回named tuple类型，元素有hits、misses和currsize。在多线程
    环境下，hits和misses元素值只为近似值。
    
    被包装的函数可使用__wrapped__属性获得原函数。
    
    LRU（least recently used）缓存在随后调用可预测的情况下效果最佳。缓
    存的最大值会限制以免超出限度，比如在服务器上长时间运行的进程。
    
    比如缓存静态网页内容：
    
    #+BEGIN_SRC python :session
      import functools
      import urllib.error
      import urllib.request

      @functools.lru_cache(maxsize=32)
      def get_pep(num):
          resorce = 'http://www.python.org/dev/peps/pep-{:04}'.format(num)
          try:
              with urllib.request.urlopen(resorce) as s:
                  return s.read()
          except urllib.error.HTTPError:
              return 'Not Found'

      for n in 8, 290, 308, 320, 8, 218, 320, 279, 289, 320, 9991:
          pep = get_pep(n)
          print(n, len(pep))

      print(get_pep.cache_info())
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> >>> ... ... ... ... ... ... ... ... >>> ... ... ... 8 116713
    - 290 64288
    - 308 51317
    - 320 51820
    - 8 116713
    - 218 47839
    - 320 51820
    - 279 49780
    - 289 51829
    - 320 51820
    - 9991 9
    - CacheInfo(hits=3, misses=8, maxsize=32, currsize=8)
    #+END_SRC
    
    再比如为斐波那契函数添加缓存：
    
    #+BEGIN_SRC python :session
      from functools import lru_cache

      @lru_cache(maxsize=None)
      def fib(n):
          if n < 2:
              return n
          else:
              return fib(n - 1) + fib(n - 2)

      [fib(n) for n in range(16)]
      fib.cache_info()
    #+END_SRC
    
    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> ... ... ... ... ... ... >>> >>> [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]
    - CacheInfo(hits=28, misses=16, maxsize=None, currsize=16)
    #+END_SRC
    
*** @functools. *total_ordering*
*** functools. *partial* (func,*args,**keywords)
*** class functools. *partialmethod* (func,*args,**keywords)
*** functools. *reduce* (function,iterable[,initializer])
*** @functools. *singledispatch* (default)
*** functools. *update_wrapper* (wrapper,wrapped,assigned=WRAPPER_ASSIGNMENT,updated=WRAPPER_UPDATES)
*** @functools. *wraps* (wrapped,assignment=WRAPPER_ASSIGNMENTS,updated=WRAPPER_UPDATES)
** partial对象
*** partial. *func*
*** partial. *args*
*** partial. *keywords*
* operator - 使用标准操作符作为函数
  operator模块提供了一套与内置操作符对应的高效函数。如
  operator.__add__(x,y)等价于x+y。这些函数名同时也是类定义时可能会用到
  的特殊方法名；为方便使用，还是有对应无双下划线版本。

** 模块函数
*** 大小比较
    这些函数适用于所有类型比较。

**** operator. *lt* (a,b)
**** operator. *le* (a,b)
**** operator. *eq* (a,b)
**** operator. *ne* (a,b)
**** operator. *ge* (a,b)
**** operator. *gt* (a,b)
**** operator. *__lt__* (a,b)
**** operator. *__le__* (a,b)
**** operator. *__eq__* (a,b)
**** operator. *__ne__* (a,b)
**** operator. *__ge__* (a,b)
**** operator. *__gt__* (a,b)

     #+BEGIN_SRC python :session
       from operator import (lt, __lt__,
                             le, __le__,
                             eq, __eq__,
                             ne, __ne__,
                             ge, __ge__,
                             gt, __gt__)
       a, b=1, 2
       a < b, lt(a, b), __lt__(a, b)
       a <= b, le(a, b), __le__(a, b)
       a == b, eq(a, b), __eq__(a, b)
       a != b, ne(a, b), __ne__(a, b)
       a > b, gt(a, b), __gt__(a, b)
       a >= b, ge(a, b), __ge__(a, b)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - ... ... ... ... >>> >>> (True, True, True)
     - (True, True, True)
     - (False, False, False)
     - (True, True, True)
     - (False, False, False)
     - (False, False, False)
     #+END_SRC
*** 逻辑判断
**** operator. *not_* (obj)
**** operator. *__not__* (obj)
     对应not(obj)。
     
     *注意* ：
     
     - 所有对象都无__not__()方法，只有解释器内部定义了此方法。
     - 结果受__bool__()和__len__()方法影响。？？？
       
     #+BEGIN_SRC python :session
       from operator import not_, __not__
       not(1), not_(1), __not__(1)
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - (False, False, False)
     #+END_SRC
**** operator. *truth* (obj)
     对应bool构造器。

     #+BEGIN_SRC python :session
       from operator import truth
       truth('abc'), bool('abc')
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - (True, True)
     #+END_SRC
**** operator. *is_* (a,b)
**** operator. *is_not* (a,b)
     对应a is b和a is not b。测试两个对象是否完全等价。

     #+BEGIN_SRC python :session
       from operator import is_, is_not
       1 is 1, is_(1, 1)
       1 is not 1, is_not(1, 1)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - (True, True)
     - (False, False)
     #+END_SRC

*** 数字和bit计算
**** 普通数学计算
***** operator. *abs* (obj)
***** operator. *__abs__* (obj)

      #+BEGIN_SRC python :session
        import operator
        abs(-1), operator.abs(-1), operator.__abs__(-1)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - (1, 1, 1)
      #+END_SRC

***** operator. *add* (a,b)
***** operator. *__add__* (a,b)

      #+BEGIN_SRC python :session
        from operator import add, __add__
        a, b = 1, 2
        a + b, add(a, b), __add__(a, b)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> (3, 3, 3)
      #+END_SRC

***** operator. *floordiv* (a,b)
***** operator. *__floordiv__* (a,b)

      #+BEGIN_SRC python :session
        from operator import floordiv, __floordiv__
        a, b = 10, 3
        a // 3
        floordiv(a, b)
        __floordiv__(a, b)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> 3
      - 3
      - 3
      #+END_SRC

***** operator. *index* (a)
***** operator. *__index__* (a) ？？？
      返回转换后的整数。等价于a.__index__()。
      
      #+BEGIN_SRC python :session
        from operator import index, __index__
        index(-111), __index__(-111), (-111).__index__()
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - (-111, -111, -111)
      #+END_SRC

***** operator. *mod* (a,b)
***** operator. *__mod__* (a,b)

      #+BEGIN_SRC python :session
        from operator import mod, __mod__
        a, b = 10, 3
        a % b, mod(a, b), __mod__(a, b)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> (1, 1, 1)
      #+END_SRC

***** operator. *mul* (a,b)
***** operator. *__mul__* (a,b)

      #+BEGIN_SRC python :session
        from operator import mul, __mul__
        a, b = 10, 3
        a * b, mul(a, b), __mul__(a, b)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> (30, 30, 30)
      #+END_SRC

***** operator. *matmul* (a,b)
***** operator. *__matmul__* (a,b)？？？
      矩阵乘法。返回a @ b。

      #+BEGIN_SRC python :session
        a = 1
        b = (10, 100, 30)
        b @ a
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> Traceback (most recent call last):
      -   File "<stdin>", line 1, in <module>
      - TypeError: unsupported operand type(s) for @: 'tuple' and 'int'
      #+END_SRC

***** operator. *neg* (obj)
***** operator. *__neg__* (obj)

      #+BEGIN_SRC python :session
        from operator import neg, __neg__
        obj = 1
        -obj, neg(obj), __neg__(obj)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> (-1, -1, -1)
      #+END_SRC

***** operator. *pos* (a,b)
***** operator. *__pos__* (a,b)

      #+BEGIN_SRC python :session
        from operator import pos, __pos__
        obj = -1
        +obj, pos(obj), __pos__(obj)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> (-1, -1, -1)
      #+END_SRC

***** operator. *pow* (a,b)
***** operator. *__pow__* (a,b)

      #+BEGIN_SRC python :session
        import operator
        a, b = 2, 10
        a**b, pow(a, b), operator.pow(a, b), operator.__pow__(a, b)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> (1024, 1024, 1024, 1024)
      #+END_SRC

***** operator *sub* (a,b)
***** operator *__sub__* (a,b)

      #+BEGIN_SRC python :session
        from operator import sub, __sub__
        a, b = 2, 1
        a - b, sub(a, b), __sub__(a, b)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> (1, 1, 1)
      #+END_SRC

***** operator *truediv* (a,b)
***** operator *__truediv__* (a,b)
      返回a / b。2/3为.66，而不是0。

      #+BEGIN_SRC python :session
        from operator import truediv, __truediv__
        a, b = 2, 3
        a / b, truediv(a, b), __truediv__(a, b)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> (0.6666666666666666, 0.6666666666666666, 0.6666666666666666)
      #+END_SRC

**** bit计算
***** operator. *and_* (a,b)
***** operator. *__and__* (a,b)

      #+BEGIN_SRC python :session
        from operator import and_, __and__
        a, b = 1, 1
        a & b, and_(a, b), __and__(a, b)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> (1, 1, 1)
      #+END_SRC

***** operator. *inv* (obj)
***** operator. *invert* (obj)
***** operator. *__inv__* (obj)
***** operator. *__invert__* (obj)
      
      #+BEGIN_SRC python :session
        from operator import inv, invert, __inv__, __invert__
        num = 2 ** 10
        ~num + 1
        inv(num) + 1
        invert(num) + 1
        __inv__(num) + 1
        __invert__(num) + 1
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> -1024
      - -1024
      - -1024
      - -1024
      - -1024
      #+END_SRC

***** operator. *lshift* (a,b)
***** operator. *__lshift* (a,b)

      #+BEGIN_SRC python :session
        from operator import lshift, __lshift__
        a, b = 2, 1
        a << b, lshift(a, b), __lshift__(a, b)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> (4, 4, 4)
      #+END_SRC

***** operator. *or_* (a,b)
***** operator. *__or__* (a,b)
      
      #+BEGIN_SRC python :session
        from operator import or_, __or__
        a, b = 8, 4
        a | b, or_(a, b), __or__(a, b)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> (12, 12, 12)
      #+END_SRC

***** operator. *rshift* (a,b)
***** operator. *__rshift__* (a,b)

      #+BEGIN_SRC python :session
        from operator import rshift, __rshift__
        a, b = 4, 1
        a >> b, rshift(a, b), __rshift__(a, b)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> (2, 2, 2)
      #+END_SRC
      
***** operator *xor* (a,b)
***** operator *__xor__* (a,b)

      #+BEGIN_SRC python :session
        from operator import xor, __xor__
        a, b = 8, 8
        a ^ b, xor(a, b), __xor__(a, b)
      #+END_SRC

      #+RESULTS:
      #+BEGIN_SRC org
      - >>> (0, 0, 0)
      #+END_SRC

*** 序列操作
**** operator *concat* (a,b)
**** operator *__concat__* (a,b)

     #+BEGIN_SRC python :session
       from operator import concat, __concat__
       a, b = 'hello ', 'world'
       a + b
       concat(a, b)
       __concat__(a, b)
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> 'hello world'
     - 'hello world'
     - 'hello world'
     #+END_SRC
     
**** operator *contains* (a,b)
**** operator *__contains__* (a,b)

     #+BEGIN_SRC python :session
       from operator import contains, __contains__
       a, b = 'a', 'abc'
       a in b, contains(b, a), __contains__(b, a)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> (True, True, True)
     #+END_SRC

**** operator *countOf* (a,b)

     #+BEGIN_SRC python :session
       from operator import countOf
       a, b = 'banana', 'a'
       a.count(b)
       countOf(a, b)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> 3
     - 3
     #+END_SRC

**** operator *delitem* (a,b)
**** operator *__delitem__* (a,b)
     将A中索引为B的元素删除。

     #+BEGIN_SRC python :session
       from operator import delitem, __delitem__
       a, b = ['a', 'b', 'c'], 1
       delitem(a, b)
       print(a)

       a, b = ['a', 'b', 'c'], 1
       del a[b]
       print(a)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> ['a', 'c']
     - >>> >>> >>> ['a', 'c']
     #+END_SRC

**** operator *getitem* (a,b)
**** operator *__getitem__* (a,b)

     #+BEGIN_SRC python :session
       from operator import getitem, __getitem__
       a, b = ['a', 'b', 'c'], 1
       a[b], getitem(a, b)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> ('b', 'b')
     #+END_SRC

**** operator *indexOf* (a,b)

     #+BEGIN_SRC python :session
       from operator import indexOf
       a, b = 'banana', 'a'
       a.index(b), indexOf(a, b)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> (1, 1)
     #+END_SRC
     
**** operator *setitem* (a,b,c)
**** operator *__setitem__* (a,b,c)

     #+BEGIN_SRC python :session
       from operator import setitem

       a, b = [1, 2, 3], 2
       a[b] = 30
       print(a)

       a, b = [1, 2, 3], 2
       setitem(a, b, 30)
       print(a)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> >>> [1, 2, 30]
     - >>> >>> >>> [1, 2, 30]
     #+END_SRC

**** operator *length_hint* (obj,default=0)
     返回OBJ的预测长度。首先尝试返回真实长度，再使用
     obj.__length_hint__()方法，最后返回默认值。

     #+BEGIN_SRC python :session
       from operator import length_hint
       obj = 'abc'
       len(obj), length_hint(obj, 100)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> (3, 3)
     #+END_SRC
     
*** 属性和元素获取
    很有利于与map()、sorted()、itertools.groupby()等需求函数参数的函数
    连用，快速获取属性和元素。
    
**** operator. *attrgetter* (attr)
**** operator. *attrgetter* (*attrs)
     - 声明f=arrtgetter('name')后，f(b)返回b.name。
     - 声明f=attrgetter('name', 'date')后,f(b)返回(b.name, b.date)。
     - 声明f=attrgetter('name.first', 'name.last')后，f(b)返回
       (b.name.first, b.name.last)。

     等价于：

     #+BEGIN_SRC python :eval never
       def attrgetter(*items):
           if any(not isinstance(item, str) for item in items):
               raise TypeError('熟悉名须为字符串')
           if len(items) == 1:
               attr = items[0]

               def g(obj):
                   return resolve_attr(obj, attr)
           else:
               def g(obj):
                   return tuple(resolve_attr(obj, attr) for attr in items)
           return g

       def resolve_attr(obj, attr):
           for name in attr.split('.'):
               obj = getattr(obj, name)
           return obj
     #+END_SRC

**** operator. *itemgetter* (item)
**** operator. *itemgetter* (*items)
     获取对象的__getitem__()方法。
     
     - 声明f=itemgetter(2)后，f(r)返回r[2]。
     - 声明f=itemgetter(2,5,3)后，f(r)返回(r[2],r[5],r[3])。
       
     等价于：
     
     #+BEGIN_SRC python :eval never
       def itemgetter(*items):
           if len(items) == 1:
               item = items[0]

               def g(obj):
                   return obj[item]
           else:
               def g(obj):
                   return tuple(obj[item] for item in items)
           return g
     #+END_SRC
     
     比如：
     
     #+BEGIN_SRC python :session
       from operator import itemgetter
       data = 'ABCDEFG'
       itemgetter(1)(data)
       itemgetter(1, 3, 5)(data)
       itemgetter(slice(2, None))(data)
     #+END_SRC
     
     #+RESULTS:
     #+BEGIN_SRC org
     - >>> 'B'
     - ('B', 'D', 'F')
     - 'CDEFG'
     #+END_SRC

     再比如操作元素的特点域：

     #+BEGIN_SRC python :session
       from operator import itemgetter
       inventory = [('apple', 3), ('banana', 2), ('pear', 5), ('orange', 1)]
       getcount = itemgetter(1)
       list(map(getcount, inventory))
       sorted(inventory, key=getcount)
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> [3, 2, 5, 1]
     - [('orange', 1), ('banana', 2), ('apple', 3), ('pear', 5)]
     #+END_SRC

**** operator. *methodcaller* (name[,args...])
     重建对象方法。
     
     - 声明f=methodcaller('name')后，f(b)返回b.name()。
     - 声明f=methodcaller('name', 'foo', bar=1)后，f(b)返回
       b.name('foo', bar=1)。

     等价于：

     #+BEGIN_SRC python :eval never
       def methodcaller(name, *args, **kwargs):
           def caller(obj):
               return getattr(obj, name)(*args, **kwargs)
           return caller
     #+END_SRC

** 将操作符映射为函数 （待续）
** inplace操作符
   比如：
   
   - x += y，等价于x = operator.iadd(x, y)。
   - z = operator.iadd(x,y)，等价于z=x;z += y。
     
   对于immutable类型的数据，不影响原来值：
   
   #+BEGIN_SRC python :session
     from operator import iadd
     a = 'hello'
     iadd(a, ' world')
     print(a)
   #+END_SRC
   
   #+RESULTS:
   #+BEGIN_SRC org
   - >>> 'hello world'
   - hello
   #+END_SRC
   
   对于mutable类型的数据，则会改变原来数据：
   
   #+BEGIN_SRC python :session
     from operator import iadd
     s = ['h', 'e', 'l', 'l', 'o']
     iadd(s, ['w', 'o', 'r', 'l', 'd'])
     print(s)
   #+END_SRC
   
   #+RESULTS:
   #+BEGIN_SRC org
   - >>> ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']
   - ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']
   #+END_SRC
*** operator. *iadd* (a,b)
*** operator. *__iadd__* (a,b)
    a=iadd(a,b)等价于a+=b。
*** operator. *iand* (a,b)
*** operator. *__iand__* (a,b)
    a=iand(a,b)等价于a&=b
*** operator. *iconcat* (a,b)
*** operator. *__iconcat__* (a,b)
    a=iconcat(a,b)等价于a+=b。
*** operator. *ifloordiv* (a,b)
*** operator. *__ifloordiv__* (a,b)
    a=floordiv(a,b)等价于a//=b。
*** operator. *ilshift* (a,b)
*** operator. *__ilshift__* (a,b)
*** operator. *imod* (a,b)
*** operator. *__imod__* (a,b)
*** operator. *mul* (a,b)
*** operator. *__mul__* (a,b)
*** operator. *imatmul* (a,b)
*** operator. *__imatmul__* (a,b)
*** operator. *ior* (a,b)
*** operator. *__ior__* (a,b)
*** operator. *ipow* (a,b)
*** operator. *__ipow__* (a,b)
*** operator. *irshift* (a,b)
*** operator. *__irshift__* (a,b)
*** operator. *isub* (a,b)
*** operator. *__isub__* (a,b)
*** operator. *itruediv* (a,b)
*** operator. *__itruediv__* (a,b)
*** operator. *ixor* (a,b)
*** operator. *__ixor__* (a,b)
