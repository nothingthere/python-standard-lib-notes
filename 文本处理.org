# Author: Claudio <3261958605@qq.com>
# Created: 2017-04-20 17:08:42
# Commentary:
#+TITLE: 文本处理

* str - 常用字符串操作
** 字符串常量
*** string. *ascii_letters*
    ascii_lowercase和ascii_uppercase的结合。不由本地决定。
    #+BEGIN_SRC python :session
      import string
      string.ascii_letters
    #+END_SRC

    #+RESULTS[dbc0c195ea9116af68a930af514a83f8927d0f88]:
    :
    : 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

*** string. *ascii_lowercase*
    小写字符。不由本地决定。
    #+BEGIN_SRC python :session
      import string
      string.ascii_lowercase
    #+END_SRC

    #+RESULTS[43fac96fdd9792434ad6a060c9837b3382fe275e]:
    :
    : 'abcdefghijklmnopqrstuvwxyz'

*** string. *ascii_uppercase*
    大写字母。不由本地决定。
    #+BEGIN_SRC python :session
      import string
      string.ascii_uppercase
    #+END_SRC

    #+RESULTS[3cc03248df9135f10c36b1d3ac4495c448e24ba1]:
    :
    : 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

*** string. *digits*

    #+BEGIN_SRC python :session
      import string
      string.digits
    #+END_SRC

    #+RESULTS[e90c3f3c2fff08a17d66c41e0b63e02925b58a4a]:
    :
    : '0123456789'

*** string. *hexdigits*

    #+BEGIN_SRC python :session
      import string
      string.hexdigits
    #+END_SRC

    #+RESULTS[10cdf01fc31dcc5777ec14d860faadc68e31268e]:
    :
    : '0123456789abcdefABCDEF'

*** string. *octdigits*

    #+BEGIN_SRC python :session
      import string
      string.octdigits
    #+END_SRC

    #+RESULTS[13332f71f3c21f481367d49f832f13393abb015f]:
    :
    : '01234567'

*** string. *punctuation*
    String of ASCII characters which are considered punctuation
    characters in the C locale.

    #+BEGIN_SRC python :session
      import string
      string.punctuation
    #+END_SRC

    #+RESULTS[7cabb4253ee71483da078dbdd7c55d5ec8426f1b]:
    :
    : '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'

*** string. *printable*
    digits、ascii_letters、punctuation和whitespace的结合。

    #+BEGIN_SRC python :session
      import string
      string.printable
    #+END_SRC

    #+RESULTS[20dbfe464a9005e43fa7130f2344ef55fcc4653b]:
    :
    : '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n\r\x0b\x0c'

*** string. *whitespace*
    含空格、tab、linefeed、return、formfeed和vertical tab。
    #+BEGIN_SRC python :session
      import string
      string.whitespace
    #+END_SRC

    #+RESULTS[7669f40dfae6126e364d36dfd57163f468b01bbb]:
    :
    : ' \t\n\r\x0b\x0c'

** 定制字符串格式 ？？？
*** class string. *Formatter*
**** *format* (format_string,*arg,**kwargs)

     #+BEGIN_SRC python :session
       from string import Formatter

       temp = 'hello {}'
       temp.format('world')

       # Formatter.format(temp,'')
     #+END_SRC

     #+RESULTS[0d139b494a1eddbd3eaa6ed75253b7ef0f782060]:
     :
     : >>> >>> 'hello world'

**** *vformat* (format_string,args,kwargs)
**** *parse* (format_string)
**** *get_field* (field_name,args,kwargs)
**** *get_value* (key,args,kwargs)
**** *check_unused_args* (used_args,args,kwargs)
**** *format_field* (value,format_spec)
**** *convert_field* (value,conversion)
** 字符串格式语法
   格式化字符串时，str.format()方法和Formatter类使用相同的语法。使用后
   者时，可定制格式语法。

   格式字符串中需被替换的地方使用{}，其余文本保持原样。如需表示{}本身，
   需使用{{}}。

   一些简单的例子：

   #+BEGIN_SRC python :session
     import string

     'First, thou shalt count to {0}'.format(1000)
     'Bring me a {}'.format('book')
     'From {} to {}'.format('New York', 'China')
     'My quest is {name}'.format(name='Claudio')
     'Units destroyed: {player[0]}'.format(player=[1, 2, 3])
     'Weight in tons {0.digits}'.format(string)
   #+END_SRC

   #+RESULTS[ad8196a5794c94864c2ca2f0013241ca39d784a2]:
   :
   : >>> 'First, thou shalt count to 1000'
   : 'Bring me a book'
   : 'From New York to China'
   : 'My quest is Claudio'
   : 'Units destroyed: 1'
   : 'Weight in tons 0123456789'

   一般情况下，使用format函数时调用的是对象上的__format__()方法。不过，
   可使用下面三个标记转换：

   | 标记 | 调用函数 |
   |------+----------|
   | !s   | str()    |
   | !r   | repr()   |
   | !a   | ascii()  |

   #+BEGIN_SRC python :session
     '我是一个聪明的 {!s}'.format('男孩')
     '我是一个聪明的 {!r}'.format('男孩')
     '我是一个聪明的 {!a}'.format('男孩')
   #+END_SRC
   
   #+RESULTS[17870e409219a15570f5dad1340074afa9113f69]:
   : '我是一个聪明的 男孩'
   : "我是一个聪明的 '男孩'"
   : "我是一个聪明的 '\\u7537\\u5b69'"
   
*** 格式规范
    模板字符串中可使用下列标记格式输出。
**** 对齐标记
     | 标记 | 含义                              |
     |------+-----------------------------------|
     | <    | 左对齐                            |
     | >    | 右对齐                            |
     | \=   | 仅对数字有效。在正/负号前增加间距 |
     | \^   | 居中对齐                          |

     #+BEGIN_SRC python :session
       name = 'claudio'

       '{}'.format(name)
       '{:>10}'.format(name)
       '{:<10}'.format(name)
       '{:=10}'.format(-100)
       '{:^10}'.format(name)
     #+END_SRC

     #+RESULTS[ecf346eb362e33e9160bba6190a0a11c2410e8b8]:
     :
     : >>> 'claudio'
     : '   claudio'
     : 'claudio   '
     : '-      100'
     : ' claudio  '

**** 对数字正负号的标记
     
     | 标记  | 含义                         |
     |-------+------------------------------|
     | +     | 不管正负数，都在前面添加符号 |
     | -     | 仅在负数前添加符号           |
     | space | 整数前用空格，负数前用负号   |
     
     #+BEGIN_SRC python :session
       '{:+}'.format(100)
       '{:+}'.format(-100)

       '{:-}'.format(100)
       '{:-}'.format(-100)

       '{: }'.format(100)
       '{: }'.format(-100)
     #+END_SRC
     
     #+RESULTS[45bf5deb6bd6ff4171aad64fd3efccb562f068fe]:
     : '+100'
     : '-100'
     : >>> '100'
     : '-100'
     : >>> ' 100'
     : '-100'
     
**** 整数进制转换

     | 标记 | 含义                                |
     |------+-------------------------------------|
     | b    | 二进制                              |
     | c    | 转换为Unicode字符                   |
     | d    | 10进制                              |
     | o    | 8进制                               |
     | x    | 16进制，小写                        |
     | X    | 16进制，大写                        |
     | n    | 同'd'，不过会使用本地环境的间隔字符 |
     | None | 同'd'                               |

     此外，还可使用下面表示浮点数的标记。

     #+BEGIN_SRC python :session
       n = 10
       '{:b}'.format(n)
       '{:c}'.format(n)
       '{:d}'.format(n)
       '{:o}'.format(n)
       '{:x}'.format(n)
       '{:X}'.format(n)
       '{:n}'.format(n)
       '{:}'.format(n)
     #+END_SRC

     #+RESULTS[29af31cdf7cc6c6480470e2f38ab32044cea119d]:
     :
     : '1010'
     : '\n'
     : '10'
     : '12'
     : 'a'
     : 'A'
     : '10'
     : '10'

     可使用“#”显示进制：

     #+BEGIN_SRC python :session
       n = 10
       '{:#b}'.format(n)
       '{:c}'.format(n)
       '{:#d}'.format(n)
       '{:#o}'.format(n)
       '{:#x}'.format(n)
       '{:#X}'.format(n)
       '{:#n}'.format(n)
       '{:#}'.format(n)
     #+END_SRC

     #+RESULTS[50be5b3b00ec1a3e12e2421107e20074e88ce3f9]:
     :
     : '0b1010'
     : '\n'
     : '10'
     : '0o12'
     : '0xa'
     : '0XA'
     : '10'
     : '10'

     还可使用“,”在数字中插入逗号：

     #+BEGIN_SRC python :session
       '{:,}'.format(1233456)
       '{:,}'.format(12334.56)
     #+END_SRC

     #+RESULTS[c285eba7a28d863f64d13e88be34504cd77975af]:
     : '1,233,456'
     : '12,334.56'

**** 浮点数和整数都可用的标记
     | 标记 | 含义                               |
     |------+------------------------------------|
     | e    | 科学计数法，小写e，默认精度6       |
     | E    | 同上，大写E                        |
     | f    | 固定小数点后位数为6位              |
     | F    | 同上，不过将nan变为NAN，inf变为INF |
     | g    | 智能使用科学计数法                 |
     | G    |                                    |
     | n    | 同g，不过根据本地环境插入分割字符  |
     | %    | 百分数表示                         |
     | None | 同g，。。。                        |

     #+BEGIN_SRC python :session
       n = 123456789.123456789

       '{:e}'.format(n)
       '{:E}'.format(n)
       '{:f}'.format(n)
       '{:F}'.format(n)
       '{:g}'.format(n)
       '{:G}'.format(n)
       '{:n}'.format(n)
       '{:%}'.format(n)
       '{:}'.format(n)
     #+END_SRC

     #+RESULTS[44bc1c02d27f640d6b2889783f52f38bcf939153]:
     #+begin_example

     >>> '1.234568e+08'
     '1.234568E+08'
     '123456789.123457'
     '123456789.123457'
     '1.23457e+08'
     '1.23457E+08'
     '1.23457e+08'
     '12345678912.345678%'
     '123456789.12345679'
     #+end_example

*** 格式例子
    大多数情况下，与使用%的传统形式相同，如'%03.2f'等价于'{:03.2f}'，
    即使用冒号和大括号替换了百分号。

    不过，此新新形式添加了一些先用法，下面例子中会体现。

**** 通过位置获取参数

     #+BEGIN_SRC python :session
       '{0}, {1}, {2}'.format('a', 'b', b'c')
       '{}, {}, {}'.format('a', 'b', 'c')
       '{2}, {1}, {0}'.format('a', 'b', 'c')
       '{2}, {1}, {0}'.format(*'abc')
       '{0} and {1!r} and {0}'.format('apple', 'banana')
     #+END_SRC

     #+RESULTS[41fdca0209912ddff3a7f23f0cf4412f661662fd]:
     : "a, b, b'c'"
     : 'a, b, c'
     : 'c, b, a'
     : 'c, b, a'
     : "apple and 'banana' and apple"

**** 通过名称获取参数

     #+BEGIN_SRC python :session
       '{country}的首都是{capital}'.format(country='中国', capital='北京')

       item = {'country': '中国', 'capital': '北京'}
       '{country}的首都是{capital}'.format(**item)
     #+END_SRC

     #+RESULTS[efc629a84afdde096307cff5ccf4cb4b70f4e72d]:
     : '中国的首都是北京'
     : >>> >>> '中国的首都是北京'

**** 获取参数的属性

     #+BEGIN_SRC python :session
       c = 3 - 5j
       '复数{0}的实部为：{0.real}, 虚部为：{0.imag}'.format(c)

       class Point:
           def __init__(self, x, y):
               self.x, self.y = x, y
           def __str__(self):
               return 'Point({self.x}, {self.y})'.format(self=self)

       str(Point(3, 3))
     #+END_SRC

     #+RESULTS[c360263864b417d4161470c009ce24f9f9910113]:
     :
     : '复数(3-5j)的实部为：3.0, 虚部为：-5.0'
     : >>> ... ... ... ... ... >>> 'Point(3, 3)'

**** 获取参数中的元素

     #+BEGIN_SRC python :session
       point = [1, 2]
       'X: {0[0]}; Y: {0[1]}'.format(point)
     #+END_SRC

     #+RESULTS[44c43572d18bbdfac83cdb06b2e9cfc67ec420bf]:
     :
     : 'X:      1; Y: 2'

**** 使用%s代替%r

     #+BEGIN_SRC python :session
       'reper()函数会显示引号：{!r}；str()函数则不会：{!s}'.format('abc', 'ABC')
     #+END_SRC

     #+RESULTS[7ffd29edf6f25d4e7584bc7ea2b28592bd4228a5]:
     : "reper()函数会显示引号：'abc'；str()函数则不会：ABC"

**** 对齐和指定宽度
     中文占两个字母宽度？？？

     #+BEGIN_SRC python :session
       '{:<20}'.format('左对齐')
       '{:>20}'.format('右对齐')
       '{:^20}'.format('居中')
       '{:*^20}'.format('居中，用信号填补空白')
     #+END_SRC

     #+RESULTS[324468f0b45ad342ac39828391573e69028d3c3c]:
     : '左对齐                 '
     : '                 右对齐'
     : '         居中         '
     : '*****居中，用信号填补空白*****'

**** 替换%+f、%-f和%f，并添加正负号

     #+BEGIN_SRC python :session
       from math import pi

       '{:+f}; {:+f}'.format(pi, -pi)
       '{: f}; {: f}'.format(pi, -pi)
       '{:-f}; {:-f}'.format(pi, -pi)
     #+END_SRC

     #+RESULTS[9d9709337e8bb17e10f6ea020a3ab96182c7b6a7]:
     :
     : >>> '+3.141593; -3.141593'
     : ' 3.141593; -3.141593'
     : '3.141593; -3.141593'

**** 替换%x和%o，并转换不同进制

     #+BEGIN_SRC python :session
       '10进制：{0:d}，16进制：{0:x}；8进制：{0:o}; 2进制：{0:b}'.format(42)
       '10进制：{0:d}，16进制：{0:#x}；8进制：{0:#o}; 2进制：{0:#b}'.format(42)
     #+END_SRC

     #+RESULTS[2cad6a8e795f81c756462863e55fa248aaf208e2]:
     : '10进制：42，16进制：2a；8进制：52; 2进制：101010'
     : '10进制：42，16进制：0x2a；8进制：0o52; 2进制：0b101010'

**** 使用逗号分割大数字

     #+BEGIN_SRC python :session
       '{:,}'.format(123456789)
     #+END_SRC

     #+RESULTS[5f51ce4e908837634f9c240f8eb939d04800ccce]:
     : '123,456,789'

**** 添加百分号

     #+BEGIN_SRC python :session
       '{:%}'.format(1 / 3)
       '{:.2%}'.format(1 / 3)
     #+END_SRC

     #+RESULTS[63b0909883ed719c3d68a87ee2643a99578e3b74]:
     : '33.333333%'
     : '33.33%'

**** 使用类型专门的格式

     #+BEGIN_SRC python :session
       import datetime

       d = datetime.datetime(2017, 4, 22, 21, 30, 55)
       '{:%Y-%m-%d %H:%M:%S}'.format(d)
     #+END_SRC

     #+RESULTS[3e8b8f3d61bd204b69eb01f7305b4c054293a415]:
     :
     : >>> >>> '2017-04-22 21:30:55'

**** 嵌套

     #+BEGIN_SRC python :session
       for align, text in zip('<^>', ['left', 'center', 'right']):
           '{0:{fill}{align}16}'.format(text, fill=align, align=align)

       '{:02X}{:02X}{:02X}{:02X}'.format(*[192, 168, 0, 1])
     #+END_SRC

     #+RESULTS[bdca78ef7e568f0bf1fcc66ba1c40750d05be890]:
     :
     : ... 'left<<<<<<<<<<<<'
     : '^^^^^center^^^^^'
     : '>>>>>>>>>>>right'
     : 'C0A80001'

     #+BEGIN_SRC python :session
       for num in range(5, 12):
           for base in 'dXob':
               print('{0:{width}{base}}'.format(num, base=base, width=5), end='')
           print()
     #+END_SRC

     #+RESULTS[3c3b781a7a6d1d10aeae17fb2e357371278fbb5c]:
     :
     : ... ... ...     5    5    5  101
     :     6    6    6  110
     :     7    7    7  111
     :     8    8   10 1000
     :     9    9   11 1001
     :    10    A   12 1010
     :    11    B   13 1011

** 模板字符串

   #+BEGIN_SRC python :session
     from string import Template
     s = Template('你好，$who。 我是$me。')

     s.substitute(who='world', me='claudio')
   #+END_SRC

   #+RESULTS[83b02956c092b2329a4db9acc744d9719f2c191b]:
   :
   : >>> >>> '你好，world。 我是claudio。'

   基本规则：

   1. $$表示$本身。
   2. $identifier表示需替换处，被映射中key为identifier的值替换。默认情
      况下，identifier需为ASCII小写字母或下划线，首字母须为ASCII小写字
      母或下划线。在第一个非此类字母除将其结束。
   3. $identifier同${identifier}在绝大多数情况下等价，当当需将其置于单
      词中时则必须使用后者，如"${identifier}name"。
   4. 其他任何形式抛出ValueError错误。

*** class string. *Template* (template)
    接受单个模板字符串TEMPLATE，构造模板。
**** *substitute* (mapping,**kwds)
     进行替换，返回新字符串。MAPPING为“类字典”对象，key值对应
     placeholder；也可使用关键字参数，关键字对应placeholder。如果
     MAPPING参数和关键字参数有重名，则关键字参数中的值有效。

     #+BEGIN_SRC python :session
       from string import Template

       temp = Template('hello, ${name}.')
       temp.substitute({'name': 'world'}, name='Claudio')
     #+END_SRC

     #+RESULTS[ecb945d54827f4a43c35b4b65aee492dc6f65b28]:
     :
     : >>> >>> 'hello, Claudio.'

**** *safe_substitute* (mapping,**kwds)
     同substitute基本相同，只是当没找到对应key值时，identifier保持原样
     输出。

     *注意* ：其实一点也不“safe”。

     #+BEGIN_SRC python :session
       from string import Template

       tmp = Template('${who}喜欢${what}')
       tmp.substitute(who='我')
       tmp.safe_substitute(who='你')
     #+END_SRC

     #+RESULTS[2f2410515ff5fe0cf485a3f3225d0d54bb5bbf77]:
     :
     : >>> >>> Traceback (most recent call last):
     :   File "<stdin>", line 1, in <module>
     :   File "/usr/lib/python3.5/string.py", line 129, in substitute
     :     return self.pattern.sub(convert, self.template)
     :   File "/usr/lib/python3.5/string.py", line 119, in convert
     :     val = mapping[named]
     : KeyError: 'what'
     : '你喜欢${what}'

**** *template*
     公共数据属性。返回构建模板时的字符串。不要改变此属性，只将其作为
     自读属性即可。

     #+BEGIN_SRC python :session
       from string import Template

       temp = Template('${who}喜欢${what}')
       temp.template
     #+END_SRC

     #+RESULTS[2ca94bc83125482c792b8f174cffaf55e8d6535f]:
     :
     : >>> >>> '${who}喜欢${what}'

**** 改造
     可以通过集成Template类，定制占位符语法，边界符（delimiter），或整
     个解析模板字符串的正则。可重置的类属性有：

     - delimiter：占位符字符串。默认为$。不要使用正则，因为实现会根据
       需要对齐调用re.escape()方法。

       #+BEGIN_SRC python :session
         from string import Template

         class MyTemp(Template):
             delimiter = '#'

         temp = MyTemp('hello #{name}')
         temp.substitute(name='world')
       #+END_SRC

       #+RESULTS[fc099f2bb9ab16e7c1edf89910812ebd47ec3fae]:
       :
       : >>> >>> ... ... >>> >>> >>> 'hello world'

     - idpattern： 在不使用大括号包裹placeholder时，会根据此正则默然添
       加大括号，默认值为[_a-z][_a-z0-9]*。

       #+BEGIN_SRC python :session
         from string import Template

         class MyTemp(Template):
             idpattern = '[_a-z][_a-z0-9。]*'

         temp = Template('我喜欢吃$food。')
         mytemp = MyTemp('我喜欢吃${food}。')
         mytemp1 = MyTemp('我喜欢吃$food。')
         # mytemp1 = MyTemp('我喜欢吃$food。')
         temp.substitute(food='orange')
         mytemp.substitute(food='orange')
         mytemp1.substitute(food='orange')
       #+END_SRC

       #+RESULTS[0374890ede19258988ff3970e5661dfbf14b2966]:
       #+begin_example

       >>> ... ... >>> >>> >>> >>> ... '我喜欢吃orange。'
       '我喜欢吃orange。'
       Traceback (most recent call last):
         File "<stdin>", line 1, in <module>
         File "/usr/lib/python3.5/string.py", line 129, in substitute
           return self.pattern.sub(convert, self.template)
         File "/usr/lib/python3.5/string.py", line 119, in convert
           val = mapping[named]
       KeyError: 'food。'
       #+end_example

     - flags：当编译用于识别替换的正则时使用的正则flags。默认值为
       re.IGNORECASE。

       *注意* ：re.VERBOSE总是会添加到flags中，所以定制idpatterns属性
       时，需遵从verbose正则的规则。

     另外，还可重置匹配整个placeholder的属性pattern。其值需为含4组
     “named capture group”的正则。每组与上面的3条规则对应，另外还添加
     了无效placeholder规则：

     - escaped：边界符本身的正则。如默认值$$。
     - named：不加大括号匹配placeholder名的正则。不要将边界付置于
       capturing group中。
     - braced：添加大括号时匹配placeholder名的正则。不要将边界符和大括
       号置于capturing group中。
     - invalid：This group matches any other delimiter pattern
       (usually a single delimiter)？？？应出现在整个正则的最后。

*** format和Template的区别  [[https://segmentfault.com/q/1010000006709792][@segmentfault]]
    string.Template正如其名，适合于定义模板，如在函数和包里定义好模板，
    就可在任意时间调用，而不用担心其细节；str.format则适合于当行表达式，
    是%-format的替代，更灵活：

    #+BEGIN_SRC python :session
      from string import Template

      class MyTem(Template):
          delimiter = '#'

      tem = MyTem('hello, #{name}')

      print(tem.substitute(name='world'))
    #+END_SRC

    #+RESULTS[598b93ddce9c174f6e2fd165c9b7839f383272cd]:
    :
    : >>> ... ... >>> >>> >>> hello, world

** 帮助函数
*** string. *capwords* (s,sep=None)
    对字符S调用str.split()方法，对每个单词调用str.capitalize()方法，再
    调用str.join()方法连接返回。

    使用SEP参宿作为分割和连接字符串的分隔符，默认为空白字符。

    #+BEGIN_SRC python :session
      from string import capwords

      capwords('i have a dream!')
      capwords('banana', sep='a')
    #+END_SRC

    #+RESULTS[da595ad1f2d225e97f61633a716d197a60387985]:
    :
    : >>> 'I Have A Dream!'
    : 'BaNaNa'

* re - 正则表达式
  此模块提供正则匹配操作，与Perl的正则相似。
  
  模板和被搜索的字符串都可为Unicode字符串和8-bit字符串。但是，Unicode
  字符串和8-bit字符串不能混合使用：不能用byte形式的模板匹配Unicode字符
  串，反之亦然；当进行替换时，模板和被搜索字符串都应为相同类型。
  
  正则表达式使用反斜杠（\）表示转义，表示特殊形式，或将特殊字符转换为
  普通字符。这与Python中字符串字面量使用相同字符表示相同含义相冲突。如
  要匹配反斜杠自身，需写为“\\\\”。因为正则本身为“\\”，每个反斜杠转义一
  次，最后就成了4个反斜杠。
  
  解决方法为使用Python的“原生字符串”表达方式，这样反斜杠在任何字符前都
  不会有特殊含义，如r"\n"是2个字符的字符串，即“\”和“n”；而“\n”则是表示
  单个换行符的字符串。一般情况下，Python中使用“原生字符串”表示正则模板。
  
  值得注意的是，大多数情况下，模块层级的正则函数都有对应的编译后正则方
  法。前者无需编译正则对象，但缺少优化的参数形式。
  
  #+BEGIN_QUOTE
  *注意* ：第三方插件regex有与re模块兼容的接口，且提供了额外功能，以及
  更丰富的Unicode支持。
  #+END_QUOTE
  
** 正则基本语法
   正则可连接：如果A和B都是正则，则AB也是正则。一般情况下，如果字符串p
   匹配正则A，且字符串q匹配正则B，则pq也匹配正则AB。
   
   重复标记，如*、+、?、{m,n}等，不能直接嵌套。
   
*** .
    默认情况下匹配除换行符以外的任意字符。如果指定了DOTALL标记，则包含
    换行符。

*** ^
    匹配字符串其实位置。如果在MUTILINE模式下，则立即匹配新行后。

*** $
    匹配字符串末或换行符前。在MULTILINE模式下，还匹配换行符前。foo匹配
    foo和foobar，但foo$则只匹配foo。foo.$会匹配foo1\nfoo2\n中的foo1，
    但在MULTILINE模式下，则匹配foo1和foo2。此外，$匹配'foo\n'会得到两
    个空字符，一个在换行符前，一个在换行符后。

    #+BEGIN_SRC python :session
      import re

      re.findall('foo.$', 'foo1\nfoo2\n')
      re.findall('foo.$', 'foo1\nfoo2\n', re.MULTILINE)
      re.findall('$', 'foo\n')
      re.findall('$', 'foo')
    #+END_SRC

    #+RESULTS[d3b2a742803383792a331777c8e27576948378ef]:
    :
    : >>> ['foo2']
    : ['foo1', 'foo2']
    : ['', '']
    : ['']

*** *
    匹配重复0个或多个。
    
    #+BEGIN_SRC python :session
      import re

      re.findall('ab*', 'a')
      re.findall('ab*', 'ab')
      re.findall('ab*', 'abbb')
      re.findall('ab*', 'ac')
      re.findall('ab*', 'c')
    #+END_SRC

    #+RESULTS[f24e4106e8445523aed2669d9d6814b71831ec44]:
    :
    : >>> ['a']
    : ['ab']
    : ['abbb']
    : ['a']
    : []

*** +
    匹配一个多或多个。

    #+BEGIN_SRC python :session
      import re

      re.findall('ab+', 'a')
      re.findall('ab+', 'ab')
      re.findall('ab+', 'abbb')
      re.findall('ab+', 'ac')
      re.findall('ab+', 'c')
    #+END_SRC

    #+RESULTS[5fb2e20b51d181e1a1eb59cf40b2280cfc56a63a]:
    :
    : >>> []
    : ['ab']
    : ['abbb']
    : []
    : []

*** ?
    匹配0个或1个。

    #+BEGIN_SRC python :session
      import re

      re.findall('ab?', 'a')
      re.findall('ab?', 'ab')
      re.findall('ab?', 'abbb')
      re.findall('ab?', 'ac')
      re.findall('ab?', 'c')
    #+END_SRC

    #+RESULTS[c67f4728c42b21dd7a18ebba57c09641183f0571]:
    :
    : >>> ['a']
    : ['ab']
    : ['ab']
    : ['a']
    : []

*** *?,+?,??
    *、+和?都是贪婪匹配，添加?号将其转换为非贪婪匹配。
    
    #+BEGIN_SRC python :session
      import re

      re.findall('<.*>', '<a> b <c>')
      re.findall('<.*?>', '<a> b <c>')
    #+END_SRC

    #+RESULTS[d8cb1e2ca9816fb4636de72e5166daedb40935bd]:
    :
    : >>> ['<a> b <c>']
    : ['<a>', '<c>']

*** {m}
    值得匹配个数为M。

    #+BEGIN_SRC python :session
      import re

      re.findall('ab{2}', 'ab')
      re.findall('ab{2}', 'abb')
      re.findall('ab{2}', 'abbbb')
    #+END_SRC

    #+RESULTS[395b9b3a7c4c905e8a6191bdb95167b82be70695]:
    :
    : >>> []
    : ['abb']
    : ['abb']

*** {m,n}
    匹配M->N个。如果缺省M，表示0->N个；缺省N，表示M->无限多个。

*** {m,n}?
    {m,n}的非贪婪形式：

    #+BEGIN_SRC python :session
      import re

      re.findall(r'ab{3,5}', 'abbbbb')
      re.findall(r'ab{3,5}?', 'abbbbb')
    #+END_SRC

    #+RESULTS[62bec64cfe56bf86826fe0040c16cd784ac94601]:
    :
    : >>> ['abbbbb']
    : ['abbb']

*** \
    转义特殊字符，如*、?和+等；或标记特殊序列（special sequence）。

    为避免过多书写过多反斜杠，强烈建议除简单的正则表达式外，都使用“原
    始字符串”。

    #+BEGIN_SRC python :session
      import re

      re.findall('\\\\', '\\')
      re.findall(r'\\', '\\')
    #+END_SRC

    #+RESULTS[1f7d469e413645a70fabb6db47137355918e50e0]:
    :
    : >>> ['\\']
    : ['\\']

*** []
    匹配字符组。
    
    - 匹配其中的任意一个字符：

      #+BEGIN_SRC python :session
        import re

        re.findall('[ban]', 'banana')
      #+END_SRC

      #+RESULTS[1eb9d3f2efad30bfe84ad740f5dfa3ba1e8088cb]:
      :
      : >>> ['b', 'a', 'n', 'a', 'n', 'a']
      
    - 匹配字符范围，如需在其中匹配“-”本身，则需将其转义，如[a\-z]或放
      在第一个或最后一个位置。
      
      #+BEGIN_SRC python :session
        import re

        re.findall('[a-z]{2}', 'banana')
        re.findall('[-a-z]', '-ba')
        re.findall('[a\-z]', '-ba')
      #+END_SRC

      #+RESULTS[8eae70c14173aa9e8177b05f2611134ab7d45665]:
      :
      : >>> ['ba', 'na', 'na']
      : ['-', 'b', 'a']
      : ['-', 'a']
      
    - 其中的特殊字符失去其特殊含义：
      
      #+BEGIN_SRC python :session
      import re

      re.findall('[(+*?)]', '[(+*?)]')
      #+END_SRC

    - 可在第一个位置使用^字符，表示不匹配其中任何字符。除在第一个位置
      外，^失去特殊含义：

      #+BEGIN_SRC python :session
      import re

      re.findall('[an]', 'banana')
      re.findall('[^an]', 'banana')
      re.findall('[an^]', '^banana')
      #+END_SRC
      
      #+RESULTS[8a97c7d04b2f9977933348316d9b030513f89965]:
      :
      : >>> ['a', 'n', 'a', 'n', 'a']
      : ['b']
      : ['^', 'a', 'n', 'a', 'n', 'a']

    - 如需在其中匹配右方括号，可使用反斜杠转义，或放在第一个位置：

      #+BEGIN_SRC python :session
        import re

        re.findall('[][]', '[]')
        re.findall('[[\]]', '[]')
      #+END_SRC

      #+RESULTS[051c649b5233f486047821138d10c7c5f1cc2402]:
      :
      : >>> ['[', ']']
      : ['[', ']']

*** |
    A|B，A和B可为任意正则，匹配A或B。从A开始向右匹配，找到匹配立即停止，
    即非贪婪。如需匹配数竖线本身，可使用反斜杠转义，或置于方括号内：

    #+BEGIN_SRC python :session
      import re

      re.findall('(fuck|love) you', 'fuck you')

      re.findall('[|]', '|')
      re.findall(r'\|', '|')
    #+END_SRC

    #+RESULTS[10dfcde01aa124fbd812b003f56833f389d3e5f4]:
    :
    : >>> ['fuck']
    : >>> ['|']
    : ['|']

*** (...)
    分组匹配。匹配括号内的正则。匹配后可使用\number形式获取匹配内容。
    匹配小括号本身可使用反斜杠转义，或置于方括号中：

    #+BEGIN_SRC python :session
      import re

      m = re.search(r'([0-9])\1', '55')
      print(m.group())
      re.findall('[()]', '()')
      re.findall(r'(\(|\))', '()')
    #+END_SRC

    #+RESULTS[7425fa45b9283a1069c689729b5674e505e9c05c]:
    :
    : >>> >>> 55
    : ['(', ')']
    : ['(', ')']

*** (?...) - 分组扩展
    扩展标记。?后的第一个字符决定扩展方式。除(?P<name>...)外，所有扩展
    都不形成新分组。下面为目前支持的扩展：
    
**** (?aiLmsux)
     不匹配任何内容，只是指定正则标记。各个字母对应的模块属性和含义分
     别为：
     
     | 字符 | 模块属性 | 含义                      |
     |------+----------+---------------------------|
     | a    | re.A     | 只匹配ASCII字符           |
     | i    | re.I     | 不区分大小写              |
     | L    | re.L     | 由本地环境决定            |
     | m    | re.M     | 多行模式                  |
     | s    | re.S     | 换行符也作为“.”的匹配     |
     | x    | re.X     | 整个正则都使用verbose模式 |
     
     #+BEGIN_SRC python :session
       import re
       re.findall('(?ax)', '人')       # ???
       re.findall('(?i)a', 'aA')
       re.findall('a', 'aA')
     #+END_SRC
     
     #+RESULTS[fbed4128058c4a06f0118e3589ca283e70d754be]:
     :
     : ['', '']
     : ['a', 'A']
     : ['a']
     
     *注意* ：(?x)标记决定整个正则的解析方式。需放在整个正则最前面，或
     单个或多个空格前面。
     
**** (?:...)
     (...)的非捕捉版本。唯一不同点为不能使用\number获取括号中匹配到的
     内容。

**** (?P<name>...)
     在(...)的基础上为反向索引添加新名字NAME。如正常情况下可使用
     \number获取分组匹配中的内容，使用此扩展后还可使用\name获取。
     
     如下面匹配单/双引号括起来的内容：

     #+BEGIN_SRC python :session
       import re
       m = re.search('(?P<quote>[\'\"])(?P<match>.*)(?P=quote)', '"name"')
       print(m.group('match'))
       re.findall('(?P<letter>abc)', 'abc')
     #+END_SRC

     #+RESULTS[1fd27221f28f134b95e3a61e1ee0bbb8c7338126]:
     :
     : >>> name
     : ['abc']

     被命名的分组可在下面3中情况下反向索引（以上例为准）：

     | 使用情况                         | 引用方式                           |
     |----------------------------------+------------------------------------|
     | 在自身所处正则内                 | (?P=quote)或\1                     |
     | 处理匹配对象m时                  | m.group('quote')或m.end('quote')等 |
     | 传递给re.sub()方法作为repl参数时 | \g<quote>或\g<1>或\1               |

**** (?P=name)
     反向索引命名分组。
**** (?#...)
     注释。

     #+BEGIN_SRC python :session
       import re

       re.findall('(?#不区分大小写)(?i)a', 'aA')
     #+END_SRC

     #+RESULTS[c309dce82dee2b20693b54c1752792be11fc6cfd]:
     :
     : >>> ['a', 'A']

**** (?=...)
     当...匹配才成功。为提前假设，不消耗字符串。如"Isaac (?=Asimov)"只
     有当"Isaac "后有字符串"Asimov"时才匹配成功。
     
     #+BEGIN_SRC python :session
       import re

       re.findall('Isaac (?=Asimov)', 'Isaac')
       re.findall('Isaac (?=Asimov)', 'Isaac Asimov')
     #+END_SRC
     
     #+RESULTS[2ce943bcbd23be1249a797c6490db4fdac85e6b3]:
     :
     : >>> []
     : ['Isaac ']
     
**** (?!...)
     当...不匹配时才成功。为提前假设，不消耗字符串。如“Isaac
     (?!Asimov)”只有当"Isaac "后不是"Asimov"才成功：

     #+BEGIN_SRC python :session
       import re

       re.findall('Isaac (?!Asimov)', 'Isaac Asimov')
       re.findall('Isaac (?!Asimov)', 'Isaac Asim')
     #+END_SRC

     #+RESULTS[450299fb22f39dd6945c95f7d816e718a723ef18]:
     :
     : >>> []
     : ['Isaac ']

**** (?<=...)
     当前位置前匹配...才成功。也为提前假设，不消耗字符串。如
     (?<=abc)def可将abcdef匹配成功。...需为固定个数的字符，如果abc或
     a|b可以，但a*或a{3,4}则不可以。

     #+BEGIN_SRC python :session
       import re

       m = re.search('(?<=abc)def', 'abcdef')
       m.group(0)
     #+END_SRC

     #+RESULTS[da583083430ea899544b1115ebd8cda5c730b752]:
     :
     : >>> >>> 'def'

     如匹配前面有短横线的单词：

     #+BEGIN_SRC python :session
       import re
       m = re.search('(?<=-)\w+', 'spam-egg')
       print(m.group(0))
     #+END_SRC

     #+RESULTS[96e23d18b42112fb158ee88b04f2157b541a142a]:
     :
     : >>> egg

**** (?<!...)
     当前位置前不匹配...才成功。与(?<=...)相同，也为提前假设，不消耗字
     符串；...字符串个数需固定。

     #+BEGIN_SRC python :session
       import re
       re.findall('^(?<!-)\w+', 'spam-egg')
       re.findall('(?<![a-z])\w+', 'spam-egg')
     #+END_SRC

     #+RESULTS[55ae9073dd63d587979f22e512c1332d3f353168]:
     :
     : ['spam']
     : ['spam', 'egg']

**** (?(id/name)yes-pattern|no-pattern)
     如果给定ID/NAME指定的匹配组存在，则使用yes-pattern，否则使用
     no-pattern。如下面简化的邮箱匹配正则：
     
     #+BEGIN_SRC python :session
       import re
       pattern = re.compile('^(<)?(\w+@\w+(?:\.\w+)+)(?(1)>|$)')
       for email in ["<user1@host.com>", "user2@host.com", "<user3@host.com", "user4@host.com>"]:
           if pattern.search(email):
               print(email)
     #+END_SRC
     
     #+RESULTS[d8cf2ffb28d6b1247dd9511ad9632d8f72963db2]:
     :
     : >>> ... ... ... <user1@host.com>
     : user2@host.com
     
*** 特殊转义字符
    如果转义下面没有列出的字符，只会匹配第二个。如\$会匹配$：

    #+BEGIN_SRC python :session
      import re

      re.findall('\$', '$')
    #+END_SRC

    #+RESULTS[037ca02c2abe1c063ca7555df2a105fb87a8336a]:
    :
    : >>> ['$']

**** \number
     反向索引。不能使用8进制数，最大数值99。

     #+BEGIN_SRC python :session
       import re
       m = re.search(r'(.+) \1', '55 5')
       m.group()
     #+END_SRC

     #+RESULTS[cb0c55418b4b668d953f47d1688c9e3219a59121]:
     :
     : >>> '5 5'
     
**** \A
     匹配字符串起始位置。
**** \b
     匹配单词边界。一个单词为Unicode字母或下划线组成的序列，所以结束单
     词的字符含：非alphnum字符、非下划线。

     严格将，\b的定义为\w和\W间（或相反），或\w和字符串首/尾。

     #+BEGIN_SRC python :session
       import re
       pattern = re.compile(r'\bfoo\b')
       for x in ['foo', 'foo.', '(foo)', 'bar foo baz', 'foobar', 'foo3']:
           if pattern.search(x):
               print(x)
     #+END_SRC

     #+RESULTS[77147a892c8ffad8ff94d4844f21906dd6dac995]:
     :
     : >>> ... ... ... foo
     : foo.
     : (foo)
     : bar foo baz

     默认情况下使用Unicode的alphanum，但可由ASCII标记修改。？？？

     在字符范围中，\b表示backspace字符。

**** \B
     与\b刚好相反。匹配不为单词边界。

     #+BEGIN_SRC python :session
       import re

       pattern = re.compile(r'py\b')

       for x in ['python', 'py3', 'py2', 'py', 'py.', 'py!]']:
           if pattern.search(x):
               print(x)
     #+END_SRC
     
     #+RESULTS[fe1756f9e6a5f0257b3d2b3a15961439e4b889f8]:
     :
     : >>> >>> >>> ... ... ... py
     : py.
     : py!]

**** \d

     #+BEGIN_SRC python :session
       import re

       re.findall(r'\d', '123a')
     #+END_SRC

     #+RESULTS[fae72128019acd161ee76694fbb63a86e0be412c]:
     :
     : >>> ['1', '2', '3']

     - Unicode：
       匹配Unicode数字，即[0-9]及其他数字字符？？？。如果使用ASCII标记，
       则相当于[0-9]，由于此标记影响整个正则，所有最好使用[0-9]。

     - 8-bit：
       等价于[0-9]

**** \D
     与\d相反。匹配所有非Unicode数字字符。如果使用了ASCII标记，相当于
     [^0-9]。由于使用标记会影响整个正则，所以最好使用[^0-9]。

     #+BEGIN_SRC python :session
       import re

       re.findall(r'\D', '\X001')
     #+END_SRC

     #+RESULTS[e4ad15a9cd0d2cdc7ac92b515f2b5973b31274ad]:
     :
     : >>> ['\\', 'X']

**** \s
     
     #+BEGIN_SRC python :session
       import re
       re.findall('\s', ' a\t\n\r\f\vb')
     #+END_SRC
     
     #+RESULTS[ae98d13f622826d346f31aaa456f4c7922479de5]:
     :
     : [' ', '\t', '\n', '\r', '\x0c', '\x0b']
     
     - Unicode
       匹配空白字符，含[ \t\n\r\f\v]，及其他许多字符？？？。如果使用了
       ASCII标记，则相当于[ \t\n\r\f\v]。由于标记会影响整个正则，所以
       需要时使用[ \t\n\r\f\v]。
     - 8-bit字符串
       等价于[ \t\n\r\f\v]。
       
**** \S
     与\s相反。
**** \w

     #+BEGIN_SRC python :session
       import re
       re.findall('\w', '我有一个梦想！')
     #+END_SRC

     #+RESULTS[ecd40b71a81cbec7a0e7480cba4fdc9c5d255d7e]:
     :
     : ['我', '有', '一', '个', '梦', '想']

     - Unicode：
       匹配组成单词的字符。含所有语言中能组成单词的字符，以及数字和下
       划线。如果使用ASCII标记，则相当于[a-zA-Z0-9_]。
     - 8-bit
       等价于[a-zA-Z0-9_]。

**** \W
     与\w相反。
**** \Z

     匹配字符串结束处。？？？

**** 其他
     大多数Python字面量字符串的转义字符，正则中也可解析：

     #+BEGIN_QUOTE
     \a	\b	\f	\n
     \r	\t	\u	\U
     \v	\x	\\
     #+END_QUOTE

     注意点：

     - \b在正则中为单词边界，在字符类中为backspace
     - \u和\U只在Unicode模式下为转义字符。在bit模式下为普通字符。
     - 如果第一个转义字符为0，或有3个八进制数字，则被看做八进制转义。
       否则被看做组匹配反向索引。在字符串字面量中，8进制转义字符最多有
       3个数字字符相邻。
     - 3.6版本开始，使用\转义无效字符将被禁用。

** 模块内容
   此模块定义了几个函数、常量和Exception。其中一些函数仅是编译正则方法
   的简化版。
   
   *注意* ：最好使用编译正则的方法。
   
*** 常量
**** re. *A*
**** re. *ASCII*
     使\w、\W、\b、\B、\d、\D、\s和\S仅匹配ASCII对应的字符，而不是匹配
     所有Unicode对应的字符。仅对Unicode正则有效，对byte正则无效。
     
     #+BEGIN_SRC python :session
       import re
       re.findall('\w', 'a一')
       re.findall('\w', 'a一', re.ASCII)
       bytes('a一', 'utf-8')
       re.findall(b'\w', bytes('a一', 'utf-8'))
       re.findall(b'\w', bytes('a一', 'utf-8'), re.ASCII)
     #+END_SRC

     #+RESULTS[ed4d0f18798a1a874b7a6f50735b63e6d7bc0399]:
     :
     : ['a', '一']
     : ['a']
     : b'a\xe4\xb8\x80'
     : [b'a']
     : [b'a']
     
**** re. *DEBUG*
     显示编译正则的Debug信息。

     #+BEGIN_SRC python :session
       import re
       re.compile('\w', re.DEBUG)
     #+END_SRC

     #+RESULTS[ada664fa569b3f8ea09eeaf17f5b73a3dabfe1a1]:
     :
     : IN
     :   CATEGORY CATEGORY_WORD
     : re.compile('\\w', re.DEBUG)

**** re. *I*
**** re. *IGNORECASE*
     不区分大小写，所以[A-Z]也会匹配小写字母。不会被本地环境影响，且对
     Unicode字符也有效。

     #+BEGIN_SRC python :session
       import re

       re.findall('[A-Z]', 'abc', re.IGNORECASE)
     #+END_SRC

     #+RESULTS[7ad7a5fe7c5ee7a3ae88b79dabdb0c3866209e2e]:
     :
     : >>> ['a', 'b', 'c']
     
**** re. *L*
**** re. *LOCALE* （3.6版本将废除）
     使\w、\W、\b、\B、\d、\D、\s和\S依赖本地环境决定匹配。不建议在本
     地字符环境不可靠的情况下使用，且每次只处理一种“文化（culture）”。

**** re. *M*
**** re. *MULTILINE*
     默认情况下，^只匹配字符串起始；$匹配字符串末尾，以及字符串末尾换
     行符（如果有）前。

     使用此标记后：^匹配匹配字符串起始和紧跟换行符后的位置；$匹配字符
     串末尾和换行符前。

     *？* ：好像只是改变了^的行为。

**** re. *S*
**** re. *DOTALL*
     默认情况下“.”匹配除换行符以外的任意字符。使用此标记后也可匹配换行
     符。

     #+BEGIN_SRC python :session
       import re

       re.findall('.', '\n')
       re.findall('.', '\n', re.DOTALL)
     #+END_SRC

     #+RESULTS[8fde86e5ae455a6ace3e19b674dfea011737c287]:
     :
     : >>> []
     : ['\n']

**** re. *X*
**** re. *VERBOSE*
     允许多行书写正则表达式，且可添加注释。
     
     规则：
     
     1. 除字符类，和前面有非转义的反斜杠外，所有空格字符都会被忽视。
     2. 除在字符类，以及前面有非转义反斜杠外的“#”，后面的内容会被作为
        注释。

     #+BEGIN_SRC python :session
       import re

       a = re.compile(r"""\d +         # 整数部分
       \.                              # 小数点
       \d *                            # 小数部分
       """, re.VERBOSE)

       b = re.compile(r'\d+\.\d*')

       a.findall('1.23 1.2 1')
       b.findall('1.23 1.2 1')
     #+END_SRC

     #+RESULTS[8375df4dd1724dfe2e11fdcb380e6a9e83fd025b]:
     :
     : >>> ... ... ... >>> >>> >>> >>> ['1.23', '1.2']
     : ['1.23', '1.2']

*** 函数
**** re. *compile* (pattern,flags=0)
     将正则表达式编译为正则对象，以使用下一节介绍的match()和search()等
     方法。

     可使用上一节介绍的标记修改正则对象，如需使用多个标记，需使用二进
     制运算符“|”结合。
     
     #+BEGIN_SRC python :eval never
       import re
       prog = re.compile(pattern)
       result = prog.match(string)
     #+END_SRC
     
     等价于：
     
     #+BEGIN_SRC python :eval never
       import re
       result = re.match(pattern, string)
     #+END_SRC

     但如果但单个程序中多次复用一个正则，使用re.compile()方法编译后效
     率更高。

**** re. *search* (pattern,string,flags=0)
**** re. *match* (pattern,string,flags=0)
**** re. *fullmatch* (pattern,string,flags=0)
**** re. *split* (pattern,string,maxsplit=0,flags=0)
**** re. *findall* (pattern,string,flags=0)
**** re. *finditer* (pattern,string,flags)
**** re. *sub* (pattern,repl,string,count=0,flags=0)
**** re. *subn* (pattern,repl,string,count=0,flags=0)
**** re. *escape* (siring)
**** re. *purge* ()
*** Exception
**** exception re. *error* (msg,pattern=None,pos=None )
***** *msg*
***** *pattern*
***** *pos*
***** *lineno*
***** *colno*
** 正则表达式对象
** 正则匹配对象
   匹配对象总是具有布尔值True。由于当match()和search()匹配失败后会返回
   None，可使用此特性判断是否匹配成功：
   
   #+BEGIN_SRC python :eval never
     match = re.search(pattern, string)
     if match:
         process(match)
   #+END_SRC
   
   匹配对象支持下列方法和熟悉：
*** 方法
**** match. *expand* (template)
     在模板字符串TEMPLATE中使用反向索引获取正则中匹配的分组。TEMPLATE
     中可使用数字反向索引，如\1和\2，和命名分组，如\反向索引替换匹配内
     容。
     
     #+BEGIN_SRC python :session
       import re

       m = re.match(r'(?P<first>\w+) (\w+)', 'hello world!')
       m.expand(r'\g<2> \1 \g<first>')
     #+END_SRC
     
     #+RESULTS[3f50ae1a7a1abe547ca4977b5259200def7b165e]:
     :
     : >>> >>> 'world hello hello'
     
**** match. *group* ([group1,...])
     返回分组匹配内容。

     - 参数默认为0，即整个匹配对象。
     - 如果有多个参数，则是匹配结果组成的元组。
     - 如果是1-99间的数字，则对应正则的各个分组。
     - 如果参数值大于正则的分组数量，则抛出IndexError错误。
     - 如果正则中分组没匹配任何内容，对应值为None。
     - 如果匹配多个，则返回最后一个。

     #+BEGIN_SRC python :session
       import re

       m = re.match(r'(\w+) (\w+)', 'Isaac Newton, physicist')
       m.group(0)
       m.group(1)
       m.group(2)
       m.group(1, 2)
     #+END_SRC

     #+RESULTS[4346f5c0db5d449b9c8545fff03d9c5a60740cb0]:
     :
     : >>> >>> 'Isaac Newton'
     : 'Isaac'
     : 'Newton'
     : ('Isaac', 'Newton')
     
     如果使用了正则命名分组的扩展功能（(?P<name>)），参数即可使用数字，
     也可使用NAME进行反向索引。如果参数使用的字符串没有该命名分组，则
     返回IndexError错误：
     
     #+BEGIN_SRC python :session
       import re

       m = re.match(r'(?P<first_name>\w+) (?P<last_name>\w+)', 'Malcolm Reynolds')

       m.group('first_name'), m.group('last_name')
       m.group(1), m.group(2)
     #+END_SRC
     
     #+RESULTS[416c0faee3171c2eb53e55c82bf781785704e558]:
     :
     : >>> >>> >>> ('Malcolm', 'Reynolds')
     : ('Malcolm', 'Reynolds')
     
     如果分组匹配多次，则返回最后匹配的内容：
     
     #+BEGIN_SRC python :session
       import re

       m = re.match(r'(..)+', 'aab2c3')
       m.group(1)
       m.group(0)
     #+END_SRC
     
     #+RESULTS[21b4b33aa5d52bbe73c01b3e13c87ac93ecd32e3]:
     :
     : >>> >>> 'c3'
     : 'aab2c3'
     
     多层嵌套情况下，消耗完一个整体后逐渐向后推移分组编号：
     
     #+BEGIN_SRC python :session
       from re import match

       m = match('(((a)))(b)', 'ab')
       m.group()
       m.group(1)
       m.group(2)
       m.group(3)
       m.group(4)
     #+END_SRC
     
     #+RESULTS[3e2e22877d4c80a9581570d8ad461ee7d32e0d35]:
     :
     : >>> >>> 'ab'
     : 'a'
     : 'a'
     : 'a'
     : 'b'
     
**** match. *groups* (default=None)
     返回元组，由所有单独分组匹配内容组成。
     
     #+BEGIN_SRC python :session
       import re
       m = re.match(r'(\d+)\.(\d+)', '3.14159')
       m.groups()
     #+END_SRC
     
     #+RESULTS[884d7a63d90f29c74bb4e4c5612fd0b70acf289c]:
     :
     : >>> ('3', '14159')
     
     如果正则中有分组不匹配任何内容，可使用DEFAULT参数指定其值，默认值
     为None：
     
     #+BEGIN_SRC python :session
       import re
       m = re.match(r'(\d+)\.?(\d+)?(\w+)?', '123')
       m.groups()
       m.groups('没有匹配')
     #+END_SRC
     
     #+RESULTS[af808ee7c37bcb469a1a6a66463e393253134506]:
     :
     : >>> ('123', None, None)
     : ('123', '没有匹配', '没有匹配')
     
     没有分组返回空字典：
     
     #+BEGIN_SRC python :session
       from re import match

       m = match('a', 'a')
       m.groupdict()
     #+END_SRC
     
     #+RESULTS[a6a3a4c6fdff891034f4abaea1210234894793cc]:
     :
     : >>> >>> {}
     
**** match. *groupdict* (default=None)
     返回字典对象，key为正则的命名分组名，value为匹配内容。

     DEFAULT参数与groups方法相同。

     #+BEGIN_SRC python :session
       import re

       m1 = re.match(r'(?P<first_name>\w+) (?P<last_name>\w+)', 'Malcolm Reynolds')
       m1.groupdict()

       m2 = re.match(r'(?P<first_name>\w+) (?P<last_name>\w+)(?P<suffex>\w)?',
                     'Malcolm Reynolds')

       m2.groupdict('Phd')
     #+END_SRC

     #+RESULTS[8a7938cf7becadb18e1ee956d6978ad48fe9e1f4]:
     :
     : >>> >>> {'last_name': 'Reynolds', 'first_name': 'Malcolm'}
     : >>> ... >>> >>> {'last_name': 'Reynolds', 'first_name': 'Malcolm', 'suffex': 'Phd'}

**** match. *start* ([group])
**** match. *end* ([group])
     返回GROUP匹配内容的首尾索引。如果正则分组存在，但不匹配任何字符串，
     则返回-1。

     #+BEGIN_SRC python :session
       import re

       m = re.match(r'(\w+) \w+ (.)?', 'Michael Jackson ')
       m.groups()
       m.start(), m.end()
       m.start(0), m.end(0)
       m.start(1), m.end(1)
       m.start(2), m.end(2)
     #+END_SRC
     
     #+RESULTS[6359d0464ff69e38123bbdd97411c7d44e21f69a]:
     :
     : >>> >>> ('Michael', None)
     : (0, 16)
     : (0, 16)
     : (0, 7)
     : (-1, -1)
     
     对于匹配对象m，如果有正则分组g匹配有内容，则m.group(g)等价于：
     
     #+BEGIN_SRC python :eval never
       m.string[m.start(g):m.end(g)]
     #+END_SRC

     *注意* ：如果分组匹配空字符串（即纯在分组，但不匹配任何内容），
     m.start(group)会与m.end(group)相等。如下例：

     #+BEGIN_SRC python :session
       import re

       m = re.search('b(c?)', 'cba')
       m.group(0)
       m.group(1)

       m.start(0), m.end(0)
       m.start(1), m.end(1)
     #+END_SRC

     #+RESULTS[d00e11c23036607a93602bc2110e5fa07bd85c13]:
     :
     : >>> >>> 'b'
     : ''
     : >>> (1, 2)
     : (2, 2)

     下例为删除 /remove_this/ 的例子：

     #+BEGIN_SRC python :session
       import re

       email = '3261958605@qremove_thisq.com'
       m = re.search('remove_this', email)
       email[:m.start()] + email[m.end():]
     #+END_SRC

     #+RESULTS[9f7eb4ef041bb44d69fcdcd36102b0b01e2e82c9]:
     :
     : >>> >>> >>> '3261958605@qq.com'

**** match. *span* ([group])
     返回由m.start(group)和m.end(group)组成的2元素元组。如果GROUP不匹
     配任何内容，则为(-1, -1)。GROUP默认值为Default。

     #+BEGIN_SRC python :session
       import re

       m = re.search('(\w+) (\w+)', 'Michael Jackson')
       m.span(0)
       m.span(1)
       m.span(2)
     #+END_SRC

     #+RESULTS[32b1236ad224a15c5c8cc948695214121a86deda]:
     :
     : >>> >>> (0, 15)
     : (0, 7)
     : (8, 15)

*** 属性
**** match. *pos*
     可能等于传递个正则对象方法search()和match()的POS参数值。即正则对
     象开始进行查找时的位置：

     #+BEGIN_SRC python :session
       import re

       pattern = re.compile('(\w+)')
       m = pattern.match('Michael Jackson', -1)
       m.group(0)
       m.pos
     #+END_SRC

     #+RESULTS[1e4714847ab10ab751f87b54553cb02020dd5605]:
     :
     : >>> >>> >>> 'Michael'
     : 0

**** match. *endpos*
     即正则结束搜索的后一个位置。可能等于传递给正则对象方法search()和
     match()的ENDPOS参数值。

     #+BEGIN_SRC python :session
       import re

       pattern = re.compile(r'(\w+)')
       m = pattern.search('Michael Jackson', 0, 40)
       m.group()
       m.group(1)
       m.endpos
     #+END_SRC

     #+RESULTS[1178e40ecf05c7f7e6e2d14e3bc8a728d3e24511]:
     :
     : >>> >>> >>> 'Michael'
     : 'Michael'
     : 15

**** match. *lastindex*
     最后一个有匹配内容的正则分组索引（从1起）。如果没有分组，或分组不
     匹配任何内容则返回None。

     #+BEGIN_SRC python :session
       from re import match

       match('(a)b', 'ab').lastindex
       match('((a)(b))', 'ab').lastindex
       match('((ab))', 'ab').lastindex

       match('(a)(b)', 'ab').lastindex

       print(match('ab', 'ab').lastindex)
       print(match('ab(.)?', 'ab').lastindex)
     #+END_SRC

     #+RESULTS[c861e30e0bfa4b2b43ab88e13425c40bf8d7ff44]:
     :
     : >>> 1
     : 1
     : 1
     : >>> 2
     : >>> None
     : None

**** match. *lastgroup*
     返回最后一个分组的名称。如果最后一个分组没有名称，或分组不匹配任
     何内容，或没有分组，返回None。

     #+BEGIN_SRC python :session
       from re import match

       match('(?P<first_name>\w+) (?P<last_name>\w+)', 'Michael Jackson').lastgroup
       print(match('(?P<first_name>\w+) (\w+)', 'Michael Jackson').lastgroup)
       print(match('\w+ \w+', 'Michael Jackson').lastgroup)
     #+END_SRC

     #+RESULTS[f098162debbf03907205be42587e8600c3347198]:
     :
     : >>> 'last_name'
     : None
     : None

**** match. *re*
     作为参数传递给search()和match()方法的正则参数。
     #+BEGIN_SRC python :session
       import re
       pattern = re.compile('(\w+) (\w+)')

       m = re.match(r'(\w+) (\w+)', 'Michael Jackson')
       m1 = pattern.match('Michael Jackson')
       type(m.re), m.re
       m1.re
     #+END_SRC
     
     #+RESULTS[3970cca851b2b252546d8cc572145d5ff2fc3c20]:
     :
     : >>> >>> >>> >>> (<class '_sre.SRE_Pattern'>, re.compile('(\\w+) (\\w+)'))
     : re.compile('(\\w+) (\\w+)')
     
**** match. *string*
     作为参数传递给search()和match()方法，用于被搜索的字符串参数。

     #+BEGIN_SRC python :session
       import re
       m = re.match(r'(\w+) (\w+)', 'Michael Jackson')
       m.string
     #+END_SRC

     #+RESULTS[11670b75f063bd545a9b7ec24a74ca84f21c875e]:
     :
     : >>> >>> 'Michael Jackson'

** 使用举例
* difflib
* textwrap
* unicodedate
* stringprep
* readline
* rlconpleter
