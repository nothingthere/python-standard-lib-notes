# Author: Claudio <3261958605@qq.com>
# Created: 2017-04-20 17:08:42
# Commentary:
#+TITLE: 文本处理

* str - 常用字符串操作
** 字符串常量
*** string. *ascii_letters*
    ascii_lowercase和ascii_uppercase的结合。不由本地决定。

    #+BEGIN_SRC python :session
      import string
      string.ascii_letters
    #+END_SRC

    #+RESULTS[dbc0c195ea9116af68a930af514a83f8927d0f88]:
    :
    : 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

*** string. *ascii_lowercase*
    小写字符。不由本地决定。

    #+BEGIN_SRC python :session
      import string
      string.ascii_lowercase
    #+END_SRC

    #+RESULTS[43fac96fdd9792434ad6a060c9837b3382fe275e]:
    :
    : 'abcdefghijklmnopqrstuvwxyz'

*** string. *ascii_uppercase*
    大写字母。不由本地决定。

    #+BEGIN_SRC python :session
      import string
      string.ascii_uppercase
    #+END_SRC

    #+RESULTS[3cc03248df9135f10c36b1d3ac4495c448e24ba1]:
    :
    : 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

*** string. *digits*

    #+BEGIN_SRC python :session
      import string
      string.digits
    #+END_SRC

    #+RESULTS[e90c3f3c2fff08a17d66c41e0b63e02925b58a4a]:
    :
    : '0123456789'

*** string. *hexdigits*

    #+BEGIN_SRC python :session
      import string
      string.hexdigits
    #+END_SRC

    #+RESULTS[10cdf01fc31dcc5777ec14d860faadc68e31268e]:
    :
    : '0123456789abcdefABCDEF'

*** string. *octdigits*

    #+BEGIN_SRC python :session
      import string
      string.octdigits
    #+END_SRC

    #+RESULTS[13332f71f3c21f481367d49f832f13393abb015f]:
    :
    : '01234567'

*** string. *punctuation*
    String of ASCII characters which are considered punctuation
    characters in the C locale.

    #+BEGIN_SRC python :session
      import string
      string.punctuation
    #+END_SRC

    #+RESULTS[7cabb4253ee71483da078dbdd7c55d5ec8426f1b]:
    :
    : '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'

*** string. *printable*
    digits、ascii_letters、punctuation和whitespace的结合。

    #+BEGIN_SRC python :session
      import string
      string.printable
    #+END_SRC

    #+RESULTS[20dbfe464a9005e43fa7130f2344ef55fcc4653b]:
    :
    : '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n\r\x0b\x0c'

*** string. *whitespace*
    含空格、tab、linefeed、return、formfeed和vertical tab。
    
    #+BEGIN_SRC python :session
      import string
      string.whitespace
    #+END_SRC

    #+RESULTS[7669f40dfae6126e364d36dfd57163f468b01bbb]:
    :
    : ' \t\n\r\x0b\x0c'

** 定制字符串格式 ？？？
*** class string. *Formatter*
**** *format* (format_string,*arg,**kwargs)

     #+BEGIN_SRC python :session
       from string import Formatter

       temp = 'hello {}'
       temp.format('world')

       # Formatter.format(temp,'')
     #+END_SRC

     #+RESULTS[0d139b494a1eddbd3eaa6ed75253b7ef0f782060]:
     :
     : >>> >>> 'hello world'

**** *vformat* (format_string,args,kwargs)
**** *parse* (format_string)
**** *get_field* (field_name,args,kwargs)
**** *get_value* (key,args,kwargs)
**** *check_unused_args* (used_args,args,kwargs)
**** *format_field* (value,format_spec)
**** *convert_field* (value,conversion)
** 字符串格式语法
   格式化字符串时，str.format()方法和Formatter类使用相同的语法。使用后
   者时，可定制格式语法。
   
   格式字符串中需被替换的地方使用{}，其余文本保持原样。如需表示{}本身，
   需使用{{}}。
   
   一些简单的例子：
   
   #+BEGIN_SRC python :session
     import string

     'First, thou shalt count to {0}'.format(1000)
     'Bring me a {}'.format('book')
     'From {} to {}'.format('New York', 'China')
     'My quest is {name}'.format(name='Claudio')
     'Units destroyed: {player[0]}'.format(player=[1, 2, 3])
     'Weight in tons {0.digits}'.format(string)
   #+END_SRC
   
   #+RESULTS[ad8196a5794c94864c2ca2f0013241ca39d784a2]:
   :
   : >>> 'First, thou shalt count to 1000'
   : 'Bring me a book'
   : 'From New York to China'
   : 'My quest is Claudio'
   : 'Units destroyed: 1'
   : 'Weight in tons 0123456789'
   
   一般情况下，使用format函数时调用的是对象上的__format__()方法。不过，
   可使用下面三个标记转换：
   
   | 标记 | 调用函数 |
   |------+----------|
   | !s   | str()    |
   | !r   | repr()   |
   | !a   | ascii()  |
   
   #+BEGIN_SRC python :session
     '我是一个聪明的 {!s}'.format('男孩')
     '我是一个聪明的 {!r}'.format('男孩')
     '我是一个聪明的 {!a}'.format('男孩')
   #+END_SRC
   
   #+RESULTS[17870e409219a15570f5dad1340074afa9113f69]:
   : '我是一个聪明的 男孩'
   : "我是一个聪明的 '男孩'"
   : "我是一个聪明的 '\\u7537\\u5b69'"
   
*** 格式规范
    模板字符串中可使用下列标记格式输出。
**** 对齐标记
     | 标记 | 含义                              |
     |------+-----------------------------------|
     | <    | 左对齐                            |
     | >    | 右对齐                            |
     | \=   | 仅对数字有效。在正/负号前增加间距 |
     | \^   | 居中对齐                          |
     
     #+BEGIN_SRC python :session
       name = 'claudio'

       '{}'.format(name)
       '{:>10}'.format(name)
       '{:<10}'.format(name)
       '{:=10}'.format(-100)
       '{:^10}'.format(name)
     #+END_SRC
     
     #+RESULTS[ecf346eb362e33e9160bba6190a0a11c2410e8b8]:
     :
     : >>> 'claudio'
     : '   claudio'
     : 'claudio   '
     : '-      100'
     : ' claudio  '
     
**** 对数字正负号的标记

     | 标记  | 含义                         |
     |-------+------------------------------|
     | +     | 不管正负数，都在前面添加符号 |
     | -     | 仅在负数前添加符号           |
     | space | 整数前用空格，负数前用负号   |

     #+BEGIN_SRC python :session
       '{:+}'.format(100)
       '{:+}'.format(-100)

       '{:-}'.format(100)
       '{:-}'.format(-100)

       '{: }'.format(100)
       '{: }'.format(-100)
     #+END_SRC

     #+RESULTS[45bf5deb6bd6ff4171aad64fd3efccb562f068fe]:
     : '+100'
     : '-100'
     : >>> '100'
     : '-100'
     : >>> ' 100'
     : '-100'

**** 整数进制转换

     | 标记 | 含义                                |
     |------+-------------------------------------|
     | b    | 二进制                              |
     | c    | 转换为Unicode字符                   |
     | d    | 10进制                              |
     | o    | 8进制                               |
     | x    | 16进制，小写                        |
     | X    | 16进制，大写                        |
     | n    | 同'd'，不过会使用本地环境的间隔字符 |
     | None | 同'd'                               |

     此外，还可使用下面表示浮点数的标记。

     #+BEGIN_SRC python :session
       n = 10
       '{:b}'.format(n)
       '{:c}'.format(n)
       '{:d}'.format(n)
       '{:o}'.format(n)
       '{:x}'.format(n)
       '{:X}'.format(n)
       '{:n}'.format(n)
       '{:}'.format(n)
     #+END_SRC
     
     #+RESULTS[29af31cdf7cc6c6480470e2f38ab32044cea119d]:
     :
     : '1010'
     : '\n'
     : '10'
     : '12'
     : 'a'
     : 'A'
     : '10'
     : '10'

     可使用“#”显示进制：

     #+BEGIN_SRC python :session
       n = 10
       '{:#b}'.format(n)
       '{:c}'.format(n)
       '{:#d}'.format(n)
       '{:#o}'.format(n)
       '{:#x}'.format(n)
       '{:#X}'.format(n)
       '{:#n}'.format(n)
       '{:#}'.format(n)
     #+END_SRC

     #+RESULTS[50be5b3b00ec1a3e12e2421107e20074e88ce3f9]:
     :
     : '0b1010'
     : '\n'
     : '10'
     : '0o12'
     : '0xa'
     : '0XA'
     : '10'
     : '10'

     还可使用“,”在数字中插入逗号：

     #+BEGIN_SRC python :session
       '{:,}'.format(1233456)
       '{:,}'.format(12334.56)
     #+END_SRC

     #+RESULTS[c285eba7a28d863f64d13e88be34504cd77975af]:
     : '1,233,456'
     : '12,334.56'

**** 浮点数和整数都可用的标记
     
     | 标记 | 含义                               |
     |------+------------------------------------|
     | e    | 科学计数法，小写e，默认精度6       |
     | E    | 同上，大写E                        |
     | f    | 固定小数点后位数为6位              |
     | F    | 同上，不过将nan变为NAN，inf变为INF |
     | g    |                                    |
     | G    | 智能使用科学计数法                 |
     | n    | 同g，不过根据本地环境插入分割字符  |
     | %    | 百分数表示                         |
     | None | 同g，。。。                        |

     #+BEGIN_SRC python :session
       n = 123456789.123456789
       # import math
       # n = math.pi
       '{:e}'.format(n)
       '{:E}'.format(n)
       '{:f}'.format(n)
       '{:F}'.format(n)
       '{:g}'.format(n)
       '{:G}'.format(n)
       '{:n}'.format(n)
       '{:%}'.format(n)
       '{:}'.format(n)
     #+END_SRC

     #+RESULTS[3049f910b6f0410f5423f380d04d5552d37570ad]:
     #+begin_example

     ... ... '1.234568e+08'
     '1.234568E+08'
     '123456789.123457'
     '123456789.123457'
     '1.23457e+08'
     '1.23457E+08'
     '1.23457e+08'
     '12345678912.345678%'
     '123456789.12345679'
     #+end_example

*** 格式例子
    大多数情况下，与使用%的传统形式相同，如'%03.2f'等价于'{:03.2f}'，
    即使用冒号和大括号替换了百分号。
    
    不过，此新新形式添加了一些先用法，下面例子中会体现。
    
**** 通过位置获取参数
     
     #+BEGIN_SRC python :session
       '{0}, {1}, {2}'.format('a', 'b', b'c')
       '{}, {}, {}'.format('a', 'b', 'c')
       '{2}, {1}, {0}'.format('a', 'b', 'c')
       '{2}, {1}, {0}'.format(*'abc')
       '{0} and {1!r} and {0}'.format('apple', 'banana')
     #+END_SRC
     
     #+RESULTS[41fdca0209912ddff3a7f23f0cf4412f661662fd]:
     : "a, b, b'c'"
     : 'a, b, c'
     : 'c, b, a'
     : 'c, b, a'
     : "apple and 'banana' and apple"
     
**** 通过名称获取参数

     #+BEGIN_SRC python :session
       '{country}的首都是{capital}'.format(country='中国', capital='北京')

       item = {'country': '中国', 'capital': '北京'}
       '{country}的首都是{capital}'.format(**item)
     #+END_SRC

     #+RESULTS[efc629a84afdde096307cff5ccf4cb4b70f4e72d]:
     : '中国的首都是北京'
     : >>> >>> '中国的首都是北京'

**** 获取参数的属性

     #+BEGIN_SRC python :session
       c = 3 - 5j
       '复数{0}的实部为：{0.real}, 虚部为：{0.imag}'.format(c)

       class Point:
           def __init__(self, x, y):
               self.x, self.y = x, y
           def __str__(self):
               return 'Point({self.x}, {self.y})'.format(self=self)

       str(Point(3, 3))
     #+END_SRC

     #+RESULTS[c360263864b417d4161470c009ce24f9f9910113]:
     :
     : '复数(3-5j)的实部为：3.0, 虚部为：-5.0'
     : >>> ... ... ... ... ... >>> 'Point(3, 3)'

**** 获取参数中的元素

     #+BEGIN_SRC python :session
       point = [1, 2]
       'X: {0[0]}; Y: {0[1]}'.format(point)
     #+END_SRC

     #+RESULTS[44c43572d18bbdfac83cdb06b2e9cfc67ec420bf]:
     :
     : 'X:      1; Y: 2'

**** 使用%s代替%r

     #+BEGIN_SRC python :session
       'reper()函数会显示引号：{!r}；str()函数则不会：{!s}'.format('abc', 'ABC')
     #+END_SRC

     #+RESULTS[7ffd29edf6f25d4e7584bc7ea2b28592bd4228a5]:
     : "repr()函数会显示引号：'abc'；str()函数则不会：ABC"

**** 对齐和指定宽度
     中文占两个字母宽度？？？
     
     #+BEGIN_SRC python :session
       '{:<20}'.format('左对齐')
       '{:>20}'.format('右对齐')
       '{:^20}'.format('居中')
       '{:*^20}'.format('居中，用信号填补空白')
     #+END_SRC
     
     #+RESULTS[324468f0b45ad342ac39828391573e69028d3c3c]:
     : '左对齐                 '
     : '                 右对齐'
     : '         居中         '
     : '*****居中，用信号填补空白*****'
     
**** 替换%+f、%-f和%f，并添加正负号

     #+BEGIN_SRC python :session
       from math import pi

       '{:+f}; {:+f}'.format(pi, -pi)
       '{: f}; {: f}'.format(pi, -pi)
       '{:-f}; {:-f}'.format(pi, -pi)
     #+END_SRC

     #+RESULTS[9d9709337e8bb17e10f6ea020a3ab96182c7b6a7]:
     :
     : >>> '+3.141593; -3.141593'
     : ' 3.141593; -3.141593'
     : '3.141593; -3.141593'

**** 替换%x和%o，并转换不同进制

     #+BEGIN_SRC python :session
       '10进制：{0:d}，16进制：{0:x}；8进制：{0:o}; 2进制：{0:b}'.format(42)
       '10进制：{0:d}，16进制：{0:#x}；8进制：{0:#o}; 2进制：{0:#b}'.format(42)
     #+END_SRC

     #+RESULTS[2cad6a8e795f81c756462863e55fa248aaf208e2]:
     : '10进制：42，16进制：2a；8进制：52; 2进制：101010'
     : '10进制：42，16进制：0x2a；8进制：0o52; 2进制：0b101010'

**** 使用逗号分割大数字

     #+BEGIN_SRC python :session
       '{:,}'.format(123456789)
     #+END_SRC

     #+RESULTS[5f51ce4e908837634f9c240f8eb939d04800ccce]:
     : '123,456,789'

**** 添加百分号

     #+BEGIN_SRC python :session
       '{:%}'.format(1 / 3)
       '{:.2%}'.format(1 / 3)
     #+END_SRC

     #+RESULTS[63b0909883ed719c3d68a87ee2643a99578e3b74]:
     : '33.333333%'
     : '33.33%'

**** 使用类型专门的格式

     #+BEGIN_SRC python :session
       import datetime

       d = datetime.datetime(2017, 4, 22, 21, 30, 55)
       '{:%Y-%m-%d %H:%M:%S}'.format(d)
     #+END_SRC

     #+RESULTS[3e8b8f3d61bd204b69eb01f7305b4c054293a415]:
     :
     : >>> >>> '2017-04-22 21:30:55'

**** 嵌套

     #+BEGIN_SRC python :session
       for align, text in zip('<^>', ['left', 'center', 'right']):
           '{0:{fill}{align}16}'.format(text, fill=align, align=align)

       '{:02X}{:02X}{:02X}{:02X}'.format(*[192, 168, 0, 1])
     #+END_SRC

     #+RESULTS[bdca78ef7e568f0bf1fcc66ba1c40750d05be890]:
     :
     : ... 'left<<<<<<<<<<<<'
     : '^^^^^center^^^^^'
     : '>>>>>>>>>>>right'
     : 'C0A80001'

     #+BEGIN_SRC python :session
       for num in range(5, 12):
           for base in 'dXob':
               print('{0:{width}{base}}'.format(num, base=base, width=5), end='')
           print()
     #+END_SRC

     #+RESULTS[3c3b781a7a6d1d10aeae17fb2e357371278fbb5c]:
     :
     : ... ... ...     5    5    5  101
     :     6    6    6  110
     :     7    7    7  111
     :     8    8   10 1000
     :     9    9   11 1001
     :    10    A   12 1010
     :    11    B   13 1011

** 模板字符串

   #+BEGIN_SRC python :session
     from string import Template
     s = Template('你好，$who。 我是$me。')

     s.substitute(who='world', me='claudio')
   #+END_SRC

   #+RESULTS[83b02956c092b2329a4db9acc744d9719f2c191b]:
   :
   : >>> >>> '你好，world。 我是claudio。'

   基本规则：

   1. $$表示$本身。
   2. $identifier表示需替换处，被映射中key为identifier的值替换。默认情
      况下，identifier需为ASCII小写字母或下划线，首字母须为ASCII小写字
      母或下划线。在第一个非此类字母除将其结束。
   3. $identifier同${identifier}在绝大多数情况下等价，当当需将其置于单
      词中时则必须使用后者，如"${identifier}name"。
   4. 其他任何形式抛出ValueError错误。

*** class string. *Template* (template)
    接受单个模板字符串TEMPLATE，构造模板。
**** *substitute* (mapping,**kwds)
     进行替换，返回新字符串。MAPPING为“类字典”对象，key值对应
     placeholder；也可使用关键字参数，关键字对应placeholder。如果
     MAPPING参数和关键字参数有重名，则关键字参数中的值有效。

     #+BEGIN_SRC python :session
       from string import Template

       temp = Template('hello, ${name}.')
       temp.substitute({'name': 'world'}, name='Claudio')
     #+END_SRC

     #+RESULTS[ecb945d54827f4a43c35b4b65aee492dc6f65b28]:
     :
     : >>> >>> 'hello, Claudio.'

**** *safe_substitute* (mapping,**kwds)
     同substitute基本相同，只是当没找到对应key值时，identifier保持原样
     输出。

     *注意* ：其实一点也不“safe”。

     #+BEGIN_SRC python :session
       from string import Template

       tmp = Template('${who}喜欢${what}')
       tmp.substitute(who='我')
       tmp.safe_substitute(who='你')
     #+END_SRC

     #+RESULTS[2f2410515ff5fe0cf485a3f3225d0d54bb5bbf77]:
     :
     : >>> >>> Traceback (most recent call last):
     :   File "<stdin>", line 1, in <module>
     :   File "/usr/lib/python3.5/string.py", line 129, in substitute
     :     return self.pattern.sub(convert, self.template)
     :   File "/usr/lib/python3.5/string.py", line 119, in convert
     :     val = mapping[named]
     : KeyError: 'what'
     : '你喜欢${what}'

**** *template*
     公共数据属性。返回构建模板时的字符串。不要改变此属性，只将其作为
     自读属性即可。

     #+BEGIN_SRC python :session
       from string import Template

       temp = Template('${who}喜欢${what}')
       temp.template
     #+END_SRC

     #+RESULTS[2ca94bc83125482c792b8f174cffaf55e8d6535f]:
     :
     : >>> >>> '${who}喜欢${what}'

**** 改造
     可以通过集成Template类，定制占位符语法，边界符（delimiter），或整
     个解析模板字符串的正则。可重置的类属性有：
     
     - delimiter：占位符字符串。默认为$。不要使用正则，因为实现会根据
       需要对齐调用re.escape()方法。
       
       #+BEGIN_SRC python :session
         from string import Template

         class MyTemp(Template):
             delimiter = '#'

         temp = MyTemp('hello #{name}')
         temp.substitute(name='world')
       #+END_SRC
       
       #+RESULTS[fc099f2bb9ab16e7c1edf89910812ebd47ec3fae]:
       :
       : >>> >>> ... ... >>> >>> >>> 'hello world'
       
     - idpattern： 在不使用大括号包裹placeholder时，会根据此正则默然添
       加大括号，默认值为[_a-z][_a-z0-9]*。
       
       #+BEGIN_SRC python :session
         from string import Template

         class MyTemp(Template):
             idpattern = '[_a-z][_a-z0-9。]*'

         temp = Template('我喜欢吃$food。')
         mytemp = MyTemp('我喜欢吃${food}。')
         mytemp1 = MyTemp('我喜欢吃$food。')
         # mytemp1 = MyTemp('我喜欢吃$food。')
         temp.substitute(food='orange')
         mytemp.substitute(food='orange')
         mytemp1.substitute(food='orange')
       #+END_SRC
       
       #+RESULTS[0374890ede19258988ff3970e5661dfbf14b2966]:
       #+begin_example
       
       >>> ... ... >>> >>> >>> >>> ... '我喜欢吃orange。'
       '我喜欢吃orange。'
       Traceback (most recent call last):
         File "<stdin>", line 1, in <module>
         File "/usr/lib/python3.5/string.py", line 129, in substitute
           return self.pattern.sub(convert, self.template)
         File "/usr/lib/python3.5/string.py", line 119, in convert
           val = mapping[named]
       KeyError: 'food。'
       #+end_example
       
     - flags：当编译用于识别替换的正则时使用的正则flags。默认值为
       re.IGNORECASE。
       
       *注意* ：re.VERBOSE总是会添加到flags中，所以定制idpatterns属性
       时，需遵从verbose正则的规则。
       
       #+BEGIN_SRC python :session
       from string import Template
       import re

       class Mytemp(Template):
           flags = re.IGNORECASE

       temp = Mytemp('我喜欢吃$food')

       temp.substitute(Food='banana')
       #+END_SRC
       
       #+RESULTS[5000775d8ec6b226692cd1ed152ee8be520d8ac7]:
       :
       : >>> >>> ... ... >>> >>> >>> Traceback (most recent call last): 
       :   File "<stdin>", line 1, in <module>
       :   File "/usr/lib/python3.5/string.py", line 129, in substitute
       :     return self.pattern.sub(convert, self.template)
       :   File "/usr/lib/python3.5/string.py", line 119, in convert
       :     val = mapping[named]
       : KeyError: 'food'
       
     另外，还可重置匹配整个placeholder的属性pattern。其值需为含4组
     “named capture group”的正则。每组与上面的3条规则对应，另外还添加
     了无效placeholder规则：
     
     - escaped：边界符本身的正则。如默认值$$。
     - named：不加大括号匹配placeholder名的正则。不要将边界付置于
       capturing group中。
     - braced：添加大括号时匹配placeholder名的正则。不要将边界符和大括
       号置于capturing group中。
     - invalid：This group matches any other delimiter pattern
       (usually a single delimiter)？？？应出现在整个正则的最后。
       
*** format和Template的区别  [[https://segmentfault.com/q/1010000006709792][@segmentfault]]
    string.Template正如其名，适合于定义模板，如在函数和包里定义好模板，
    就可在任意时间调用，而不用担心其细节；str.format则适合于当行表达式，
    是%-format的替代，更灵活：

    #+BEGIN_SRC python :session
      from string import Template

      class MyTem(Template):
          delimiter = '#'

      tem = MyTem('hello, #{name}')

      print(tem.substitute(name='world'))
    #+END_SRC

    #+RESULTS[598b93ddce9c174f6e2fd165c9b7839f383272cd]:
    :
    : >>> ... ... >>> >>> >>> hello, world

** 帮助函数
*** string. *capwords* (s,sep=None)
    对字符S调用str.split()方法，对每个单词调用str.capitalize()方法，再
    调用str.join()方法连接返回。

    使用SEP参宿作为分割和连接字符串的分隔符，默认为空白字符。

    #+BEGIN_SRC python :session
      from string import capwords

      capwords('i have a dream!')
      capwords('banana', sep='a')
    #+END_SRC

    #+RESULTS[da595ad1f2d225e97f61633a716d197a60387985]:
    :
    : >>> 'I Have A Dream!'
    : 'BaNaNa'

* re - 正则表达式
  此模块提供正则匹配操作，与Perl的正则相似。
  
  模板和被搜索的字符串都可为Unicode字符串和8-bit字符串。但是，Unicode
  字符串和8-bit字符串不能混合使用：不能用byte形式的模板匹配Unicode字符
  串，反之亦然；当进行替换时，模板和被搜索字符串都应为相同类型。
  
  正则表达式使用反斜杠（\）表示转义，表示特殊形式，或将特殊字符转换为
  普通字符。这与Python中字符串字面量使用相同字符表示相同含义相冲突。如
  要匹配反斜杠自身，需写为“\\\\”。因为正则本身为“\\”，每个反斜杠转义一
  次，最后就成了4个反斜杠。
  
  解决方法为使用Python的“原生字符串”表达方式，这样反斜杠在任何字符前都
  不会有特殊含义，如r"\n"是2个字符的字符串，即“\”和“n”；而“\n”则是表示
  单个换行符的字符串。一般情况下，Python中使用“原生字符串”表示正则模板。
  
  值得注意的是，大多数情况下，模块层级的正则函数都有对应的编译后正则方
  法。前者无需编译正则对象，但缺少优化的参数形式。
  
  #+BEGIN_QUOTE
  *注意* ：第三方插件regex有与re模块兼容的接口，且提供了额外功能，以及
  更丰富的Unicode支持。
  #+END_QUOTE
  
** 正则基本语法
   正则可连接：如果A和B都是正则，则AB也是正则。一般情况下，如果字符串p
   匹配正则A，且字符串q匹配正则B，则pq也匹配正则AB。
   
   重复标记，如*、+、?、{m,n}等，不能直接嵌套。
   
*** .
    默认情况下匹配除换行符以外的任意字符。如果指定了DOTALL标记，则包含
    换行符。

*** ^
    匹配字符串其实位置。如果在MUTILINE模式下，则立即匹配新行后。

*** $
    匹配字符串末或换行符前。在MULTILINE模式下，还匹配换行符前。foo匹配
    foo和foobar，但foo$则只匹配foo。foo.$会匹配foo1\nfoo2\n中的foo1，
    但在MULTILINE模式下，则匹配foo1和foo2。此外，$匹配'foo\n'会得到两
    个空字符，一个在换行符前，一个在换行符后。

    #+BEGIN_SRC python :session
      import re

      re.findall('foo.$', 'foo1\nfoo2\n')
      re.findall('foo.$', 'foo1\nfoo2\n', re.MULTILINE)
      re.findall('$', 'foo\n')
      re.findall('$', 'foo')
    #+END_SRC

    #+RESULTS[d3b2a742803383792a331777c8e27576948378ef]:
    :
    : >>> ['foo2']
    : ['foo1', 'foo2']
    : ['', '']
    : ['']

*** *
    匹配重复0个或多个。
    
    #+BEGIN_SRC python :session
      import re

      re.findall('ab*', 'a')
      re.findall('ab*', 'ab')
      re.findall('ab*', 'abbb')
      re.findall('ab*', 'ac')
      re.findall('ab*', 'c')
    #+END_SRC

    #+RESULTS[f24e4106e8445523aed2669d9d6814b71831ec44]:
    :
    : >>> ['a']
    : ['ab']
    : ['abbb']
    : ['a']
    : []

*** +
    匹配一个多或多个。

    #+BEGIN_SRC python :session
      import re

      re.findall('ab+', 'a')
      re.findall('ab+', 'ab')
      re.findall('ab+', 'abbb')
      re.findall('ab+', 'ac')
      re.findall('ab+', 'c')
    #+END_SRC

    #+RESULTS[5fb2e20b51d181e1a1eb59cf40b2280cfc56a63a]:
    :
    : >>> []
    : ['ab']
    : ['abbb']
    : []
    : []

*** ?
    匹配0个或1个。

    #+BEGIN_SRC python :session
      import re

      re.findall('ab?', 'a')
      re.findall('ab?', 'ab')
      re.findall('ab?', 'abbb')
      re.findall('ab?', 'ac')
      re.findall('ab?', 'c')
    #+END_SRC

    #+RESULTS[c67f4728c42b21dd7a18ebba57c09641183f0571]:
    :
    : >>> ['a']
    : ['ab']
    : ['ab']
    : ['a']
    : []

*** *?,+?,??
    *、+和?都是贪婪匹配，添加?号将其转换为非贪婪匹配。
    
    #+BEGIN_SRC python :session
      import re

      re.findall('<.*>', '<a> b <c>')
      re.findall('<.*?>', '<a> b <c>')
    #+END_SRC

    #+RESULTS[d8cb1e2ca9816fb4636de72e5166daedb40935bd]:
    :
    : >>> ['<a> b <c>']
    : ['<a>', '<c>']

*** {m}
    值得匹配个数为M。

    #+BEGIN_SRC python :session
      import re

      re.findall('ab{2}', 'ab')
      re.findall('ab{2}', 'abb')
      re.findall('ab{2}', 'abbbb')
    #+END_SRC

    #+RESULTS[395b9b3a7c4c905e8a6191bdb95167b82be70695]:
    :
    : >>> []
    : ['abb']
    : ['abb']

*** {m,n}
    匹配M->N个。如果缺省M，表示0->N个；缺省N，表示M->无限多个。

*** {m,n}?
    {m,n}的非贪婪形式：

    #+BEGIN_SRC python :session
      import re

      re.findall(r'ab{3,5}', 'abbbbb')
      re.findall(r'ab{3,5}?', 'abbbbb')
    #+END_SRC

    #+RESULTS[62bec64cfe56bf86826fe0040c16cd784ac94601]:
    :
    : >>> ['abbbbb']
    : ['abbb']

*** \
    转义特殊字符，如*、?和+等；或标记特殊序列（special sequence）。

    为避免过多书写过多反斜杠，强烈建议除简单的正则表达式外，都使用“原
    始字符串”。

    #+BEGIN_SRC python :session
      import re

      re.findall('\\\\', '\\')
      re.findall(r'\\', '\\')
    #+END_SRC

    #+RESULTS[1f7d469e413645a70fabb6db47137355918e50e0]:
    :
    : >>> ['\\']
    : ['\\']

*** []
    匹配字符组。
    
    - 匹配其中的任意一个字符：

      #+BEGIN_SRC python :session
        import re

        re.findall('[ban]', 'banana')
      #+END_SRC

      #+RESULTS[1eb9d3f2efad30bfe84ad740f5dfa3ba1e8088cb]:
      :
      : >>> ['b', 'a', 'n', 'a', 'n', 'a']
      
    - 匹配字符范围，如需在其中匹配“-”本身，则需将其转义，如[a\-z]或放
      在第一个或最后一个位置。

      #+BEGIN_SRC python :session
        import re

        re.findall('[a-z]{2}', 'banana')
        re.findall('[-a-z]', '-ba')
        re.findall('[a\-z]', '-ba')
      #+END_SRC

      #+RESULTS[8eae70c14173aa9e8177b05f2611134ab7d45665]:
      :
      : >>> ['ba', 'na', 'na']
      : ['-', 'b', 'a']
      : ['-', 'a']
      
    - 其中的特殊字符失去其特殊含义：
      
      #+BEGIN_SRC python :session
      import re

      re.findall('[(+*?)]', '[(+*?)]')
      #+END_SRC
      
      #+RESULTS[43e5bb75b04f9aabde5ff974e132c05d1e979b75]:
      :
      : >>> ['(', '+', '*', '?', ')']
      
    - 可在第一个位置使用^字符，表示不匹配其中任何字符。除在第一个位置
      外，^失去特殊含义：

      #+BEGIN_SRC python :session
      import re

      re.findall('[an]', 'banana')
      re.findall('[^an]', 'banana')
      re.findall('[an^]', '^banana')
      #+END_SRC

      #+RESULTS[8a97c7d04b2f9977933348316d9b030513f89965]:
      :
      : >>> ['a', 'n', 'a', 'n', 'a']
      : ['b']
      : ['^', 'a', 'n', 'a', 'n', 'a']

    - 如需在其中匹配右方括号，可使用反斜杠转义，或放在第一个位置：

      #+BEGIN_SRC python :session
        import re

        re.findall('[][]', '[]')
        re.findall('[[\]]', '[]')
      #+END_SRC

      #+RESULTS[051c649b5233f486047821138d10c7c5f1cc2402]:
      :
      : >>> ['[', ']']
      : ['[', ']']

*** |
    A|B，A和B可为任意正则，匹配A或B。从A开始向右匹配，找到匹配立即停止，
    即非贪婪。如需匹配数竖线本身，可使用反斜杠转义，或置于方括号内：
    
    #+BEGIN_SRC python :session
      import re

      re.findall('(fuck|love) you', 'fuck you')

      re.findall('[|]', '|')
      re.findall('\|', '|')
    #+END_SRC
    
    #+RESULTS[a3d2634face3d90eb11de3f8b3918e83349afbc1]:
    :
    : >>> ['fuck']
    : >>> ['|']
    : ['|']

*** (...)
    分组匹配。匹配括号内的正则。匹配后可使用\number形式获取匹配内容。
    匹配小括号本身可使用反斜杠转义，或置于方括号中：

    #+BEGIN_SRC python :session
      import re

      m = re.search(r'([0-9])\1', '55')
      print(m.group())
      re.findall('[()]', '()')
      re.findall(r'(\(|\))', '()')
    #+END_SRC

    #+RESULTS[7425fa45b9283a1069c689729b5674e505e9c05c]:
    :
    : >>> >>> 55
    : ['(', ')']
    : ['(', ')']

*** (?...) - 分组扩展
    扩展标记。?后的第一个字符决定扩展方式。除(?P<name>...)外，所有扩展
    都不形成新分组。下面为目前支持的扩展：
    
**** (?aiLmsux)
     不匹配任何内容，只是指定正则标记。各个字母对应的模块属性和含义分
     别为：
     
     | 字符 | 模块属性 | 含义                      |
     |------+----------+---------------------------|
     | a    | re.A     | 只匹配ASCII字符           |
     | i    | re.I     | 不区分大小写              |
     | L    | re.L     | 由本地环境决定            |
     | m    | re.M     | 多行模式                  |
     | s    | re.S     | 换行符也作为“.”的匹配     |
     | x    | re.X     | 整个正则都使用verbose模式 |
     
     #+BEGIN_SRC python :session
       import re
       re.findall('(?a)', '人')       # ???
       re.findall('(?i)a', 'aA')
       re.findall('a', 'aA')
     #+END_SRC
     
     #+RESULTS[3d7e5871f6df0e3d858f7913bb1e63c9196b85bb]:
     :
     : ['', '']
     : ['a', 'A']
     : ['a']
     
     *注意* ：(?x)标记决定整个正则的解析方式。需放在整个正则最前面，或
     单个或多个空格前面。
     
**** (?:...)
     (...)的非捕捉版本。唯一不同点为不能使用\number获取括号中匹配到的
     内容。

**** (?P<name>...)
     在(...)的基础上为反向索引添加新名字NAME。如正常情况下可使用
     \number获取分组匹配中的内容，使用此扩展后还可使用\name获取。

     如下面匹配单/双引号括起来的内容：

     #+BEGIN_SRC python :session
       import re
       m = re.search('(?P<quote>[\'\"])(?P<match>.*)(?P=quote)', '"name"')
       print(m.group('match'))
       re.findall('(?P<letter>abc)', 'abc')
     #+END_SRC

     #+RESULTS[1fd27221f28f134b95e3a61e1ee0bbb8c7338126]:
     :
     : >>> name
     : ['abc']

     被命名的分组可在下面3中情况下反向索引（以上例为准）：

     | 使用情况                         | 引用方式                           |
     |----------------------------------+------------------------------------|
     | 在自身所处正则内                 | (?P=quote)或\1                     |
     | 处理匹配对象m时                  | m.group('quote')或m.end('quote')等 |
     | 传递给re.sub()方法作为repl参数时 | \g<quote>或\g<1>或\1               |

**** (?P=name)
     反向索引命名分组。
**** (?#...)
     注释。

     #+BEGIN_SRC python :session
       import re

       re.findall('(?#不区分大小写)(?i)a', 'aA')
     #+END_SRC

     #+RESULTS[c309dce82dee2b20693b54c1752792be11fc6cfd]:
     :
     : >>> ['a', 'A']

**** (?=...)
     当...匹配才成功。为提前假设，不消耗字符串。如"Isaac (?=Asimov)"只
     有当"Isaac "后有字符串"Asimov"时才匹配成功。
     
     #+BEGIN_SRC python :session
       import re

       re.findall('Isaac (?=Asimov)', 'Isaac')
       re.findall('Isaac (?=Asimov)', 'Isaac Asimov')
     #+END_SRC
     
     #+RESULTS[2ce943bcbd23be1249a797c6490db4fdac85e6b3]:
     :
     : >>> []
     : ['Isaac ']

**** (?!...)
     当...不匹配时才成功。为提前假设，不消耗字符串。如“Isaac
     (?!Asimov)”只有当"Isaac "后不是"Asimov"才成功：

     #+BEGIN_SRC python :session
       import re

       re.findall('Isaac (?!Asimov)', 'Isaac Asimov')
       re.findall('Isaac (?!Asimov)', 'Isaac Asim')
     #+END_SRC

     #+RESULTS[450299fb22f39dd6945c95f7d816e718a723ef18]:
     :
     : >>> []
     : ['Isaac ']

**** (?<=...)
     当前位置前匹配...才成功。也为提前假设，不消耗字符串。如
     (?<=abc)def可将abcdef匹配成功。...需为固定个数的字符，如果abc或
     a|b可以，但a*或a{3,4}则不可以。
     
     #+BEGIN_SRC python :session
       import re

       m = re.search('(?<=abc)def', 'abcdef')
       m.group(0)
     #+END_SRC
     
     #+RESULTS[da583083430ea899544b1115ebd8cda5c730b752]:
     :
     : >>> >>> 'def'
     
     如匹配前面有短横线的单词：
     
     #+BEGIN_SRC python :session
       import re
       m = re.search('(?<=-)\w+', 'spam-egg')
       print(m.group(0))
     #+END_SRC
     
     #+RESULTS[96e23d18b42112fb158ee88b04f2157b541a142a]:
     :
     : >>> egg

**** (?<!...)
     当前位置前不匹配...才成功。与(?<=...)相同，也为提前假设，不消耗字
     符串；...字符串个数需固定。

     #+BEGIN_SRC python :session
       import re
       re.findall('^(?<!-)\w+', 'spam-egg')
       re.findall('(?<![a-z])\w+', 'spam-egg')
     #+END_SRC

     #+RESULTS[55ae9073dd63d587979f22e512c1332d3f353168]:
     :
     : ['spam']
     : ['spam', 'egg']

**** (?(id/name)yes-pattern|no-pattern)
     如果给定ID/NAME指定的匹配组存在，则使用yes-pattern，否则使用
     no-pattern。如下面简化的邮箱匹配正则：

     #+BEGIN_SRC python :session
       import re
       pattern = re.compile('^(<)?(\w+@\w+(?:\.\w+)+)(?(1)>|$)')
       for email in ["<user1@host.com>", "user2@host.com", "<user3@host.com", "user4@host.com>"]:
           if pattern.search(email):
               print(email)
     #+END_SRC

     #+RESULTS[d8cf2ffb28d6b1247dd9511ad9632d8f72963db2]:
     :
     : >>> ... ... ... <user1@host.com>
     : user2@host.com

*** 特殊转义字符
    如果转义下面没有列出的字符，只会匹配第二个。如\$会匹配$：
    
    #+BEGIN_SRC python :session
      import re

      re.findall('\$', '$')
    #+END_SRC
    
    #+RESULTS[037ca02c2abe1c063ca7555df2a105fb87a8336a]:
    :
    : >>> ['$']
    
**** \number
     反向索引。不能使用8进制数，最大数值99。
     
     #+BEGIN_SRC python :session
       import re
       m = re.search(r'(.+) \1', '55 5')
       m.group(0)
     #+END_SRC
     
     #+RESULTS[bb02f8e49c3e433f7fcbc6da50be404a267a4259]:
     :
     : >>> '5 5'
     
**** \A
     匹配字符串起始位置。
**** \b
     匹配单词边界。一个单词为Unicode字母或下划线组成的序列，所以结束单
     词的字符含：非alphnum字符、非下划线。

     严格将，\b的定义为\w和\W间（或相反），或\w和字符串首/尾。

     #+BEGIN_SRC python :session
       import re
       pattern = re.compile(r'\bfoo\b')
       for x in ['foo', 'foo.', '(foo)', 'bar foo baz', 'foobar', 'foo3']:
           if pattern.search(x):
               print(x)
     #+END_SRC

     #+RESULTS[77147a892c8ffad8ff94d4844f21906dd6dac995]:
     :
     : >>> ... ... ... foo
     : foo.
     : (foo)
     : bar foo baz

     默认情况下使用Unicode的alphanum，但可由ASCII标记修改。？？？

     在字符范围中，\b表示backspace字符。

**** \B
     与\b刚好相反。匹配不为单词边界。

     #+BEGIN_SRC python :session
       import re

       pattern = re.compile(r'py\b')

       for x in ['python', 'py3', 'py2', 'py', 'py.', 'py!]']:
           if pattern.search(x):
               print(x)
     #+END_SRC
     
     #+RESULTS[fe1756f9e6a5f0257b3d2b3a15961439e4b889f8]:
     :
     : >>> >>> >>> ... ... ... py
     : py.
     : py!]

**** \d

     #+BEGIN_SRC python :session
       import re

       re.findall(r'\d', '123a')
     #+END_SRC

     #+RESULTS[fae72128019acd161ee76694fbb63a86e0be412c]:
     :
     : >>> ['1', '2', '3']

     - Unicode：
       匹配Unicode数字，即[0-9]及其他数字字符？？？。如果使用ASCII标记，
       则相当于[0-9]，由于此标记影响整个正则，所有最好使用[0-9]。

     - 8-bit：
       等价于[0-9]

**** \D
     与\d相反。匹配所有非Unicode数字字符。如果使用了ASCII标记，相当于
     [^0-9]。由于使用标记会影响整个正则，所以最好使用[^0-9]。

     #+BEGIN_SRC python :session
       import re

       re.findall(r'\D', '\X001')
     #+END_SRC

     #+RESULTS[e4ad15a9cd0d2cdc7ac92b515f2b5973b31274ad]:
     :
     : >>> ['\\', 'X']

**** \s
     
     #+BEGIN_SRC python :session
       import re
       re.findall('\s', ' a\t\n\r\f\vb')
     #+END_SRC
     
     #+RESULTS[ae98d13f622826d346f31aaa456f4c7922479de5]:
     :
     : [' ', '\t', '\n', '\r', '\x0c', '\x0b']
     
     - Unicode
       匹配空白字符，含[ \t\n\r\f\v]，及其他许多字符？？？。如果使用了
       ASCII标记，则相当于[ \t\n\r\f\v]。由于标记会影响整个正则，所以
       需要时使用[ \t\n\r\f\v]。
     - 8-bit字符串
       等价于[ \t\n\r\f\v]。
       
**** \S
     与\s相反。
**** \w
     
     #+BEGIN_SRC python :session
       import re
       re.findall('\w', '我有一个梦想！')
     #+END_SRC

     #+RESULTS[ecd40b71a81cbec7a0e7480cba4fdc9c5d255d7e]:
     :
     : ['我', '有', '一', '个', '梦', '想']

     - Unicode：
       匹配组成单词的字符。含所有语言中能组成单词的字符，以及数字和下
       划线。如果使用ASCII标记，则相当于[a-zA-Z0-9_]。
     - 8-bit
       等价于[a-zA-Z0-9_]。

**** \W
     与\w相反。
**** \Z

     匹配字符串结束处。？？？

**** 其他
     大多数Python字面量字符串的转义字符，正则中也可解析：

     #+BEGIN_QUOTE
     \a	\b	\f	\n
     \r	\t	\u	\U
     \v	\x	\\
     #+END_QUOTE

     注意点：

     - \b在正则中为单词边界，在字符类中为backspace
     - \u和\U只在Unicode模式下为转义字符。在bit模式下为普通字符。
     - 如果第一个转义字符为0，或有3个八进制数字，则被看做八进制转义。
       否则被看做组匹配反向索引。在字符串字面量中，8进制转义字符最多有
       3个数字字符相邻。
     - 3.6版本开始，使用\转义无效字符将被禁用。

** 模块内容
   此模块定义了几个函数、常量和Exception。其中一些函数仅是编译正则方法
   的简化版。
   
   *注意* ：最好使用编译正则的方法。
   
*** 常量
**** re. *A*
**** re. *ASCII*
     使\w、\W、\b、\B、\d、\D、\s和\S仅匹配ASCII对应的字符，而不是匹配
     所有Unicode对应的字符。仅对Unicode正则有效，对byte正则无效。
     
     #+BEGIN_SRC python :session
       import re
       re.findall('\w', 'a一')
       re.findall('\w', 'a一', re.ASCII)
       bytes('a一', 'utf-8')
       re.findall(b'\w', bytes('a一', 'utf-8'))
       re.findall(b'\w', bytes('a一', 'utf-8'), re.ASCII)
     #+END_SRC
     
     #+RESULTS[ed4d0f18798a1a874b7a6f50735b63e6d7bc0399]:
     :
     : ['a', '一']
     : ['a']
     : b'a\xe4\xb8\x80'
     : [b'a']
     : [b'a']
     
**** re. *DEBUG*
     显示编译正则的Debug信息。
     
     #+BEGIN_SRC python :session
       import re
       re.compile('\w', re.DEBUG)
     #+END_SRC
     
     #+RESULTS[ada664fa569b3f8ea09eeaf17f5b73a3dabfe1a1]:
     :
     : IN
     :   CATEGORY CATEGORY_WORD
     : re.compile('\\w', re.DEBUG)

**** re. *I*
**** re. *IGNORECASE*
     不区分大小写，所以[A-Z]也会匹配小写字母。不会被本地环境影响，且对
     Unicode字符也有效。

     #+BEGIN_SRC python :session
       import re

       re.findall('[A-Z]', 'abc', re.IGNORECASE)
     #+END_SRC

     #+RESULTS[7ad7a5fe7c5ee7a3ae88b79dabdb0c3866209e2e]:
     :
     : >>> ['a', 'b', 'c']
     
**** re. *L*
**** re. *LOCALE* （3.6版本将废除）
     使\w、\W、\b、\B、\d、\D、\s和\S依赖本地环境决定匹配。不建议在本
     地字符环境不可靠的情况下使用，且每次只处理一种“文化（culture）”。

**** re. *M*
**** re. *MULTILINE*
     默认情况下，^只匹配字符串起始；$匹配字符串末尾，以及字符串末尾换
     行符（如果有）前。

     使用此标记后：^匹配匹配字符串起始和紧跟换行符后的位置；$匹配字符
     串末尾和换行符前。

     *？* ：好像只是改变了^的行为。

**** re. *S*
**** re. *DOTALL*
     默认情况下“.”匹配除换行符以外的任意字符。使用此标记后也可匹配换行
     符。

     #+BEGIN_SRC python :session
       import re

       re.findall('.', '\n')
       re.findall('.', '\n', re.DOTALL)
     #+END_SRC

     #+RESULTS[8fde86e5ae455a6ace3e19b674dfea011737c287]:
     :
     : >>> []
     : ['\n']

**** re. *X*
**** re. *VERBOSE*
     允许多行书写正则表达式，且可添加注释。

     规则：

     1. 除字符类，和前面有非转义的反斜杠外，所有空格字符都会被忽视。
     2. 除在字符类，以及前面有非转义反斜杠外的“#”，后面的内容会被作为
        注释。

     #+BEGIN_SRC python :session
       import re

       a = re.compile(r"""\d +         # 整数部分
       \.                              # 小数点
       \d *                            # 小数部分
       """, re.VERBOSE)

       b = re.compile(r'\d+\.\d*')

       a.findall('1.23 1.2 1')
       b.findall('1.23 1.2 1')
     #+END_SRC

     #+RESULTS[8375df4dd1724dfe2e11fdcb380e6a9e83fd025b]:
     :
     : >>> ... ... ... >>> >>> >>> >>> ['1.23', '1.2']
     : ['1.23', '1.2']

*** 方法
**** re. *compile* (pattern,flags=0)
     将正则表达式编译为正则对象，以使用下一节介绍的match()和search()等
     方法。

     可使用上一节介绍的标记修改正则对象，如需使用多个标记，需使用二进
     制运算符“|”结合。

     #+BEGIN_SRC python :eval never
       import re
       prog = re.compile(pattern)
       result = prog.match(string)
     #+END_SRC

     等价于：

     #+BEGIN_SRC python :eval never
       import re
       result = re.match(pattern, string)
     #+END_SRC

     但如果但单个程序中多次复用一个正则，使用re.compile()方法编译后效
     率更高。

     #+BEGIN_QUOTE
     由于传递给re.compile()方法和模块层级的匹配函数会缓存正则，所以单
     次使用少量正则时，可不必考虑使用编译版本的正则方法。
     #+END_QUOTE

**** re. *search* (pattern,string,flags=0)
     整体扫描字符串STRING，查看第一个满足PATTERN的位置，返回对应匹配对
     象；如果没有匹配成功，返回None；匹配成功，但不匹配任何文本，还是
     会返回只含空字符串的匹配对象。

     #+BEGIN_SRC python :session
       from re import search

       search('d*', 'a').group()
       print(search('d', ''))
     #+END_SRC

     #+RESULTS[739420a5d3d71d5135e9a2d8506ddcc37fae58dc]:
     :
     : >>> ''
     : None

**** re. *match* (pattern,string,flags=0)
     如果从字符串STRING起始位置开始有0个或多个字符可匹配PATTERN，则返
     回匹配对象；如果没有匹配成功，则返回None；；匹配成功，但不匹配任
     何文本，还是会返回只含空字符串的匹配对象。
     
     #+BEGIN_SRC python :session
       from re import match

       print(match('[0-9]', 'a1b'))
       match('[0-9]', '1ab')
     #+END_SRC
     
     #+RESULTS[6d0fb76f8682d44df1d2a29a67b7457bc76c6941]:
     :
     : >>> None
     : <_sre.SRE_Match object; span=(0, 1), match='1'>
     
     *注意* ：
     
     1. 即时使用了re.MULTILINE模式，re.match()也是从整个字符串起始位置
        开始查找匹配，而不是从每个新行起始处开始。
        
     2. 如果要查看任何位置，而不是起始位置是否匹配，使用search()方法：
        
        #+BEGIN_SRC python :session
           from re import match, search

           print(match('[a-z]', '!abc'))
           search('[a-z]', '!abc').group()
        #+END_SRC
        
        #+RESULTS[8c5c87466b3ef0098a4731abc4a4607048da84ba]:
        :
        : >>> None
        : 'a'
        
**** re. *fullmatch* (pattern,string,flags=0)
     查看整个STRING是否匹配PATTERN，返回匹配对象；如果不匹配，则返回
     None；匹配成功，但不匹配任何文本，还是会返回只含空字符串的匹配对
     象。     


     #+BEGIN_SRC python :session
       from re import search, fullmatch

       search('a', 'cba').group()
       print(fullmatch('a', 'cba'))
       fullmatch('a', 'a').group()
     #+END_SRC
     
     #+RESULTS[0792b3de015de249698e7ea50ea20a59d951ed48]:
     :
     : >>> 'a'
     : None
     : 'a'
     
**** Re. *split* (pattern,string,maxsplit=0,flags=0)
     在出现PATTERN处分割STRING，返回链表。如果使用了捕捉模式的正则分组，
     则所有分组的匹配内容也包含在结果中。如果有maxsplit参数，则最多分
     割MAXSPLIT次，剩余字符串作为结果的最后一个元素。

     #+BEGIN_SRC python :session
       from re import split, IGNORECASE

       split('\W+', 'Words, words, words.')
       split('(\W+)', 'Words, words, words.')
       split('[a-f]+', '0a3B9', flags=IGNORECASE)
     #+END_SRC

     #+RESULTS[1a2a60181eba4721fb53739497cc6f3d000e7f14]:
     :
     : >>> ['Words', 'words', 'words', '']
     : ['Words', ', ', 'words', ', ', 'words', '.', '']
     : ['0', '3', '9']

     如果STRING首末匹配正则中的捕获分组，则会在结果中包含空字符串：

     #+BEGIN_SRC python :session
       from re import split

       split('(\W+)', '...words,words...')
     #+END_SRC
     
     #+RESULTS[8d886d4efb87f92ab50d6f499c6c5d24ac8a2628]:
     :
     : >>> ['', '...', 'words', ',', 'words', '...', '']

     #+BEGIN_QUOTE
     *注意* ：split()方法目前并不在在自身可为空字符串处进行分割。如下
     例，“x*”在a前匹配0个x，则b和c间匹配1个，c后匹配0个，正确的结果应
     该是['', 'a', 'x', 'b', 'c', '']。但为向后兼容，会生成如下结果，
     且抛出FutureWarning。

     #+BEGIN_SRC python :session
       from re import split

       split('(x*)', 'axbc')
     #+END_SRC

     #+RESULTS[e6bd9937ea0b77ed2084f1b11bcb9d8a734ab15f]:
     :
     : >>> /usr/lib/python3.5/re.py:203: FutureWarning: split() requires a non-empty pattern match.
     :   return _compile(pattern, flags).split(string, maxsplit)
     : ['a', 'x', 'bc']

     只匹配空字符串的正则已被禁用：

     #+BEGIN_SRC python :session
       from re import split, MULTILINE

       split('^$', 'a\nb', MULTILINE)
     #+END_SRC

     #+RESULTS[f35b990abfeb4946ab2cd6287d3f8085fcb05fd5]:
     :
     : >>> Traceback (most recent call last):
     :   File "<stdin>", line 1, in <module>
     :   File "/usr/lib/python3.5/re.py", line 203, in split
     :     return _compile(pattern, flags).split(string, maxsplit)
     : ValueError: split() requires a non-empty pattern match.

     #+END_QUOTE

**** re. *findall* (pattern,string,flags=0)
     返回链表，由非重叠匹配内容组成。从左到右扫描，返回结果链表中的元
     素的顺序为匹配顺序。

     #+BEGIN_SRC python :session
       from re import findall

       findall('\w', 'abc')
     #+END_SRC

     #+RESULTS[059d17b0aa79b42f3bd511a488c2ddd1b85d5e67]:
     :
     : >>> ['a', 'b', 'c']

     如果PATTERN中有捕获分组，则链表中内容为对应分组匹配的内容；如果有
     多个分组，则每个元素为对应分组匹配内容组成的元组。

     #+BEGIN_SRC python :session
       from re import findall

       findall(r'[0-9][a-z]', '1a23c')
       findall(r'([0-9])[a-z]', '1a23c')
       findall(r'([0-9])([a-z])', '1a23c')
     #+END_SRC

     #+RESULTS[91ca12f5f1f88c36de389821111d994d0508ec15]:
     :
     : >>> ['1a', '3c']
     : ['1', '3']
     : [('1', 'a'), ('3', 'c')]

     Empty matches are included in the result unless they touch the
     beginning of another match.

**** re. *finditer* (pattern,string,flags)
     与findall的区别为：结果为iterator对象，其中元素为匹配对象；不管是
     否有捕获分组，各元素始终对应整个匹配内容。

     #+BEGIN_SRC python :session
       from re import finditer

       i = finditer('([a-z])[0-9]', 'a1b2c3')
       for x in i:
           print(x.group())
     #+END_SRC

     #+RESULTS[65b077efefe1b5d50fe85795c6d056a4d2e23516]:
     :
     : >>> >>> ... ... a1
     : b2
     : c3

**** re. *sub* (pattern,repl,string,count=0,flags=0)
     使用REPL作为模板，使用PATTERN匹配STRING的内容。如果没有匹配内容，
     则REPL按原样返回。REPL可为函数或字符串，如果为字符串，则会处理其
     中的转义字符，如\n会转换为换行符，\r会转换为Carriage return等。无
     含义的转义字符，如\&保持原样。使用\number形式进行反向索引。
     
     #+BEGIN_SRC python :session
       import re

       re.sub(r'def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):',
              r'static PyObject*\npy_\1(void)\n{',
              'def myfunc():'
              )
     #+END_SRC
     
     #+RESULTS[764048d33624b807dd33f4e152202944946051a8]:
     :
     : >>> ... ... ... 'static PyObject*\npy_myfunc(void)\n{'
     
     如果REPL为函数，则会处理所有非重叠PATTERN匹配。参数为匹配对象，返
     回值为需替换的内容。如：
     
     #+BEGIN_SRC python :session
       import re

       def dash2camal(matchobj):
           return matchobj.group(0)[1].upper()

       re.sub('_\w', dash2camal, 'this_is_variable_name')
     #+END_SRC
     
     #+RESULTS[2e24d96cd099c0474bf8d26e9f503720817f953e]:
     :
     : >>> ... ... >>> 'thisIsVariableName'
     
     COUNT为最多的替换个数，需为非负数。如果缺省或为0，表示替换所有。
     如果没有匹配内容，当只有前面没有匹配内容时才替换？？？：
     
     #+BEGIN_SRC python :session
       import re
       re.sub('x*', '-', 'abc')
     #+END_SRC
     
     #+RESULTS[0be01624da5b15701f8f2438cfd7885918671069]:
     :
     : '-a-b-c-'
     
     当REPL为字符串时，可使用反向索引。\g<name>或\g<number>表示
     (?P<name>...)匹配的捕获分组内容。也可使用数字反向索引，\g<2>等价
     于\2。\20为反向索引第20个分组，而不是第2个分组后添加字符串“0”。
     \g<0>表示表示整个匹配内容。
     
**** re. *subn* (pattern,repl,string,count=0,flags=0)
     与sub方法用法一样，只是返回结果为元组：第一个元素与sub方法的返回
     值相同，第二个元素为替换个数。

     #+BEGIN_SRC python :session
       import re

       def dash2camel(matchobj):
           return matchobj.group(0)[1].upper()

       re.subn('_\w', dash2camel, 'this_is_variable')
       re.subn('_\w', dash2camel, 'this_is_variable', count=1)
       re.subn('_\w', dash2camel, 'this-is-variable', count=1)
     #+END_SRC

     #+RESULTS[69ef37e9683a9a9784ac7848e9273af37de00978]:
     :
     : >>> >>> ... ... >>> >>> ('thisIsVariable', 2)
     : ('thisIs_variable', 1)
     : ('this-is-variable', 0)

**** re. *escape* (siring)
     转义除所有ASCII字母数字和下划线外的所有字符。如果要使用正则去匹配
     含正则的字符串，此方法很有用。

     #+BEGIN_SRC python :session
       import re

       re.escape('abc_12')
       re.escape('\w\n\\')
     #+END_SRC

     #+RESULTS[698dd0925515baa613f4d25202185bb3bd2bdda8]:
     :
     : >>> 'abc_12'
     : '\\\\w\\\n\\\\'

**** re. *purge* () ？？？
     清空所有正则表达式缓存。
     
*** Exception
**** exception re. *error* (msg,pattern=None,pos=None )
     当传递个上面方法的正则表达式解析不成功时抛出的错误，如括号不匹配；
     或当编译或匹配正则时发生错误。It is never an error if a string
     contains no match for a pattern. 此错误对象有下面4个属性：

     - *msg* ：错误信息。
     - *pattern* ：正则。
     - *pos* ：正则编译失败开始的位置。
     - *lineno* ：pos属性对应的行数。
     - *colno* ：pos对应的列数。

     #+BEGIN_SRC python :session
       import re

       try:
           re.match('(', 'abc')
       except re.error as error:
           print(error.msg)
           print(error.pattern)
           print(error.pos)
           print(error.lineno)
           print(error.colno)
     #+END_SRC

     #+RESULTS[64af38ff971caa6dee8d046004b59e8dff79aafc]:
     :
     : >>> ... ... ... ... ... ... ... ... missing ), unterminated subpattern
     : (
     : 0
     : 1
     : 1

** 正则表达式对象
   被编译的正则表达式有下面方法和属性。
   
*** 方法
    较之模块级别对应的方法，可指定开始匹配和结束匹配的位置，即POS和
    ENDPOS参数；由于编译时添加了flag标记，所有没有此参数。
    
**** regex. *search* (string[,pos[,endpos]])
     扫描整个STRING，查找第一个满足匹配的文本，返回正则表达式；如果没
     匹配成功，返回None，不同于匹配成功；匹配成功，但不匹配任何文本，
     还是会返回只含空字符串的匹配对象。
     
     #+BEGIN_SRC python :session
       import re
       pattern = re.compile('d')
       pattern1 = re.compile('d*')

       pattern.search('dog')
       print(pattern.search('dog', 1))

       # 匹配成功，但不匹配任何内容
       pattern1.search('dog', 1)
     #+END_SRC
     
     #+RESULTS[595d50894e9c421eac77b3159caae7c78ec4aed0]:
     :
     : >>> >>> >>> <_sre.SRE_Match object; span=(0, 1), match='d'>
     : None
     : >>> ... <_sre.SRE_Match object; span=(1, 1), match=''>

     可选参数POS为STRING中开始搜索的索引位置，默认为0。并不完全等价于
     截断STRING，“^”匹配正真的字符串起始位置或换行符后的位置，并不是
     POS参数所指定开始搜索的位置：

     #+BEGIN_SRC python :session
       import re

       pattern = re.compile('^d', re.MULTILINE)
       pattern.search('dog')
       print(pattern.search('o\ndg', pos=1))
       print(pattern.search('odg', pos=1))
     #+END_SRC

     #+RESULTS[b928866c52db5ee66503fbe86b7443cb94a5589c]:
     :
     : >>> >>> <_sre.SRE_Match object; span=(0, 1), match='d'>
     : <_sre.SRE_Match object; span=(2, 3), match='d'>
     : None

     第三个可选参数为匹配结束的位置，即匹配最多计算到ENDPOS-1处。如果
     ENDPOS小于POS，则不会有任何结果。假设rx为被编译的正则，则有：

     #+BEGIN_SRC python :eval never
       rx.search(string, 0, 50) == rx.search(string[:50], 0)
     #+END_SRC

**** regex. *match* (string[,pos[,endpos]])
     如果STRING起始位置有0个或多个字符匹配，则返回匹配对象；如果没有匹
     配成功，则返回None；匹配成功，但不匹配任何文本，还是会返回只含
     空字符串的匹配对象。
     
     POS和ENDPOS参数的用法同search()方法。

     #+BEGIN_SRC python :session
       import re

       pattern = re.compile('o')
       print(pattern.match('dog'))     # o不是第一个字符
       pattern.match('dog', 1)
     #+END_SRC

     #+RESULTS[b58c49636e6b96083dc4a4526edc8c6c82d93e8d]:
     :
     : >>> >>> None
     : <_sre.SRE_Match object; span=(1, 2), match='o'>

**** regex. *fullmatch* (string[,pos[,endpos]])
     如果整个STRING匹配，则返回匹配对象。如果比匹配则返回None；匹配
     成功，但不匹配任何文本，还是会返回只含空字符串的匹配对象。

     POS和ENDPOS的用法同search()方法。

     #+BEGIN_SRC python :session
       import re
       pattern = re.compile('o[gh]')

       pattern.fullmatch('dog'), pattern.fullmatch('oge'), pattern.fullmatch('ogre')
       pattern.fullmatch('dogge', 1, 3)
     #+END_SRC

     #+RESULTS[29ee1adb973e308f26b87107aa1df74690ba267d]:
     :
     : >>> >>> >>> (None, None, None)
     : <_sre.SRE_Match object; span=(1, 3), match='og'>

**** regex. *split* (string, maxsplit=0)
     同模块级别的split方法用法相同。
**** regex. *findall* (string[,pos[,endpos]])
     同模块级别的findall方法用法相同，但可使用POS和ENDPOS参数限制搜索
     范围。

**** regex. *finditer* (string[,pos[,endpos]])
     同模块级别的finditer方法用法相同，但可使用POS和ENDPOS参数限制搜索
     范围。
     
**** regex. *sub* (repl,string,count=0)
     同模块级别的sub方法用法相同。

**** regex. *subn* (repl,string,count=0)
     同模块级别的subn方法用法相同。

*** 属性
**** regex. *flags*
     含传递给re.compile()方法，以及(?...)内联的flag标记。如果为Unicode
     形式的正则，则自动添加re.UNIOCDE标记。

     #+BEGIN_SRC python :session
       import re

       re.compile('').flags, re.UNICODE
       re.compile(b'').flags
       re.compile('(?Li)', re.VERBOSE).flags
     #+END_SRC

     #+RESULTS[2772b6142f4a3d587f7365088b88c29b15e6e5f4]:
     :
     : >>> (32, 32)
     : 0
     : 102

**** regex. *groups*
     捕获分组数量。

     #+BEGIN_SRC python :session
       import re

       re.compile('').groups
       re.compile('()').groups
       re.compile('()(?P<name>)').groups
       re.compile('(?:)').groups
     #+END_SRC

     #+RESULTS[943d3bbaed042dde09adf7343c77498f273f80ff]:
     :
     : >>> 0
     : 1
     : 2
     : 0

**** regex. *groupindex*
     返回正则中命名捕获分组组成的字典映射对象。key值为命名分组名称，
     value值为命名分组的数字反向引用值。

     #+BEGIN_SRC python :session
       import re

       re.compile('').groupindex
       re.compile('()').groupindex
       re.compile('(?P<name>)(?P<age>)').groupindex
     #+END_SRC

     #+RESULTS[a85ca27866874f160a0df3330a672f5cb16ca48e]:
     :
     : >>> mappingproxy({})
     : mappingproxy({})
     : 2

**** regex. *pattern*
     传递给compile()方法的正则字符串。
     
     #+BEGIN_SRC python :session
       import re

       re.compile(b'xyz()').pattern
       re.compile('xyz()').pattern
     #+END_SRC
     
     #+RESULTS[6013ac05a3b508213048d8d3a713e7d962a6656c]:
     :
     : >>> b'xyz()'
     : 'xyz()'
     
** 正则匹配对象
   匹配对象总是具有布尔值True。由于当match()和search()匹配失败后会返回
   None，可使用此特性判断是否匹配成功：

   #+BEGIN_SRC python :eval never
     match = re.search(pattern, string)
     if match:
         process(match)
   #+END_SRC

   匹配对象支持下列方法和属性：
*** 方法
**** match. *expand* (template)
     在模板字符串TEMPLATE中使用反向索引获取正则中匹配的分组。TEMPLATE
     中可使用数字反向索引，如\1和\2，和命名分组，如\name，反向索引替换
     匹配内容。

     #+BEGIN_SRC python :session
       import re

       m = re.match(r'(?P<first>\w+) (\w+)', 'hello world!')
       m.expand(r'\g<2> \1 \g<first>')
     #+END_SRC

     #+RESULTS[3f50ae1a7a1abe547ca4977b5259200def7b165e]:
     :
     : >>> >>> 'world hello hello'

**** match. *group* ([group1,...])
     返回分组匹配内容。

     - 参数默认为0，即整个匹配对象。
     - 如果有多个参数，则是匹配结果组成的元组。
     - 如果是1-99间的数字，则对应正则的各个分组。
     - 如果参数值大于正则的分组数量，则抛出IndexError错误。
     - 如果正则中分组没匹配任何内容，对应值为None。
     - 如果匹配多个，则返回最后一个。

     #+BEGIN_SRC python :session
       import re

       m = re.match(r'(\w+) (\w+)', 'Isaac Newton, physicist')
       m.group(0)
       m.group(1)
       m.group(2)
       m.group(1, 2)
     #+END_SRC

     #+RESULTS[4346f5c0db5d449b9c8545fff03d9c5a60740cb0]:
     :
     : >>> >>> 'Isaac Newton'
     : 'Isaac'
     : 'Newton'
     : ('Isaac', 'Newton')

     如果使用了正则命名分组的扩展功能（(?P<name>)），参数即可使用数字，
     也可使用NAME进行反向索引。如果参数使用的字符串没有该命名分组，则
     返回IndexError错误：
     
     #+BEGIN_SRC python :session
       import re

       m = re.match(r'(?P<first_name>\w+) (?P<last_name>\w+)', 'Malcolm Reynolds')

       m.group('first_name'), m.group('last_name')
       m.group(1), m.group(2)
     #+END_SRC
     
     #+RESULTS[416c0faee3171c2eb53e55c82bf781785704e558]:
     :
     : >>> >>> >>> ('Malcolm', 'Reynolds')
     : ('Malcolm', 'Reynolds')
     
     如果分组匹配多次，则返回最后匹配的内容：
     
     #+BEGIN_SRC python :session
       import re

       m = re.match(r'(..)+', 'aab2c3')
       m.group(1)
       m.group(0)
     #+END_SRC
     
     #+RESULTS[21b4b33aa5d52bbe73c01b3e13c87ac93ecd32e3]:
     :
     : >>> >>> 'c3'
     : 'aab2c3'
     
     多层嵌套情况下，消耗完一个整体后逐渐向后推移分组编号：
     
     #+BEGIN_SRC python :session
       from re import match

       m = match('(((a)))(b)', 'ab')
       m.group()
       m.group(1)
       m.group(2)
       m.group(3)
       m.group(4)
     #+END_SRC
     
     #+RESULTS[3e2e22877d4c80a9581570d8ad461ee7d32e0d35]:
     :
     : >>> >>> 'ab'
     : 'a'
     : 'a'
     : 'a'
     : 'b'
     
**** match. *groups* (default=None)
     返回元组，由所有单独分组匹配内容组成。
     
     #+BEGIN_SRC python :session
       import re
       m = re.match(r'(\d+)\.(\d+)', '3.14159')
       m.groups()
     #+END_SRC
     
     #+RESULTS[884d7a63d90f29c74bb4e4c5612fd0b70acf289c]:
     :
     : >>> ('3', '14159')
     
     如果正则中有分组不匹配任何内容，可使用DEFAULT参数指定其值，默认值
     为None：

     #+BEGIN_SRC python :session
       import re
       m = re.match(r'(\d+)\.?(\d+)?(\w+)?', '123')
       m.groups()
       m.groups('没有匹配')
     #+END_SRC

     #+RESULTS[af808ee7c37bcb469a1a6a66463e393253134506]:
     :
     : >>> ('123', None, None)
     : ('123', '没有匹配', '没有匹配')

     没有分组返回空字典：

     #+BEGIN_SRC python :session
       from re import match

       m = match('a', 'a')
       m.groupdict()
     #+END_SRC

     #+RESULTS[a6a3a4c6fdff891034f4abaea1210234894793cc]:
     :
     : >>> >>> {}

**** match. *groupdict* (default=None)
     返回字典对象，key为正则的命名分组名，value为匹配内容。
     
     DEFAULT参数与groups方法相同。
     
     #+BEGIN_SRC python :session
       import re

       m1 = re.match(r'(?P<first_name>\w+) (?P<last_name>\w+)', 'Malcolm Reynolds')
       m1.groupdict()

       m2 = re.match(r'(?P<first_name>\w+) (?P<last_name>\w+)(?P<suffix>\w)?',
                     'Malcolm Reynolds')

       m2.groupdict('Phd')
       m2.groupdict()
     #+END_SRC

     #+RESULTS[cefbee6e52e6402fd05abf9908d384e597f493b8]:
     :
     : >>> >>> {'first_name': 'Malcolm', 'last_name': 'Reynolds'}
     : >>> ... >>> >>> {'first_name': 'Malcolm', 'suffix': 'Phd', 'last_name': 'Reynolds'}
     : {'first_name': 'Malcolm', 'suffix': None, 'last_name': 'Reynolds'}

**** match. *start* ([group])
**** match. *end* ([group])
     返回GROUP匹配内容的首尾索引。如果正则分组存在，但不匹配任何字符串，
     则返回-1。
     
     #+BEGIN_SRC python :session
       import re

       m = re.match(r'(\w+) \w+ (.)?', 'Michael Jackson ')
       m.groups()
       m.start(), m.end()
       m.start(0), m.end(0)
       m.start(1), m.end(1)
       m.start(2), m.end(2)
     #+END_SRC
     
     #+RESULTS[6359d0464ff69e38123bbdd97411c7d44e21f69a]:
     :
     : >>> >>> ('Michael', None)
     : (0, 16)
     : (0, 16)
     : (0, 7)
     : (-1, -1)
     
     对于匹配对象m，如果有正则分组g匹配有内容，则m.group(g)等价于：
     
     #+BEGIN_SRC python :eval never
       m.string[m.start(g):m.end(g)]
     #+END_SRC
     
     *注意* ：如果分组匹配空字符串（即存在分组，但不匹配任何内容），
     m.start(group)会与m.end(group)相等。如下例：
     
     #+BEGIN_SRC python :session
       import re

       m = re.search('b(c?)', 'cba')
       m.group(0)
       m.group(1)

       m.start(0), m.end(0)
       m.start(1), m.end(1)
     #+END_SRC
     
     #+RESULTS[d00e11c23036607a93602bc2110e5fa07bd85c13]:
     :
     : >>> >>> 'b'
     : ''
     : >>> (1, 2)
     : (2, 2)
     
     下例为删除 /remove_this/ 的例子：
     
     #+BEGIN_SRC python :session
       import re

       email = '3261958605@qremove_thisq.com'
       m = re.search('remove_this', email)
       email[:m.start()] + email[m.end():]
     #+END_SRC
     
     #+RESULTS[9f7eb4ef041bb44d69fcdcd36102b0b01e2e82c9]:
     :
     : >>> >>> >>> '3261958605@qq.com'
     
**** match. *span* ([group])
     返回由m.start(group)和m.end(group)组成的2元素元组。如果GROUP不匹
     配任何内容，则为(-1, -1)。GROUP默认值为Default。

     #+BEGIN_SRC python :session
       import re

       m = re.search('(\w+) (\w+)', 'Michael Jackson')
       m.span(0)
       m.span(1)
       m.span(2)
     #+END_SRC

     #+RESULTS[32b1236ad224a15c5c8cc948695214121a86deda]:
     :
     : >>> >>> (0, 15)
     : (0, 7)
     : (8, 15)

*** 属性
**** match. *pos*
     可能等于传递个正则对象方法search()和match()的POS参数值。即正则对
     象开始进行查找时的位置：

     #+BEGIN_SRC python :session
       import re

       pattern = re.compile('(\w+)')
       m = pattern.match('Michael Jackson', -1)
       m.group(0)
       m.pos
     #+END_SRC

     #+RESULTS[1e4714847ab10ab751f87b54553cb02020dd5605]:
     :
     : >>> >>> >>> 'Michael'
     : 0

**** match. *endpos*
     即正则结束搜索的后一个位置。可能等于传递给正则对象方法search()和
     match()的ENDPOS参数值。

     #+BEGIN_SRC python :session
       import re

       pattern = re.compile(r'(\w+)')
       m = pattern.search('Michael Jackson', 0, 40)
       m.group()
       m.group(1)
       m.endpos
     #+END_SRC

     #+RESULTS[1178e40ecf05c7f7e6e2d14e3bc8a728d3e24511]:
     :
     : >>> >>> >>> 'Michael'
     : 'Michael'
     : 15

**** match. *lastindex*
     最后一个有匹配内容的正则分组索引（从1起）。如果没有分组，或分组不
     匹配任何内容则返回None。

     #+BEGIN_SRC python :session
       from re import match

       match('(a)b', 'ab').lastindex
       match('((a)(b))', 'ab').lastindex
       match('((ab))', 'ab').lastindex

       match('(a)(b)', 'ab').lastindex

       print(match('ab', 'ab').lastindex)
       print(match('ab(.)?', 'ab').lastindex)
     #+END_SRC

     #+RESULTS[c861e30e0bfa4b2b43ab88e13425c40bf8d7ff44]:
     :
     : >>> 1
     : 1
     : 1
     : >>> 2
     : >>> None
     : None

**** match. *lastgroup*
     返回最后一个分组的名称。如果最后一个分组没有名称，或分组不匹配任
     何内容，或没有分组，返回None。

     #+BEGIN_SRC python :session
       from re import match

       match('(?P<first_name>\w+) (?P<last_name>\w+)', 'Michael Jackson').lastgroup
       print(match('(?P<first_name>\w+) (\w+)', 'Michael Jackson').lastgroup)
       print(match('\w+ \w+', 'Michael Jackson').lastgroup)
     #+END_SRC

     #+RESULTS[f098162debbf03907205be42587e8600c3347198]:
     :
     : >>> 'last_name'
     : None
     : None
     
**** match. *re*
     作为参数传递给search()和match()方法的正则参数。
     #+BEGIN_SRC python :session
       import re
       pattern = re.compile('(\w+) (\w+)')

       m = re.match(r'(\w+) (\w+)', 'Michael Jackson')
       m1 = pattern.match('Michael Jackson')
       type(m.re), m.re
       m1.re
     #+END_SRC

     #+RESULTS[3970cca851b2b252546d8cc572145d5ff2fc3c20]:
     :
     : >>> >>> >>> >>> (<class '_sre.SRE_Pattern'>, re.compile('(\\w+) (\\w+)'))
     : re.compile('(\\w+) (\\w+)')

**** match. *string*
     作为参数传递给search()和match()方法，用于被搜索的字符串参数。

     #+BEGIN_SRC python :session
       import re
       m = re.match(r'(\w+) (\w+)', 'Michael Jackson')
       m.string
     #+END_SRC

     #+RESULTS[11670b75f063bd545a9b7ec24a74ca84f21c875e]:
     :
     : >>> >>> 'Michael Jackson'
     
** 使用举例
*** 配对检查
    下面的例子中将使用此帮助函数打印匹配对象：
    
    #+BEGIN_SRC python :session
      def displaymatch(match):
          if match is None:
              print(None)
          else:
              print('<Match: {}, groups={}>'.format(match.group(), match.groups()))
    #+END_SRC
    
    #+RESULTS[816acc52ed86904f3cb4c7f9122ec16bfc5dc22e]:
    
    假设编写一个扑克程序，每个玩家手中有5张牌，“a”代表Ace，“k”代表King，
    “q”代表queen，“j”代表Jack，“t”代表10，2-9分别代表其他牌。则可使用
    正则检查玩家手中牌的数量和值是否正确：
    
    #+BEGIN_SRC python :session
      import re
      valid = re.compile(r'^[a2-9tjqk]{5}$')
      displaymatch(valid.match('aktq'))
      displaymatch(valid.match('ajt5e'))
      displaymatch(valid.match('akt'))
      displaymatch(valid.match('727ak'))
    #+END_SRC

    #+RESULTS[5cc6723551093a93dbe49fe376b7448b733868c4]:
    :
    : >>> None
    : None
    : None
    : <Match:  727ak, groups=()>

    使用反向引用查看是否有“对子”：

    #+BEGIN_SRC python :session
      import re
      pair = re.compile(r'.*(.).*\1')
      displaymatch(pair.match('717ak'))
      displaymatch(pair.match('718ak'))
      displaymatch(pair.match('354aa'))
    #+END_SRC

    #+RESULTS[666c51b269209024d7a98fe9deafb5fa91c79730]:
    :
    : >>> <Match: 717, groups=('7',)>
    : None
    : <Match:  354aa, groups=('a',)>

    以及使用group方法查看“对子”时什么：

    #+BEGIN_SRC python :session
      pair.match('354aa').group(1)
    #+END_SRC

    #+RESULTS[c66a65d33f2b050da5633b9273b338949000d9de]:
    : 'a'

*** 模仿scanf()
    下表为scanf()函数中占位符对应的正则（基本合适）：

    | scanf占位符 | 正则                                        |
    |-------------+---------------------------------------------|
    | %c          | .                                           |
    | %5c         | .{5}                                        |
    | %d          | [+-]?\d+                                    |
    | %e,%E,%f,%g | [+-]?(\d+(\.\d*)?\vert\.\d+)([eE][+-]\d+)?  |
    | %i          | [+-]?(0[xX][\dA-Fa-f]+\vert0[0-7]*\vert\d+) |
    | %o          | [+-]?[0-7]+                                 |
    | %s          | \S+                                         |
    | %u          | \d+                                         |
    | %x,%X       | [+-]?(0[xX])?[\dA-F-f]+                     |
    |             |                                             |

    如读取文本：

    #+BEGIN_EXAMPLE
      /usr/sbin/sendmail - 0 errors, 4 warnings
    #+END_EXAMPLE

    scanf()的格式为：

    #+BEGIN_SRC python :session
      %s - %d errors, % d warnings
    #+END_SRC

    对应的Python正则为：

    #+BEGIN_SRC python :session
      (\S +) - (\d+) errors, (\d+) warnings
    #+END_SRC

*** search() vs. match()
    search()方法为扫描整个字符串匹配，而match()方法则是只在起始位置开
    始匹配。

    使用“^”可强制search()方法只从起始位置开始匹配：

    #+BEGIN_SRC python :session
      import re

      print(re.match('c', 'abcdef'))
      print(re.match('^c', 'abcdef'))
      print(re.match('^a', 'abcdef'))
    #+END_SRC

    #+RESULTS[d9d142fd36515bb2d5e8c296d132d47b9fc6f1c3]:
    :
    : >>> None
    : None
    : <_sre.SRE_Match object; span=(0, 1), match='a'>

    当在re.MULTIPLE模式下，match()方法只是会从字符串正真的其实位置开始
    匹配；而使用了“^”正则的search()方法会匹配所有换行符前的位置：

    #+BEGIN_SRC python :session
      import re

      print(re.match('X', 'A\nB\nX', re.MULTILINE))
      print(re.search('^X', 'A\nB\nX', re.MULTILINE))
    #+END_SRC

    #+RESULTS[3a2fa92e9bd7a25851bf1cd63bdbe1c1ca100267]:
    :
    : >>> None
    : <_sre.SRE_Match object; span=(4, 5), match='X'>
    
*** 制作电话薄
    split()方法可根据正则分割字符串。利用此方法可将文本数据转换为
    Python中的数据结果。如下面生成电话本的例子：
    
    下面为文本（一般在文本文件中）：
    
    #+BEGIN_SRC python :session
      text = '''小张：192.168.3.4 155 北京

      小王：192.145.2.5 436 上海
      小明：182.122.12.122 广州

      小黄：122.312.232.12 深圳'''
    #+END_SRC

    每条信息间可能有多个空行，利用split()方法将每条项目转换为链表元素：

    #+BEGIN_SRC python :session
      import re
      entries = re.split('\n+', text)
      entries
    #+END_SRC

    #+RESULTS[40f95cdd94740721d4691df79f83064f0387c982]:
    :
    : >>> ['小张：192.168.3.4 155 北京', '小王：192.145.2.5 436 上海', '小明：182.122.12.122 广州', '小黄：122.312.232.12 深圳']

    再使用split()方法将每个元素进一步分割：

    #+BEGIN_SRC python :session
      import re
      [re.split('：? ', entry, 3) for entry in entries]
    #+END_SRC

    #+RESULTS[9112cc05a7ae4023f3fe483288d4f47983182cfc]:
    :
    : >>> [['小张：192.168.3.4', '155', '北京'], ['小王：192.145.2.5', '436', '上海'], ['小明：182.122.12.122', '广州'], ['小黄：122.312.232.12', '深圳']]

    增加分割数目：

    #+BEGIN_SRC python :session
      import re
      [re.split('：? ', entry, 4) for entry in entries]
    #+END_SRC

    #+RESULTS[2a6d33cd22881070c69bc69c64648541543a5ae3]:
    :
    : >>> [['小张：192.168.3.4', '155', '北京'], ['小王：192.145.2.5', '436', '上海'], ['小明：182.122.12.122', '广州'], ['小黄：122.312.232.12', '深圳']]

*** 文本修改
    sub()方法能用单个字符串或函数返回值替换所有匹配内容。下例使用此方
    法打乱所有单词除首位字母外的顺序：
    
    #+BEGIN_SRC python :session
      import random
      import re

      def shuffle(m):
          inner_word = list(m.group(2))
          random.shuffle(inner_word)
          return m.group(1) + ''.join(inner_word) + m.group(3)

      text = 'Professor Abdolmalek, please report your absences promptly.'
      re.sub(r'(\w)(\w+)(\w)', shuffle, text)
      re.subn(r'(\w)(\w+)(\w)', shuffle, text)
    #+END_SRC
    
    #+RESULTS[aecb6e6d114fb71671056d19329b6a2dddc8e44b]:
    :
    : >>> >>> ... ... ... ... >>> >>> 'Psoersofr Aebmlladok, paelse rproet yuor acbesens ptromlpy.'
    : ('Psoersofr Aamlelbdok, pasele rproet yuor aebescns polmrpty.', 7)
    
*** 查找所有英语副词
    不同于search()方法，findall()方法可获取所以出现的文本。利用此特点
    可查找所有文本中的副词：

    #+BEGIN_SRC python :session
      import re
      text = 'gently, do not run so quickly.'
      re.findall(r'\w+ly', text)
    #+END_SRC

    #+RESULTS[148712671095c8e264137a763068b12355885de5]:
    :
    : >>> ['gently', 'quickly']

*** 查找所有英语副词，及其在字符串中的位置
    不同于findall()方法，finditer()方法中的各个元素为匹配对象，可用此
    特点获取关于匹配文本在文本中的具体位置：

    #+BEGIN_SRC python :session
      import re
      text = 'gently, do not run so quickly!'
      for m in re.finditer(r'\w+ly', text):
          print('{}-{}: {}'.format(m.start(), m.end(), m.group(0)))
    #+END_SRC

    #+RESULTS[4ef7fc9b3983475658f8fed723d8f52c6d11a9b9]:
    :
    : >>> ... ... 0-6: gently
    : 22-29:   quickly

*** 原始字符串
    使用原始值字符串（r'abc'）可使正则表达式简洁易读。如果不使用原始字
    符串，所有反斜杠转义都需再使用另外一个反斜杠转义。下面两例等价：

    #+BEGIN_SRC python :session
      import re
      re.match(r'\W(.)\1\W', ' ff ')
      re.match('\\W(.)\\1\\W', ' ff ')
    #+END_SRC

    #+RESULTS[f87ad450a30bd52afa406cd837f586372d272cff]:
    :
    : <_sre.SRE_Match object; span=(0, 4), match=' ff '>
    : <_sre.SRE_Match object; span=(0, 4), match=' ff '>

    如需匹配反斜杠本身，需对其转义。原始字符串中只需两个反斜杠，而普通
    字符串中则需4个。

    #+BEGIN_SRC python :session
      import re
      re.match(r'\\', r'\\')
      re.match('\\\\', r'\\')
    #+END_SRC

    #+RESULTS[2b58d4d52cda60cffeafef4bf50e7516c02ef15c]:
    :
    : <_sre.SRE_Match object; span=(0, 1), match='\\'>
    : <_sre.SRE_Match object; span=(0, 1), match='\\'>

*** 制作分词器
    分词器是将字符串分类。编写解释器或编译器的第一步就是利用分词器分词。
    
    文本分类为单个正则，将他们所有结合在一个总正则中然后历遍匹配。
    
    #+BEGIN_SRC python :session
      import collections
      import re

      Token = collections.namedtuple('Token', ['typ', 'value', 'line', 'column'])


      def tokenize(code):
          keywords = {'IF', 'THEN', 'ENDIF', 'FOR', 'NEXT', 'GOSUB', 'RETURN'}
          token_specification = [
              ('NUMBER', r'\d+(\.\d*)?'),  # 整数或浮点数
              ('ASSIGN', r':='),        # 赋值操作符
              ('END', r';'),            # 语句结束标识
              ('ID', r'[A-Za-z]+'),     # Identifier
              ('OP', r'[-+*/]'),        # 数学运算符
              ('NEWLINE', r'\n'),       # 换行
              ('SKIP', r'[ \t]'),       # 跳过空格和tab
              ('MISMATCH', r'.')        # 其他
          ]
          tok_regex = '|'.join('(?P<{0[0]}>{0[1]})'.format(pair)
                               for pair in token_specification)
          line_num = 1
          line_start = 0
          for mo in re.finditer(tok_regex, code):
              kind = mo.lastgroup
              value = mo.group(kind)
              if kind == 'NEWLINE':
                  line_start = mo.end()
                  line_num += 1
              elif kind == 'SKIP':
                  pass
              elif kind == 'MISMATCH':
                  raise RuntimeError(
                      '{} unexpected on line {}'.format(value, line_num))
              else:
                  if kind == 'ID' and value in keywords:
                      kind = value
                  column = mo.start() - line_start
                  yield Token(kind, value, line_num, column)

      statements = ''' IF quantity THEN
              total := total + price * quantity;
              tax := price * 0.05;
      ENDIF;
      '''

      for token in tokenize(statements):
          print(token)
    #+END_SRC

    #+RESULTS[34edca470cd7177c40d3aff00d84a96d059feae1]:
    #+begin_example

    >>> >>> >>> >>> >>> ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... >>> >>> ... ... ... ... >>> >>> ... ... Token(typ='IF', value='IF', line=1, column=1)
    Token(typ='ID', value='quantity', line=1, column=4)
    Token(typ='THEN', value='THEN', line=1, column=13)
    Token(typ='ID', value='total', line=2, column=8)
    Token(typ='ASSIGN', value=':=', line=2, column=14)
    Token(typ='ID', value='total', line=2, column=17)
    Token(typ='OP', value='+', line=2, column=23)
    Token(typ='ID', value='price', line=2, column=25)
    Token(typ='OP', value='*', line=2, column=31)
    Token(typ='ID', value='quantity', line=2, column=33)
    Token(typ='END', value=';', line=2, column=41)
    Token(typ='ID', value='tax', line=3, column=8)
    Token(typ='ASSIGN', value=':=', line=3, column=12)
    Token(typ='ID', value='price', line=3, column=15)
    Token(typ='OP', value='*', line=3, column=21)
    Token(typ='NUMBER', value='0.05', line=3, column=23)
    Token(typ='END', value=';', line=3, column=27)
    Token(typ='ENDIF', value='ENDIF', line=4, column=0)
    Token(typ='END', value=';', line=4, column=5)
    #+end_example

* difflib - 文本对比
  此模块提供对比序列（Sequence）的类和函数。可用于对比文件，生成对比不
  同形式的信息（含HTML、context和unified diffs）。如需对比文件夹和文件，
  参考filecmp模块。
  
** class difflib. *SequenceMatcher*
   此类型非常灵活，只要元素为“可哈希”值，就可比较任意类型的两个序列。
   其基础算法为“gestalt模式匹配” （[[file:faq.org][FAQ]]）。 并在此基础上提供了过滤“垃圾
   字符”的功能，如空行和空格。

   - *效率* ：
     gestalt匹配算法最坏的情况为时间呈次方增加，正常情况为呈平方增加。
     SequenceMatcher类中的算法，最坏情况为呈次方增加，并根据相同字符数
     的不同变化；最坏的情况为呈线性增加。

   - *自动猜想垃圾字符* ：
     SequenceMatcher支持自动将特定序列作为垃圾。原理为：计算某个元素在
     序列中出现的次数。当某个元素大于等于2时，如果次数占序列长度超过1%，
     且序列至少有200个元素，则将此元素作为“受欢迎”元素，并将其作为“垃
     圾”以进行序列匹配。？？？可在创建SequenceMatcher对象时将autojunk
     参数赋值False取消此功能。

   #+BEGIN_SRC python :session
     from difflib import SequenceMatcher

     diff = SequenceMatcher(a='b111ac', b='v111ca')
     diff.get_matching_blocks()
   #+END_SRC

   #+RESULTS[6409e370845694dd9b45e0d29ebbdc6bfe6386f5]:
   :
   : >>> >>> [Match(a=1, b=1, size=3), Match(a=4, b=5, size=1), Match(a=6, b=6, size=0)]

** class difflib. *Differ*
   此类用于比多行字符串文本，生成可读的比较结果。Differ使用
   SequenceMatcher比较行与行的不同，以及相近行中字符的不同。
   
   显示结果类似与diff命令：
   
   | 字符 | 含义              |
   |------+-------------------|
   | -    | 只有序列1才有的行 |
   | +    | 只有序列2才有的行 |
   | ' '  | 两个序列都有的行  |
   | ?    | 两个序列都无的行  |
   
   #+BEGIN_SRC python :session
     from difflib import Differ
     from pprint import pprint

     text1 = ''' 1.a
     2.b
     c
     '''

     text2 = ''' 1.a
     2.v
     '''
     d = Differ()
     list(d.compare(text1, text2))
   #+END_SRC
   
   #+RESULTS[6a265cdbbe4e6fc28bb4f039bed6d87aec0bd9e8]:
   :
   : >>> >>> >>> ... ... ... >>> >>> ... ... >>> >>> ['   ', '  1', '  .', '  a', '  \n', '  2', '  .', '- b', '+ v', '  \n', '- c', '- \n']
   
** class difflib. *HtmlDiff*
   此类可用于将比较结果生成HTML表格（或含此表格的完整HTML文件）。

   #+BEGIN_SRC python :session
     from difflib import HtmlDiff

     html_diff = HtmlDiff()

     html_diff.make_table(['文本', '比较'], ['文本', '比较'])
     with open('files/test.html', 'w') as f:
         f.write(html_diff.make_file(['abc', 'def'], [
                 'abc', 'ddd'], fromdesc='字符串1', todesc='字符串2', context=False))
   #+END_SRC
   
   #+RESULTS[c37971182bce8456d00e2f61f04c8e3d2b8ed89d]:
   :
   : >>> >>> >>> '\n    <table class="diff" id="difflib_chg_to23__top"\n           cellspacing="0" cellpadding="0" rules="groups" >\n        <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>\n        <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>\n        \n        <tbody>\n            <tr><td class="diff_next"><a href="#difflib_chg_to23__top">t</a></td><td class="diff_header" id="from23_1">1</td><td nowrap="nowrap">文本</td><td class="diff_next"><a href="#difflib_chg_to23__top">t</a></td><td class="diff_header" id="to23_1">1</td><td nowrap="nowrap">文本</td></tr>\n            <tr><td class="diff_next"></td><td class="diff_header" id="from23_2">2</td><td nowrap="nowrap">比较</td><td class="diff_next"></td><td class="diff_header" id="to23_2">2</td><td nowrap="nowrap">比较</td></tr>\n        </tbody>\n    </table>'
   : ... ... ... 2579
   
*** 构造器
**** *__init__* (tabsize=8,wrapcolumn=None,linejunk=None,charjunk=IS_CHARACTER_JUNK)
     用于初始化HtmlDiff实例。

     TABSIZE参数为可选关键字参数，用于指定tab所占空格个数，默认为8。

     WRAPCOLUMN参数为可选关键字参数，用于指定行折叠的列，默认为None，
     即不折叠。

     LINEJUNK和CHARJUNK参数为传递给ndiff()方法的可选关键字参数。
     HtmlDiff使用ndiff()生成比较差异。

*** 公共方法
**** *make_file* (fromalines,tolines,fromedesc="",todesc="",context=False,nunlines=5,*,charset='utf-8')
     比较FROMLINES和TOLINES(字符串组成的链表)，返回字符串。此字符串为
     一个完成HTML字符串，含比较结果组成的表格。
     
     FROMDESC和TODESC为表格头字符串，默认为空字符串。
     
     CONTEXT和NUMLINES用于空着表格样式。
     
**** *make_table* (fromlines,tolines,fromdesc="",todesc="",context=False,numlines=5)
     与make_file()方法唯一不同的是：生成HTML表格，而不是完整HTML页面字
     符串。

** difflib. *context_diff* (a,b,fromfile="",tofile="",fromfiledate="",tofiledate="",n=3,lineterm="\n")
   比较A和B（字符串链表），返回上下文差异格式的字符串组成的生成器（生
   成比较结果字符串）。

   显示修改内容，以及几行上下文行。上下文行数由参数N控制，默认为3。

   默认情况下，控制行（有***和---的行），后面会自动添加换行符，可使用
   LINETERM参数修改。

   可使用FROM/TOFILE和FROM/TOFILEDATE参数指定显示时的文件名，很修改时
   间。FROM/TOFILEDATE的格式为 [[http://baike.baidu.com/item/ISO%25208601][ISO 8601]] 时间格式。

   #+BEGIN_SRC python :session
     from difflib import context_diff
     import sys
     s1 = ['bacon\n', 'eggs\n', 'ham\n', 'guido\n']
     s2 = ['python\n', 'eggy\n', 'hamster\n', 'guido\n']

     sys.stdout.writelines(context_diff(
         s1, s2, n=1, fromfile='file1', tofile='file2', fromfiledate='2007-01-02', lineterm='\n\t\t'))
   #+END_SRC

   #+RESULTS[bddce0372c7d83ed64cd0fbc8fcc56c5826fb1b7]:
   #+begin_example

   >>> >>> >>> >>> ... *** file1	2007-01-02
           --- file2
           ***************
           *** 1,4 ****
           ! bacon
   ! eggs
   ! ham
     guido
   --- 1,4 ----
           ! python
   ! eggy
   ! hamster
     guido
   #+end_example

** difflib. *get_close_matches* (word,possibilities,n=3,cutoff=0.6)
   将WORD（一般为字符串）与POSSIBILITIES（一般为字符串链表）中的每个元
   素比较，返回“最佳匹配”组成的链表，匹配度最高的排在前面。

   可选参数N（默认值3）为返回链表中的最大个数，需大于0。

   可选参数CUTOFF（默认值0.6），为0到1间的浮点数。含义为至少匹配度为此
   值才包含在返回结果中。

   #+BEGIN_SRC python :session
     from difflib import get_close_matches
     import keyword

     get_close_matches('appel', ['ape', 'apple', 'peach', 'puppy'])
     get_close_matches('wheel', keyword.kwlist)
     get_close_matches('apple', keyword.kwlist)
     get_close_matches('accept', keyword.kwlist)
     get_close_matches('accept', keyword.kwlist, cutoff=0.3)
     get_close_matches('accept', keyword.kwlist, cutoff=0.3, n=2)
     get_close_matches('Pennsylvania', ['Pencilvaneya'], cutoff=0.67)
     get_close_matches('Pennsylvania', ['Pencilvaneya'], cutoff=0.66)
   #+END_SRC

   #+RESULTS[2c26a43c3068c6c8e31c58c59f17247923b59cab]:
   :
   : >>> >>> ['apple', 'ape']
   : ['while']
   : ['False']
   : ['except']
   : ['except', 'assert', 'raise']
   : ['except', 'assert']
   : []
   : ['Pencilvaneya']

** difflib. *ndiff* (a,b,linejunk=None,charchunk=IS_CHARACTER_JUNK)
   比较A和B（字符串链表），返回Differ风格的delta（生成delta行的生成器）。

   可选参数LINEJUNK和CHARJUNK为过滤函数（或None）。

   - LINEJUNK：接受单个字符串参数，如需指定参数为垃圾行，则返回True，
     否则返回False。默认值为None。可使用模块级别函数IS_LINE_JUNK，指定
     过滤不含可见字符的行，except for at most one pound character
     ('#')。背后的SequenceMatcher类会动态分析哪行出现频率高，并将其作
     为垃圾行，所以比此函数实用。？？？
   - CHARJUNK：接受单个字符串参数（长度为1），如需指定该字符为垃圾字符，
     则返回True，否则返回False。默认值为模块级别函数
     IS_CHARACTER_JUNK()，过滤空白字符（空格和tab）。最好不要实用此参
     数过滤换行符。

   #+BEGIN_SRC python :session
     from difflib import ndiff, IS_LINE_JUNK
     diff = ndiff('one\ntwo\nthree\n'.splitlines(keepends=True),
                  'ore\ntree\nemu\n'.splitlines(keepends=True), linejunk=IS_LINE_JUNK)
     print(diff)
     print(''.join(diff), end='')
   #+END_SRC
   
   #+RESULTS[2fa747cb46c39a13ef7aaa99a43526e3e2d7ded9]:
   #+begin_example

   ... >>> <generator object Differ.compare at 0x7ff8b7e45fc0>
   - one
   ?  ^
   + ore
   ?  ^
   - two
   - three
   ?  -
   + tree
   + emu
   #+end_example

** difflib. *restore* (sequence,which)
   返回delta生成器中的一个。

   SEQUENCE需为Differ.compare()或ndiff()的返回值，WHICH为1或2。

   #+BEGIN_SRC python :session
     from difflib import ndiff, restore

     diff = ndiff('one\ntwo\nthree\n'.splitlines(keepends=True),
                  'ore\ntree\nemu\n'.splitlines(keepends=True))

     diff = list(diff)
     print(diff)
     ''.join(restore(diff, 1))
     ''.join(restore(diff, 2))
   #+END_SRC

   #+RESULTS[9ab8c6616f9648959199e73fad9dae270fbe03aa]:
   :
   : >>> ... >>> >>> >>> ['- one\n', '?  ^\n', '+ ore\n', '?  ^\n', '- two\n', '- three\n', '?  -\n', '+ tree\n', '+ emu\n']
   : 'one\ntwo\nthree\n'
   : 'ore\ntree\nemu\n'

** difflib. *unifies_diff* (a,b,fromfile="",tofile="",fromfiledate="",tofiledate="",n=3,lineterm="\n")
   与context_diff方法用法相同。只是生成unified-diff风格结果。

   #+BEGIN_SRC python :session
     from difflib import unified_diff
     import sys

     s1 = ['bacon\n', 'eggs\n', 'ham\n', 'guido\n']
     s2 = ['python\n', 'eggy\n', 'hamster\n', 'guido\n']
     sys.stdout.writelines(unified_diff(s1, s2, fromfile='a.txt', tofile='b.txt'))
   #+END_SRC

   #+RESULTS[37231eb023b1ece630447ccadd37ddda1e4a51f9]:
   #+begin_example

   >>> >>> >>> >>> --- a.txt
   +++ b.txt
   @@ -1,4 +1,4 @@
   -bacon
   -eggs
   -ham
   +python
   +eggy
   +hamster
    guido
   #+end_example

** difflib. *diff_bytes* (dfunc,a,b,fromfile=b"",tofile=b"",fromfiledate=b"",tofiledate=b"",n=3,lineterm=b"\n")
   使用DFUNC比较A和B（bytes链表），yield delta行序列（同样为bytes对象），
   格式与DFUNC相同。DFUNC为unified_diff()或context_diff()。

   使用此方法可比较不同编码的序列数据，除N参数外所有参数都需为bytes对
   象。相当于：

   #+BEGIN_SRC python :eval never
     dfunc(a, b, fromfile, tofile, fromfiledate, tofiledate, n, linterm)
   #+END_SRC
   
   返回结果也为bytes对象，编码不变。

** difflib. *IS_LINE_JUNK* (line)
   如果LINE为空行，或只含一个“#”，则返回True。

   #+BEGIN_SRC python :session
     from difflib import IS_LINE_JUNK

     IS_LINE_JUNK('\n')
     IS_LINE_JUNK(' #')
     IS_LINE_JUNK('##')
     IS_LINE_JUNK('a')
   #+END_SRC

   #+RESULTS[37421748018f71231c052c42b20d101f3583a18a]:
   :
   : >>> True
   : True
   : False
   : False

** difflib. *IS_CHARACTER_JUNK* (ch)
   如果为空格或tab，则返回True。为ndiff()方法中charjunk参数的默认值。

   #+BEGIN_SRC python :session
     from difflib import IS_CHARACTER_JUNK

     IS_CHARACTER_JUNK(' ')
     IS_CHARACTER_JUNK('\t')
     IS_CHARACTER_JUNK('a')
   #+END_SRC

   #+RESULTS[ba6edd275fddb49712484d5ab37e40c55b1c559d]:
   :
   : >>> True
   : True
   : False

** SequenceMatcher对象
   构造器：
   
*** class difflib. *SequenceMatcher* (jsjunk=None,a="",b="",autojunk=True)
    可选参数ISJUNK需为None（默认值）或接受一个参数的函数，参数对应序列
    元素，如果将其指定为“垃圾字符”，则返回True。None为不将任何字符作为
    垃圾字符，相当于“lambda: x:0”。比如将tab和空格作为垃圾字符：

    #+BEGIN_SRC python :eval never
      lambda x: x in ' \t'
    #+END_SRC

    可选参数A和B为被比较的两个序列，默认值为空字符串。两个序列元素都须
    为可哈希对象。

    可选参数AUTOJUNK可设置为False，关闭自动猜想垃圾字符功能。

    SequenceMatcher对象有下面3个熟悉：

    - bjunk：序列B中的“垃圾”字符组成的集合。
    - bpopular：序列B中被自动猜想为“受欢迎”的的字符集合（如果autojunk
      参数不为None）。
    - b2j：序列B中除上面两个属包含的字符外，各元素及对应其索引构成的字
      典。
      
    当调用set_seqs()和set_seq2()后，上面3个属性都会相应变化。
    
    #+BEGIN_SRC python :session
      from difflib import SequenceMatcher

      sm = SequenceMatcher(a='abc', b='12 \t', isjunk=lambda x: x in ' \t')
      sm.bjunk
      sm.bpopular
      sm.b2j

      sm.set_seq2('abca')
      sm.bjunk
      sm.bpopular
      sm.b2j
    #+END_SRC
    
    #+RESULTS[d058ba3647002bd19d4fe15aaa70473eac99bbe3]:
    :
    : >>> >>> {'\t', ' '}
    : set()
    : {'1':    [0], '2': [1]}
    : >>> >>> set()
    : set()
    : {'c':    [2], 'a': [0, 3], 'b': [1]}
    
    SequenceMatcher对象有下列方法：
    
**** *set_seqs* (a,b)
     同时设置被比较的两个序列。
     
     SequenceMatcher会计算缓存序列B的信息。所以，当需将一个序列与多个
     序列比较时，可使用set_seq2固定序列B，再使用set_seq1()不断重复声明
     序列A进行比较。
     
**** *set_seq1* (a)
**** *set_seq2* (b)
     分别设置序列A和B。
     
**** *find_longest_match* (alo,ahi,blo,bhi)
     返回A[alo:ahi]与B[blo:bhi]两个截断中最长的匹配序列。返回值为命名
     元组：Match(a, b, size)。
     
     - 如果isjunk参数为None：如果有多个匹配长度相同，则返回A和B中最前
       面开始匹配的索引，及最长长度。
       
     - 如果isjunk不为None：如下面第二例，序列A中的“ abcd”并不会与序列B
       中的“ abcd”匹配，而是将序列A中的“abcd”与序列B中最左边的“abcd”想
       匹配。
       
     - 如果没有匹配：返回(alo, blo, 0)
       
     #+BEGIN_SRC python :session
       from difflib import SequenceMatcher

       # isjunk == None
       sm = SequenceMatcher(a=' abcd', b='abcd abcd')
       match = sm.find_longest_match(0, 5, 0, 9)
       print(match)
       print(match.a, match.b, match.size)

       # isjunk != None
       sm1 = SequenceMatcher(a=' abcd', b='abcd abcd', isjunk=(lambda x: x == ' '))
       sm1.find_longest_match(0, 5, 0, 9)

       # 没有匹配
       sm2 = SequenceMatcher(a='aaa', b='bbb')
       sm2.find_longest_match(0, 3, 0, 3)
     #+END_SRC
     
     #+RESULTS[29ed74fed75af62e2493de5e39508c118446538a]:
     :
     : >>> ... >>> >>> Match(a=0, b=4, size=5)
     : 0 4 5
     : >>> ... >>> Match(a=1, b=0, size=4)
     : >>> ... >>> Match(a=0, b=0, size=0)
     
**** *get_matching_blocks* ()
     返回由三元素命名元组组成的链表。其中每个元素为(i, j, n)，含义为
     A[i:i+n]==B[j:j+n]。每个命名元组中i和j单调递增。
     
     最后一个元素无实际含义，总是(len(A), len(B), 0)。
     
     #+BEGIN_SRC python :session
       from difflib import SequenceMatcher

       sm = SequenceMatcher(isjunk=None, a='abxcd', b='abcd')

       sm.get_matching_blocks()
     #+END_SRC
     
     #+RESULTS[64e7862d2ec759a2f832ef883c54f782007fe1cf]:
     :
     : >>> >>> >>> [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]
     
**** *get_opcodes* ()
     返回5元素元组组成的链表。每个元组的形式为(tag,i1,i2,j2,j2)。第一
     个元组中有i1==j2==0，后续的元组中有当前i2等于上一个元组的i1，当权
     j2等于上一个元素的j2。

     元组中tag的值及其含义为：

     | 值        | 含义                                 |
     |-----------+--------------------------------------|
     | 'replace' | a[i1:i2]应被b[j2:j2]替代             |
     | 'delete'  | a[i1:i2]应被删除。此时有j2==j2       |
     | 'insert'  | b[j1:j2]应插入到a[i1:i2]。此时i1==i2 |
     | 'equal'   | a[i1:i2] == b[j1:j2]，即两个截断相等 |

     #+BEGIN_SRC python :session
       from difflib import SequenceMatcher
       a = 'qabxcd'
       b = 'abycdf'

       s = SequenceMatcher(None, a, b)
       for tag, i1, i2, j1, j2 in s.get_opcodes():
           print('{:7} a[{}:{}] --> b[{}:{}]]  {!r:>8} --> {!r}'.format(tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2]))
     #+END_SRC

     #+RESULTS[518af92d7c59a279ef670ee485e72bd2f8af51a0]:
     :
     : >>> >>> >>> >>> ... ... delete  a[0:1] --> b[0:0]]       'q' --> ''
     : equal   a[1:3] --> b[0:2]]      'ab' --> 'ab'
     : replace a[3:4] --> b[2:3]]       'x' --> 'y'
     : equal   a[4:6] --> b[3:5]]      'cd' --> 'cd'
     : insert  a[6:6] --> b[5:6]]        '' --> 'f'

**** *get_grouped_opcodes* (n=3)
     与get_opcodes()方法基本相同。N参数为上下文的行数。

     只是返回值为生成器，每个元素对应的元组与get_opcodes()返回值的元素。

**** *ratio* ()
     返回A和B的相似度，0.0-1.0。假设A和B的字符总数为T，按照gestalt算法
     得出的匹配度字符数为M，则其值为： M * 2.0 / T。如果完全相同，返回
     值为1.0；如果没有一个字符匹配，返回值为0.0。

     #+BEGIN_SRC python :session
       from difflib import SequenceMatcher

       sm = SequenceMatcher(None, 'Pennsylvania', 'Pencilvaneya')
       sm.ratio()
     #+END_SRC

     #+RESULTS[70b0b192032da5460b990a8288a1a811668a4fc5]:
     :
     : >>> >>> 0.6666666666666666

     如果之前没有调用过get_matching_blacks()和get_opcodes()方法，调用
     此方法很奢侈，此时可使用quick_ration()或real_quick_ratio()方法，
     获取只大不小的近似值。

**** *quick_ratio* ()
     相对ratio()较快的方法，获取近似值。
**** *real_quick_ratio* ()
     最快获取近似值的方法。

     上面3个方法的值可能会根据快慢不同而不同。后两种方法的返回值不会小
     于ratio()方法的返回值：

     #+BEGIN_SRC python :session
       from difflib import SequenceMatcher
       sm = SequenceMatcher(None, 'Pencilvaneya', 'Pennsylvania')

       sm.ratio()
       sm.quick_ratio()
       sm.real_quick_ratio()
     #+END_SRC

     #+RESULTS[5e3d4404fd22e67afa621b6ead0fce85c18d400a]:
     :
     : >>> >>> 0.6666666666666666
     : 0.8333333333333334
     : 1.0

** SequenceMatcher举例
   下面将空格作为垃圾字符，进行两个字符串比较：
   
   #+BEGIN_SRC python :session
     from difflib import SequenceMatcher

     sm = SequenceMatcher(lambda x: x == ' ', 'private Thread correntThread;',
                          'private volatile Thread currentThread;')
   #+END_SRC
   
   使用ratio()方法查看相似度。一般相似度为0.6表示接近：
   
   #+BEGIN_SRC python :session
     print(round(sm.ratio(), 3))
   #+END_SRC
   
   #+RESULTS[fcb93acff806b9e3a68b9fd8772aa205ab1ca0ce]:
   : 0.836
   
   如果只关心是否有匹配，可使用get_matching_blocks()：

   #+BEGIN_SRC python :session
     for block in sm.get_matching_blocks():
         print('a[{}] and b[{}] match for {} elements'.format(
             block.a, block.b, block.size))

     SequenceMatcher(None, '', '').get_matching_blocks()
   #+END_SRC
   
   #+RESULTS[88f0739b36b32bc72aac669b80392bcfbf2aa3c9]:
   :
   : ... ... a[0] and b[0] match for 8 elements
   : a[8] and b[17] match for 8 elements
   : a[17] and b[26] match for 12 elements
   : a[29] and b[38] match for 0 elements
   : >>> [Match(a=0, b=0, size=0)]

   如果只关心如果将第一个序列改变为第二个序列，可使用get_opcodes()方法：

   #+BEGIN_SRC python :session
     for opcode in sm.get_opcodes():
         print('{:8} a[{}:{}] b[{}:{}]'.format(*opcode))
   #+END_SRC

   #+RESULTS[7a72b1be51e63927b589c4c6369449251d4fd791]:
   :
   : ... equal    a[0:8] b[0:8]
   : insert   a[8:8] b[8:17]
   : equal    a[8:16] b[17:25]
   : replace  a[16:17] b[25:26]
   : equal    a[17:29] b[26:38]

** Differ对象
   Note that Differ-generated deltas make no claim to be minimal
   diffs. To the contrary, minimal diffs are often counter-intuitive,
   because they synch up anywhere possible, sometimes accidental
   matches 100 pages apart. Restricting synch points to contiguous
   matches preserves some notion of locality, at the occasional cost
   of producing a longer diff.
   
   构造器：
   
*** class difflib. *Differ* (linejunk=None,charjunk=None)
    可选参数LINEJUNK和CHARJUNK为过滤函数（默认值为None）：
    
    - LINEJUNK：接受单个字符串参数，如果将其作为垃圾行，则返回True。默
      认值为None，即不将任何行作为垃圾行。
    - CHARJUNK：接受单个字符字符串参数，如果将该字符作为垃圾字符，则返
      回True。默认值为None，即将不将任何字符作为垃圾字符。
      
    此两个过滤函数的原来与find_longest_match()方法的isjunk参数机制一样，
    即只是提高比较速度，但不会忽视已被过滤的行和字符。
    
    唯一的方法：
    
**** *compare* (a,b)
     比较两个由文本行（末尾有换行符的字符串）组成的序列，生成delta（文
     本行序列）。
     
     A和B中的每个元素需为末尾有换行符的字符串。A和B序列可由readlines()
     方法从“类文件”对象中获取，生成的delta是由末尾有换行符的字符串组成
     的序列，可用writelines()方法输出。
     
** Differ举例
   先声明两个由文本行（末尾有换行符的字符串）组成的序列：
   
   #+BEGIN_SRC python :session
     text1 = '''1. Beautiful is better than ugly.
     2. Explicit is better than implicit.
     3. Simple is better than complex.
     4. Complex is better than complicated.
     '''.splitlines(keepends=True)

     text2 = '''1. Beautiful is better than ugly.
     3. Simple is better than complex.
     4. Complicated is better than complex.
     5. Flat is better than nested.
     '''.splitlines(keepends=True)
   #+END_SRC
   
   再声明Differ对象：
   
   #+BEGIN_SRC python :session
     from difflib import Differ
     d = Differ()
   #+END_SRC
   
   使用compare比较者两个字符串，并转换为链表美化输出：
   
   #+BEGIN_SRC python :session
     from pprint import pprint

     d.compare(text1, text2)
     result = list(d.compare(text1, text2))
     pprint(result)
   #+END_SRC

   #+RESULTS[8e6e2df29dfedc1b9237435b472f5b30f89191ed]:
   #+begin_example

   >>> <generator object Differ.compare at 0x7ff8b7de8360>
   >>> ['  1. Beautiful is better than ugly.\n',
    '- 2. Explicit is better than implicit.\n',
    '  3. Simple is better than complex.\n',
    '- 4. Complex is better than complicated.\n',
    '?          ^                     ---- ^\n',
    '+ 4. Complicated is better than complex.\n',
    '?         ++++ ^                      ^\n',
    '+ 5. Flat is better than nested.\n']
   #+end_example

   或使用writelines()方法直接输出：

   #+BEGIN_SRC python :session
     import sys
     sys.stdout.writelines(result)
   #+END_SRC

   #+RESULTS[92400f416f77f13268b50845eb908bde18393cbd]:
   :
   : 1. Beautiful is better than ugly.
   : - 2. Explicit is better than implicit.
   :   3. Simple is better than complex.
   : - 4. Complex is better than complicated.
   : ?          ^                     ---- ^
   : + 4. Complicated is better than complex.
   : ?         ++++ ^                      ^
   : + 5. Flat is better than nested.

** difflib命令行接口实现
   [[file:files/diff.py]] 使用了difflib模块实现类似diff命令行工具的实现。

* textwrap - 文本折叠和填充
  textwrap模块提供文本折叠的帮助函数，以及对应的类TextWrapper。如果只是折
  叠或填充少量文本字符串，使用帮助函数即可；否则最好使用TextWrapper类，
  使效率更高。
  
** textwrap. *wrap* (text,width=70,**kwargs)
   折叠单个文本段落TEXT（字符串），使每行字符数不超过WIDTH。返回折叠后
   的字符串链表，不含末尾换行符。

   关键字参数与TextWrapper对象属性相同，见下文。WIDTH默认值为70。

   详细用法见TextWrapper.wrap()方法。

   #+BEGIN_SRC python :session
     from textwrap import wrap
     wrap('a' * 23, width=10)
   #+END_SRC

   #+RESULTS[276e5e95eb70e0cacd79102a6504f33d8d2c2c3a]:
   :
   : ['aaaaaaaaaa', 'aaaaaaaaaa', 'aaa']

** textwrap. *fill* (text,width=70,**kwargs)
   折叠单个文本段落，返回折叠后的段落字符串。等价于：

   #+BEGIN_SRC python :eval never
     '\n'.join(wrap(text, ...))
   #+END_SRC

   参数用法与wrap()完全相同。

   #+BEGIN_SRC python :session
     from textwrap import wrap, fill
     fill('a' * 23, width=10)
   #+END_SRC

   #+RESULTS[56bfb65e85fa58e885da861c8a8fd26fef0c8f06]:
   :
   : 'aaaaaaaaaa\naaaaaaaaaa\naaa'

** textwrap. *shorten* (text,width,**kwargs)
   将TEXT删减为WIDTH长度。

   首先将相邻的空格替换为单个空格。如果结果 <= WIDTH，则返回；否则删减
   末尾“单词”，使剩余字符加上PLACEHOLDER <= WIDTH。

   #+BEGIN_SRC python :session
     from textwrap import shorten
     shorten('hello  world!', width=120)
     shorten('hello  world!', width=11)
     shorten('hello  world!', width=10, placeholder='...')
   #+END_SRC

   #+RESULTS[533090a9329d615f49b6f23d3a18f573da9647a0]:
   :
   : 'hello world!'
   : 'hello [...]'
   : 'hello...'

   可选关键字参数与TextWrapper对象属性相对应，见下文。

   *注意* ：多余空格在调用TextWrapper.fill()方法前执行，所以修改
   tabsize、expand_tabs、drop_whitespace和replace_whitespace并不会有任
   何效果。

** textwrap. *dedent* (text)
   删除TEXT中每行行首相同的tab或空格。

   *注意* ：空格和tab都被看做whitespace，但两者不相等：“ hello”与
   “\thello”不含相同的行首whitespace。

   #+BEGIN_SRC python :session
     from textwrap import dedent
     text = '''\
             hello
             world
     '''
     print(repr(text))
     print(repr(dedent(text)))
   #+END_SRC

   #+RESULTS[f6a8a9c9b479742b369afd24cc3638e84f926be7]:
   :
   : ... ... ... >>> '        hello\n        world\n'
   : 'hello\nworld\n'

** textwrap. *indent* (text,prefix,predict=None)
   在TEXT中指定的行首添加PREFIX。
   
   每行使用TEXT.splitelines(True)分割获得。
   
   默认情况下，PREFIX添加到除只有whitespace的的行首：
   
   #+BEGIN_SRC python :session
     from textwrap import indent
     s = 'hello\n\n \nworld'
     indent(s, ' ')
   #+END_SRC
   
   #+RESULTS[b7affb53a05e91db1a56cd635f07660095b4b01d]:
   :
   : >>> ' hello\n\n \n world'
   
   可选参数PREDICT为函数对象，控制添加PREFIX的行。如对每行都都添加
   PREFIX：
   
   #+BEGIN_SRC python :session
     print(indent(s, '+', lambda line: True))
   #+END_SRC
   
   #+RESULTS[640c0451f755ecc09aa5ee372fcc9b6d9a79bbdd]:
   : +hello
   : +
   : +
   : +world
   
   wrap()、fill()和shorten()的原理为创建一个全新的TextWrapper实例，再
   调用对应方法。此实例不能被重用，所以对于频繁使用wrap()和fill()的应
   用，先创建TextWrapper对象效率更高。
   
   文本一般在空格或连字符后折叠。如果TextWrapper.break_long_words为
   False，则不折叠“长单词”。
   
** class textwrap. *TexWrapper* (**kwargs)
   TextWrapper类的构造器有许多可选关键字参数。每个关键字参数都对应其实
   例属性，所以：
   
   #+BEGIN_SRC python :eval never
     wrapper = TextWrapper(initial_indent='* ')
   #+END_SRC
   
   等价于：
   
   #+BEGIN_SRC python :eval never
     wrapper = TextWrapper()
     wrapper.initial_indent = '* '
   #+END_SRC
   
   可多次复用TextWrapper对象，期间可更改任意属性。
   
   TextWrapper实例的属性（对应构造器的关键字参数）如下：
   
*** *width*
    默认值：70。折叠后文本行的最大长度。只要TEXT没有单词长度超过
    WIDTH，TextWrapper就能保证折叠后的每行不会超过WIDTH个字符。

    #+BEGIN_SRC python :session
      from textwrap import TextWrapper
      wrapper = TextWrapper(width=70)
      wrapper.width
    #+END_SRC

    #+RESULTS[6449049f98dc5f73de92ca7c052a64470f533434]:
    :
    : >>> 70
    
*** *expand_tabs*
    默认值：True。如果为True，则将TEXT中所有tab都转换为空格。使用
    TEXT的expandtabs()方法。

    #+BEGIN_SRC python :session
      from textwrap import TextWrapper
      wrapper = TextWrapper(expand_tabs=False)
      wrapper.fill('a\tb')
      wrapper.expand_tabs = True
      wrapper.fill('a\tb')
    #+END_SRC

    #+RESULTS[77064e68aa563820d86343c9cffc58ac27b66e4c]:
    :
    : >>> 'a b'
    : >>> 'a       b'

*** *tabsize*
    默认值：8。如果expand_tabs参数为True，则将根据所在列和TABSIZE参
    数将tab替换为0个或多个空格。

    #+BEGIN_SRC python :session
      from textwrap import TextWrapper
      wrapper = TextWrapper()
      wrapper.fill('a\tb')
      wrapper.tabsize = 4
      wrapper.fill('a\tb')
    #+END_SRC

    #+RESULTS[98cc79254ca41f3dd8bf9df7bc345ec81bbda9c5]:
    :
    : >>> 'a       b'
    : >>> 'a   b'

*** *replace_whitespace*
    默认值：True。在tab替换为空格后，折叠前，将“\t\n\v\f\r”（不含
    空格）替换为单个空格。

    *注意* ：如果expand_tabs为False，且replace_whitespace为True，每个
    tab都会被替换为空格，应区别于tab扩张。
    
    *注意* ：如果replace_whitespace为False，且换行符在文本中间。可能会
    根据WIDTH，使用str.splitlines()将文本转换为多个段落再折叠。

    #+BEGIN_SRC python :session
      from textwrap import TextWrapper
      wrapper = TextWrapper()
      wrapper.fill('a\tb\n\nc d\f\v\t\ne')
      wrapper.replace_whitespace = False
      wrapper.fill('a\tb\n\nc d\f\v\t\ne')
    #+END_SRC

    #+RESULTS[900e408d75283070867d645e9d566f48f5c27ffb]:
    :
    : >>> 'a       b  c d      e'
    : >>> 'a       b\n\nc d\x0c\x0b   \ne'

*** *drop_whitespace*
    默认值：True。折叠后，indent前，删除在每行首末的whitespace（含
    空格）。Whitespace at the beginning of the paragraph, however, is
    not dropped if non-whitespace follows it. 如果整行都由whitespace组
    成，则整行都删除。

    #+BEGIN_SRC python :session
      from textwrap import TextWrapper
      wrapper = TextWrapper(width=2)
      wrapper.wrap('ab\n \tcd')
      wrapper.drop_whitespace = False
      wrapper.wrap('ab\n \tcd')
      wrapper.wrap('ab\n \ncd')
    #+END_SRC

    #+RESULTS[e0d138003aba17cd984268e6eec50e614266763e]:
    :
    : >>> ['ab', 'cd']
    : >>> ['ab', '  ', '  ', '  ', '  ', ' ', 'cd']
    : ['ab', '  ', ' ', 'cd']

*** *initial_indent*
    折叠后第一行添加的内容。如果整个字符串为空，则不添加。Counts
    towards the length of the first line.

    #+BEGIN_SRC python :session
      from textwrap import TextWrapper
      wrapper = TextWrapper(initial_indent='++++', width=1)
      print(wrapper.fill('abcd'))
      print(wrapper.fill(''))
    #+END_SRC

    #+RESULTS[7b000c72a4eb0fba0eb240d8f00f8edf87f41e00]:
    :
    : >>> ++++a
    : b
    : c
    : d

*** *subsequent_indent*
    除第一行外，在折叠后的每行前添加的内容。 Counts towards the length
    of each line except the first.

    #+BEGIN_SRC python :session
      from textwrap import TextWrapper
      wrapper = TextWrapper(subsequent_indent='', width=2)
      wrapper.fill('abcd')
      wrapper.subsequent_indent = '+++'
      wrapper.fill('abcd')
    #+END_SRC

    #+RESULTS[bbadce9c8385ad51dd2e0b5d36a39d7c26813400]:
    :
    : >>> 'ab\ncd'
    : >>> 'ab\n+++c\n+++d'

*** *fix_sentence_endings* ？？？
*** *break_long_words*
    默认值：True。是否折叠长度大于WIDTH的单词。如果为False，长度大
    于WIDTH的单词会放在单独一行。

    #+BEGIN_SRC python :session
      from textwrap import TextWrapper

      wrapper = TextWrapper(width=3)
      wrapper.fill('abcd')
      wrapper.break_long_words = False
      wrapper.fill('abcd')
    #+END_SRC

    #+RESULTS[16b316b0b313cd614858ac3b5f639f0b609c0491]:
    :
    : >>> >>> 'abc\nd'
    : >>> 'abcd'

*** *break_on_hyphens*
    默认值：True。如果为True，可能在whitespace和连字符后换行，否则只在
    whitespace处换行。如需将连字符连接的单词放在一行，需声明
    break_long_words为False。

    #+BEGIN_SRC python :session
      from textwrap import TextWrapper
      wrapper = TextWrapper(width=3)
      wrapper.fill('ab-d')
      wrapper.break_on_hyphens = False
      wrapper.fill('ab-d')
      wrapper.break_long_words = False
      wrapper.fill('ab-d')
    #+END_SRC

    #+RESULTS[8ec7a4c7e028cff567c6f78e001dfb3bfe0d8b9f]:
    :
    : >>> 'ab-\nd'
    : >>> 'ab-\nd'
    : >>> 'ab-d'

*** *max_lines*
    默认值：None。如果不为None，则结果最多含MAX_LINES行，其他行用
    placeholder表示。
    
    #+BEGIN_SRC python :session
      from textwrap import TextWrapper
      wrapper = TextWrapper(width=2)
      wrapper.fill('abcdefg')
      wrapper.max_lines = 3
      wrapper.placeholder = '..'
      wrapper.fill('abcdefg')
    #+END_SRC

    #+RESULTS[1529d1243e154533fc73a77d9675f611529378e9]:
    :
    : >>> 'ab\ncd\nef\ng'
    : >>> >>> 'ab\ncd\n..'

*** *placeholder*
    默认值：“[...]”。如果折叠后的文本末尾有内容被删除，则使用此变量值
    代替。

    #+BEGIN_SRC python :session
      from textwrap import TextWrapper
      wrapper = TextWrapper(width=5, max_lines=2)
      wrapper.fill('abc' * 10)
      wrapper.placeholder = '...'
      wrapper.fill('abc' * 10)
    #+END_SRC

    #+RESULTS[3714850c2fcd10c80dc7ab4f94f56e40575d5d34]:
    :
    : >>> 'abcab\n[...]'
    : >>> 'abcab\n...'

*** 方法
**** *wrap* (text)
     折叠单个段落TEXT，使每行最多有WIDTH个字符。所有选择都从
     TextWrapper实例的的属性中获取。返回字符串链表，每个字符串元素不含
     换行符。如果没有任何内容，返回空链表。

**** *fill* (text)
     折叠单个段落TEXT，返回折叠后的字符串。

* unicodedate - Unicode数据库
  ASCII、Unicode和UTF-8的简介，参考 [[http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html][阮一峰的博客]] 。
** 函数
*** unicodedate. *lookup* (name)

    #+BEGIN_SRC python :session
      import unicodedata

      unicodedata.lookup('END OF TEXT')
      unicodedata.lookup('ETX')

    #+END_SRC

    #+RESULTS[16d6ad1354145377fe97fdd5378a9cca94d7a500]:
    :
    : >>> '\x03'
    : '\x03'

*** unicodedate. *name* (chr[,default])

    #+BEGIN_SRC python :session
      import unicodedata
      unicodedata.name('a')
      unicodedata.name('一')
    #+END_SRC

    #+RESULTS[b07ba84b9e1bb0b18e9214a1071b0ec6790bbdd9]:
    :
    : 'LATIN SMALL LETTER A'
    : 'CJK UNIFIED IDEOGRAPH-4E00'

*** unicodedate. *decimal* (chr[,default])

    #+BEGIN_SRC python :session
      import unicodedata
      unicodedata.decimal('1')
      unicodedata.decimal('一', 1)
    #+END_SRC

    #+RESULTS[d27ddbfa90bc790d69f1c3c4f99ef952188e1644]:
    :
    : 1
    : 1

*** unicodedate. *digit* (char[,default])

    #+BEGIN_SRC python :session
      import unicodedata
      unicodedata.digit('1')
      unicodedata.digit('柒',7)
    #+END_SRC
    
    #+RESULTS[8e225a07a0bccf9e1a3df7221a49a1c57a91d50f]:
    :
    : 1
    : 7

*** unicodedate. *numeric* (chr[,default])

    #+BEGIN_SRC python :session
      import unicodedata
      unicodedata.numeric('1')
      unicodedata.numeric('叁')
    #+END_SRC
    
    #+RESULTS[d638aad5a39cf92b36eede2bbbe8317c6a05df87]:
    :
    : 1.0
    : >>> 3.0

*** unicodedate. *category* (chr)

    #+BEGIN_SRC python :session
      import unicodedata
      unicodedata.category('一')
      unicodedata.category('1')
      unicodedata.category('。')
    #+END_SRC

    #+RESULTS[fea1962fdb42ce8c90be6d7c7b4b9f305fd4339b]:
    :
    : 'Lo'
    : 'Nd'
    : 'Po'

*** unicodedate. *bidirectional* (chr)

    #+BEGIN_SRC python :session
      import unicodedata
      unicodedata.bidirectional('1')
      unicodedata.bidirectional('a')
      unicodedata.bidirectional('一')
    #+END_SRC

    #+RESULTS[4d6a93b44d930e8dd0ce23ca05c54bfb49b4f349]:
    :
    : 'EN'
    : 'L'
    : 'L'

*** unicodedate. *combining* (chr)
    #+BEGIN_SRC python :session
      import unicodedata
      unicodedata.combining('一')
      unicodedata.combining('1')
    #+END_SRC

    #+RESULTS[2ab4aab7afb75b673ca3c8347be616b8f677d097]:
    :
    : 0
    : 0

*** unicodedate. *east_asian_width* (chr)

    #+BEGIN_SRC python :session
      import unicodedata
      unicodedata.east_asian_width('一')
      unicodedata.east_asian_width('。')
    #+END_SRC

    #+RESULTS[ded65a7d1c9bf497ebe3cb2e7e173eb2968adaab]:
    :
    : 'W'
    : 'W'

*** unicodedate. *mirrored* (chr)
    #+BEGIN_SRC python :session
      import unicodedata
      unicodedata.mirrored('一')
      unicodedata.mirrored('1')
    #+END_SRC

    #+RESULTS[f5c3eff46272211b2618fbf99ccfc70441cb3607]:
    :
    : 0
    : 0

*** unicodedate. *decomposition* (chr)
*** unicodedate. *normalize* (from,unistr)
** 属性
*** unicodedate. *unidate_version*

    #+BEGIN_SRC python :session
      import unicodedata
      unicodedata.unidata_version
    #+END_SRC

    #+RESULTS[9b28c6f2cc967234744d96f87ef8944df9bec5a6]:
    :
    : '8.0.0'

*** unicodedate. *ucd_3_2_0*

    #+BEGIN_SRC python :session
      import unicodedata
      unicodedata.ucd_3_2_0
    #+END_SRC

    #+RESULTS[beb6d74e7387eff7d42791c5464a931e584b227d]:
    :
    : <unicodedata.UCD object at 0x7f945959e968>

** 举例
   
   #+BEGIN_EXAMPLE python
     >>> import unicodedata
     >>> unicodedata.lookup('LEFT CURLY BRACKET')
     '{'
     >>> unicodedata.name('/')
     'SOLIDUS'
     >>> unicodedata.decimal('9')
     9
     >>> unicodedata.decimal('a')
     Traceback (most recent call last):
         File "<stdin>", line 1, in <module>
     ValueError: not a decimal
     >>> unicodedata.category('A')
     'Lu'
     >>> unicodedata.category('\u0660')
     'Nd'
   #+END_EXAMPLE
   
* stringprep
* readline
* rlconpleter
