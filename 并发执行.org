# Author: Claudio <3261958605@qq.com>
# Created: 2017-06-02 11:40:31
# Commentary:
#+TITLE: 并发执行

[[file:~/Desktop/Python/resources/site/docs.python.org/3.5/library/concurrency.html][本地页面]]

本章介绍的模块可实现并发执行代码。是否选用并发执行取决于程序需求，榨干
CPU性能还是IO性能，协作多任务还是优先多任务。

* threading - 以线程为基础并发
  threading模块主要用来同时运行I/O操作频繁的任务，如需利用多核CPU，可
  参考multiprocessing模块。

  本模块建立在底层_thread模块上，提供操作线程的高阶接口。还可参见queue
  模块。

  如果缺少_thread模块，则不能使用threading模块，此时可使用
  dummy_threading模块作为替代品。

** 模块函数
*** threading. *active_count* ()
    当前存活的Thread对象数量，等于threading.enumerate()调用结果的长度。

    #+BEGIN_SRC python :session
      import threading
      print('当前Thread对象数量：', threading.active_count())
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> 当前Thread对象数量： 1
    #+END_SRC

*** threading. *current_thread* ()
    返回当前Thread对象，与控制调用环境的线程相关。如果调用函数在不为通过
    threading模块创建，则返回功能优先的“虚假”线程对象。？？？
*** threading. *get_ident* ()
    返回当前线程的“身份”，为非0整数。此数值并没有直接的实际含义，主要
    用来作为一个“魔法cookie”。比如用来索引线程相关的字典。当线程退出，
    另一个线程创建时，线程“身份”可能被垃圾回收。

    #+BEGIN_SRC python :session
      import threading
      print(threading.current_thread())
      print(threading.get_ident())
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - <_MainThread(MainThread, started 140373658789632)>
    - 140373658789632
    #+END_SRC

*** threading. *enumerate* ()
    返回当前所有存活线程注册的链表。

    包含：后台线程（daemonic threads）、current_thread()创建的“虚假”线
    程（dummy thread）、以及主线程。

    不包括：已经被终止的线程，还没开始执行的线程。

*** threading. *main_thread* ()
    返回主线程Thread对象。普通情况下，当Python解释器开启时就启动主线程。

*** threading. *settrace* (func) ？？？
    为所有threading模块创建的线程添加跟踪函数（“trace function”）。在
    执行run()方法前，FUNC参数会传递给sys.settrace()函数。

*** threading. *setprofile* (func) ？？？
    为所有threading模块创建的线程添加profile函数。在执行run()方法前，
    FUNC参数会传递给sys.setprofile()函数。

*** threading. *stack_size* ([size]) ？？？
    返回创建新线程时，线程使用的stack大小。

    size：可选参数，指定以后创建线程时分配的stack大小。默认为0，即使用
    系统默认配置。如果设置，则需为>=32,768（32KiB）。如果不支持设置，
    则抛出RuntimeError错误；如果数值无效，则抛出ValueError错误，不做修
    改。目前支持的最小stack为32KiB。

    设置时，对系统有依赖。（待续）

** 模块常量
*** threading. *TIMEOUT_MAX*
    本模块中函数/构造器TIMEOUT参数允许的最大值，如Lock.acquire()、
    Rlock.acquire()和Condition.wait()等。如果超过此值，则抛出
    OverflowError错误。

    #+BEGIN_SRC python :session
      import threading
      threading.TIMEOUT_MAX
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 9223372036.0
    #+END_SRC

** 线程本地变量 ？？？
   线程本地变量，其值只在线程中有效。使用threading.local（或子类），可
   创建线程本地变量。

   #+BEGIN_EXAMPLE python
     mydata = threading.local()
     mydata.x = 1
   #+END_EXAMPLE

   实例的值在不同线程中相互独立。

*** class threading. *local*
    表示线程本地变量数据的类。

    具体用法可参考_threading_local模块的文档。

** Thread对象
   Thread类表示独立允许的线程活动。有两种办法创建线程：

   1. 在构造器中传递可调用对象。
   2. 使用子类，重置run()方法。

      *声明Thread子类时，只能重置__init__()和run()方法。*

   当创建Thread对象后，只有调用其start()方法才能激活线程。激活后在独立
   的线程中运行run()方法。

   当线程启动后，则表示线程“存活”。当run()方法执行结束——正常结束或抛出
   错误没被处理，则线程“终止”。可使用is_alive()方法判断线程使用“存活”。

   线程可调用join()方法，调用后，直到调用join()方法的线程的join()方法
   执行结束后，才会执行当前线程中的代码。

   Thread对象具有name属性，可在构造器中指定，此属性可写。

   当线程声明为“后台线程”时，即声明构造器的daemon参数为True，如果主线
   程退出时，“后台线程”还没执行完，也会随之退出。可通过修改Thread对象
   的daemon属性，或在构造器中声明。是否为“后台线程”，默认继承于创建它
   的线程。

   #+BEGIN_SRC python :session
     import threading as td
     import time

     def job():
         time.sleep(2)
         print('执行子线程函数。')

     def multi_thread():
         t1 = td.Thread(target=job, daemon=True)
         t1.start()
         # t1.join()

     multi_thread()
     print('主线程执行结束')
   #+END_SRC

   #+RESULTS:
   #+BEGIN_SRC org
   - >>> >>> ... ... ... >>> ... ... ... ... >>> >>> 主线程执行结束
   #+END_SRC

   #+BEGIN_QUOTE
   *注意* ： “后台线程”退出可能非常“唐突”，如不能合理释放资源（如已打
   开文件和数据库事务）。如需优雅退出“后台线程”，可使其“非后台化”，并
   使用合适的信号机制，如后面介绍的threading.Event对象。
   #+END_QUOTE

   总是有一个“主线程”，即控制Python程序的初始线程，从不为“后台线程”。

   有可能会自动创建“虚拟线程对象（dummy thread objects）”。他们为“外部
   线程（alien threads）”，在threading模块外创建，如直接从C代码创建。
   “虚拟线程”功能有限，且总是“存活”，并且为“后台线程”，不能调用join()
   方法，不能被删除。

*** class threading. *Thread* (group=None,target=None,name=None,args=(),kwargs={},*,daemon=None)

    *使用此构造器时，只能使用关键字参数。* 各参数的含义为：

    group：需为None，为以后支持ThreadGroup实现扩展预留的参数。

    target：可调用对象，被run()方法激活。默认为None，即不进行任何调用。

    name：线程名称。构造时默认创建"Thread-N"，其中N为十进制数。

    args：target指定可调用对象的参数，默认为()。

    kwargs：字典对象，target指定可调用对象的关键字参数，默认为{}。

    daemon：明确声明新建线程是否为“后台线程”。如果为None（默认值），
    则根据创建线程的线程是否为“后台线程”而定。

    *如果子类重载此构造器，则需保证在__init__()声明中，做任何事前声明
    Thread.__init__()。*

**** start()
     激活线程。

     只能调用一次。目的时将Thread对象的run()方法放置在新建的线程中执行。

     如果调用多次，则抛出RuntimeError错误。

**** run()
     表示线程活动的方法。

     可在子类中重置此方法；标准的run()方法会调用构造器中target参数指定
     的可调用对象，并让其调用args和kwargs指定的参数。

**** join(timeout=None)
     等待直到线程执行结束。使所在线程中的代码，直到该线程的join()方法
     调用终止（正常结束、抛出错误不被处理、超过timeout指定时间）后才执
     行。

     timeout：如果不为None，须为指定秒数的浮点数。由于join()方法总是返
     回None，所以如果使用timeout参数，需使用is_alive()方法判断子线程是
     否依然“存活”，再决定是否重新调用join()方法。

     当timeout参数为None或缺省时，所有代码会被阻塞至子线程执行结束后才
     执行。

     一个线程对象可调用多次join()方法。

     如果对可能造成“锁死”的线程对象调用join()方法，会抛出RuntimeError
     错误。如果在调用start()方法前调用join()方法，也会抛出RuntimeError
     错误。

     #+BEGIN_SRC python :session
       import threading as td
       import time

       def job():
           time.sleep(2)
           print('子线程执行结束。')

       def multi_thread():
           t1 = td.Thread(target=job)
           t1.start()
           t1.join(1)
           print('子线程是否存活：', t1.is_alive())
           if t1.is_alive():
               t1.join()

       multi_thread()
       print('主线程执行结束')
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> ... ... ... >>> ... ... ... ... ... ... ... >>> 子线程是否存活： True
     - 子线程执行结束。
     - 主线程执行结束
     #+END_SRC

**** name
     用来辨别线程的字符串，没有实际含义。多个线程可有相同名字。初始名
     字由构造器自动生成。
**** getName()
**** setName()
     name属性的旧API。
**** ident
     “线程身份”，如果线程还没启动则为None，如果已启动则为非0整数。当一
     个线程退出，另一个线程启动时，此“身份”可能被重新利用。即时线程退
     出后，也可获取。

**** is_alive()
     如果线程为“存活”状态，则返回True。

     在run()方法开始执行前，run()方法结束前，都返回True。模块函数
     enumerate()返回内容只含当前“存活”线程。

**** daemon
     表示是否为“后台线程”的布尔值。如果赋值，则需在调用start()方法前，
     否则抛出RuntimeError错误。默认继承于创建该线程是否为“后台线程”，
     主线程不为“后台线程”，所以在主线程中创建的线程默认daemon=False。

     当没有非“后台线程”存活时，整个Python程序退出。

**** isDeamon()
**** setDaemon()
     daemon属性的旧API。

** Lock对象
   一个原始的lock为一个同步原始，当锁定后，不属于任何一个特点线程。在
   Python中，此类型为目前最底层的同步原始，由_thread扩展模块直接实
   现。？？？

   一个原始lock有两种状态：“locked（锁定）”和“unlocked（去锁定）”。有
   两个基本发股份：acquire()和release()。当“去锁定”后，使用acquire()可
   将状态改变为“锁定”状态，并立即返回。当“锁定”后，acquire()会使当前线
   程一直阻塞，直到另一个线程中调用release()方法，将其“解锁”，然后可重
   新调用acquire()将其“锁定”并返回。release()方法只能在“锁定”状态下调
   用，否则抛出RuntimeError错误。

   支持上下文管理器协议。

   当在多个线程中调用acquire()锁定线程后，再调用release()方法时只能解
   锁一个线程；具体解锁哪一个根据Python实现不定。

*** class threading. *Lock*
    实现原始lock对象的类。当对某个线程锁定后，直到调用release()才释放
    （任何线程可操作此释放行为）。

**** acquire(blocking=True,timeout=-1)
**** release()
** Rlock对象
** Condition对象
** Semaphore对象
*** Semaphore举例
** Event对象
** Timer对象
** Barrier对象
** 在with上下文管理器中使用locks、conditions和semaphores
* multiprocessing - 以进程为基础的并发
* concurrent包
* concurrent.future
* subprocess
  subprocess模块用于产生新进程，连接自己的输出/输入/错误流管道，并获取
  返回码。此模块旨在替换几个旧模块和函数：

  #+BEGIN_EXAMPLE python
    os.system
    os.spawn*
  #+END_EXAMPLE

** 使用subprocess模块
   如需激活子进程，建议尽量使用run()函数；如需更高阶定制，可直接使用底
   层的Popen接口。

   run()函数在Python3.5时才新增，如需向后兼容，参考后面的“旧高阶API”。

*** subprocess. *run* (args,*,stdin=None,input=None,stderr=None,shell=False,timeout=None,check=False)
    执行ARGS指定的命令，等待执行结束，返回CompleteProcess实例。

    参数使用方法参考后面的“常用参数”。用法基本上与Popen构造器的参数用
    法相同，timeout、input和check除外。实际上，本函数所有参数都传递给
    Popen接口。

    默认情况下，不会捕获标准输出和标准错误流。如需捕获，传递PIPI作为
    STDOUT/STDERR参数值。

    TIMEOUT参数实际上传递给Popen.communicate()函数。如果超时，子进程被
    干掉，然后等待。子进程被终止后，TimeExpired错误会重新抛出。

    INPUT参数也会传递给Popen.communicate()函数，作为子进程的标准输入流。
    如果使用，须为比特序列，或参数UNIVERSAL_NEWLINES=True的情况下可为
    字符串。使用后，内部的Popen对象会自动将STDIN参数设置为PIPE，就可能
    不使用本函数的STDIN参数。

    如果CHECK参数为true，且子进程返回码（exit code）不为0，则抛出
    CalledProcessError错误。如果捕获的stdout和stderr，从抛出Exception
    的属性可获取本函数参数，以及退出码等信息。

    举例：

    #+BEGIN_EXAMPLE sh
      >>> subprocess.run(['ls', '-l']) # 不捕获输出，只是打印
      total 0
      -rw-r--r-- 1 claudio claudio 0 Jun  3 15:53 text.txt
      CompletedProcess(args=['ls', '-l'], returncode=0)
      >>> subprocess.run('exit 1', shell=True)
      CompletedProcess(args='exit 1', returncode=1)
      >>> subprocess.run('exit 1', shell=True, check=True)
      Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
        File "/usr/lib/python3.5/subprocess.py", line 398, in run
        output=stdout, stderr=stderr)
      >>> subprocess.run(['ls', '-l', '/dev/null'], stdout=subprocess.PIPE) # 捕获输出
      CompletedProcess(args=['ls', '-l', '/dev/null'], returncode=0, stdout=b'crw-rw-rw- 1 root root 1, 3 Jun  2 10:27 /dev/null\n')
    #+END_EXAMPLE

*** class subprocess. *CompletedProcess*
    run()函数返回值，表示该子进程已经执行完成。有下面属性。

**** args
     传递给run()函数执行的命令，可能是字符串也可能为链表。

**** returncode
     子进程返回码，0表示子进程成功执行完成。

     POSIX中，如果为数值-N，表示子进程被信号N终止。

**** stdout
     从子进程标准输出流捕获的内容，一般为bytes对象，如果run()使用参数
     universal_newlines=True参数，则为字符串。

**** stderr
     从子进程标准错误流捕获的内容，一般为bytes对象，如果run()使用参数
     universal_newlines=True参数，则为字符串。
**** check_returncode()
     如果returncode不为0，抛出CalledProcessError错误，否则返回None。

*** subprocess. *DEVNULL*
    可用于Popen的STDIN、STDOUT和STDERR参数的特殊值，表示使用特殊文件
    os.devnull。

*** subprocess. *PIPE*
    可用于Popen的STDIN、STDOUT和STDERR参数的特殊值，表示对应标准流会打
    开一个管道。与Popen.communicate()一起使用更有用。

*** subprocess. *STDOUT*
    用于Popen的stderr参数的特殊值，当stderr=subprocess.STDOUT时，可将
    标准错误流重定向到标准输出流。

*** exception subprocess. *SubprocessError*
    本模块所有exception的基础类。

*** exception subprocess. *TimeoutExpired*
    SubprocessError的子类，当等待子进程超时时抛出。有如需属性：

    #+BEGIN_SRC python :session
      import subprocess
      import sys
      DECODING = sys.getdefaultencoding()
      try:
          subprocess.run(['ping', 'bing.com'], stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE, timeout=2)
      except subprocess.TimeoutExpired as time_why:
          print('cmd：', time_why.cmd)
          print('timeout：', time_why.timeout)
          print('output：', time_why.output.decode(DECODING))
          print('stdout：', time_why.stdout.decode(DECODING))
          print('stderr：', time_why.stderr.decode(DECODING))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> >>> ... ... ... ... ... ... ... ... ... cmd： ['ping', 'bing.com']
    - timeout： 2
    - output： PING bing.com (204.79.197.200) 56(84) bytes of data.
    - 64 bytes from bing.com (204.79.197.200): icmp_seq=2 ttl=116 time=49.1 ms
    - stdout： PING bing.com (204.79.197.200) 56(84) bytes of data.
    - 64 bytes from bing.com (204.79.197.200): icmp_seq=2 ttl=116 time=49.1 ms
    - stderr：
    #+END_SRC

**** cmd
     激活子进程的命令。
**** timeout
     超时时长秒数。
**** output
     子进程输出（如果被run()或check_output()捕获），否则为None。
**** stdout
     output的别名，为保证与stderr语义一致。
**** stderr
     子进程标准错误流（如果被run()捕获），否则为None。

*** exception subprocess. *CalledProcessError*
    SubprocessError子类，当进程被check_all()或check_ooutput()执行返回
    非0返回码时抛出。

    #+BEGIN_SRC python :session
      import subprocess

      try:
          proc = subprocess.run(
              ['ls', 'not-exists'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
      except subprocess.CalledProcessError as why:
          print('returncode：', why.returncode)
          print('cmd：', why.cmd)
          print('output：', why.output)
          print('stdout：', why.stdout)
          print('stderr：', why.stderr)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> ... ... ... ... ... ... ... ... ... returncode： 2
    - cmd： ['ls', 'not-exists']
    - output： b''
    - stdout： b''
    - stderr： b"ls: cannot access 'not-exists': No such file or directory\n"
    #+END_SRC

**** returncode
     子进程返回码。如果子进程因信号退出，则为表示信号的负数。
**** cmd
     激活子进程的命令。

**** output
     子进程输出（如果被run()或check_output()捕获），否则为None。
**** stdout
     output的别名，为保证与stderr语义一致。
**** stderr
     子进程标准错误流（如果被run()捕获），否则为None。

*** 常用参数
    为支持不同的使用场景，Popen构造器和run()函数使用大量可选参数。大多
    数情况下，许多参数可省略使用默认值，常用的参数如下：

**** ARGS
     执行命令，可为字符，也可为命令和参数组成的序列（如链表）。首选序
     列，这样可方便处理命令参数的转义和添加引号（如允许命令参数为有空
     格的字符串）。如果为单个字符串，要么SHELL参数需为True，要么执行命
     令不得带任何参数。

**** STDIN、STDOUT和STDERR
     表示命令执行的标准输入流、输出流和错误流定向方式。可选值为
     subprocess.PIPE、subprocess.DEVNULL、已存在的文件描述符（正数）、
     已存在的文件对象或None。PIPE表示会为子进程打开一个管道。DEVNULL表
     示使用os.devnull文件。默认为None，表示不对标准流进行任何重定向。
     子进程文件处理继承于父进程。此外，STDERR可设置为subprocess.STDOUT，
     将标准错误流重定向到标准输出流。

**** UNIVERSAL_NEWLINES
     如果UNIVERSAL_NEWLINES为False，则stdin、stdout和stderr都使用二进
     制模式，不会自动转换换行符。

     如果UNIVERSAL_NEWLINES为True，则文件对象以文本模式打开，使用
     locale.getpreferredecodiong(False)编码和解码。对应stdin，换行符
     "\n"自动转换为os.linesep；对于stdout，所有输入的换行符都转换为
     "\n"。

     #+BEGIN_QUOTE
     *注意* ：Popen.communicate()不会自动更新Popen.stdin、Popen.stdout
     和Popen.stderr不会的换行符属性。
     #+END_QUOTE

**** SHELL
     当SHELL属性为，命令会在shell环境中执行。即可使用shell本身的特性，
     如管道、文件名通配符、环境变量扩张、家目录"~"扩张等特性。不过，
     Python已提供类似shell的特性，如glob、fnmath、os.path.expanduser()
     等。

     #+BEGIN_QUOTE
     *注意* ：参考后文“安全”小节有关shell=True时的说明。
     #+END_QUOTE

     下面为使用shell=True后使用家目录扩张的例子：

     #+BEGIN_EXAMPLE ipython
       In [60]: subprocess.run(['ls', '~'])
       ls: cannot access '~': No such file or directory
       Out[60]: CompletedProcess(args=['ls', '~'], returncode=2)

       In [61]: subprocess.run(['ls', '~'], shell=True)
       Backup    Documents  Music           Pictures   Templates  Videos
       bin        Downloads  myarchive.tar.gz  Public  test
       Desktop  dwhelper   PDF                               python    test.txt
       Out[61]: CompletedProcess(args=['ls', '~'], returncode=0)
     #+END_EXAMPLE

*** POPEN构造器
    本模块的底层使用Popen类实现，可利用此类更灵活定制run()等函数不能处
    理的情况。

**** class subprocess. *Popen* (args,bufsize=-1,executable=None,stdin=None,stdout=None,stderr=None,preexec_fn=None,close_fds=True,shell=False,cwd=None,env=None,universal_newline=False,startupinfo=None,creationflags=0,restore_signals=True,start_new_session=False,pass_fds=())
     在程序中执行新进程。在POSIX中，使用与os.execvp()类似方法执行子程
     序；Windows中，调用系统CreateProcess()函数。参数使用方法如下：

     - args：为序列或字符串。默认情况下，如果args为序列，则第一个元素
       为需执行的命令；如果为字符串，则依赖不同系统类型，可参考后面关
       于shell和executable参数的介绍。 *首选使用序列，而非字符串。*

       在POSIX中，如果args为字符串，会将字符串解释为可支持程序的路径，
       如"/bin/ls"。但不能更任何参数。

       #+BEGIN_SRC python :session
         import shlex
         import subprocess
         commad_line = '''/usr/bin/viking -input eggs.txt -output "spam spam.txt" -cmd "echo '$MONEY'"'''
         args = shlex.split(commad_line)
         print(args)
         p = subprocess.Popen(args)
       #+END_SRC

       #+RESULTS:
       #+BEGIN_SRC org
       - >>> >>> >>> ['/usr/bin/viking', '-input', 'eggs.txt', '-output', 'spam spam.txt', '-cmd', "echo '$MONEY'"]
       #+END_SRC

       在Windows中，如果args为序列，会转换为字符串，因为系统调用时使用
       的CreateProcess()函数接受字符串参数。

     - shell：默认为False，指定是否使用shell执行程序。如果为True，建议
       使用字符串对象作为args参数值。

       *不建议使用shell=True*

       在POSIX中，当shell=True时，默认使用/bin/sh。ARGS为字符串，将直
       接执行字符串指定的命令，即字符换需与在命令行中直接输入的一样，
       比如引号和转义文件名中的空格的斜杠；如果ARGS为序列，则第一个元
       素表示命令，其余元素表示该命令的参数，即等价于：

       #+BEGIN_EXAMPLE python
         Popen(['/bin/sh', '-c', args[0], args[1], ...])
       #+END_EXAMPLE

       Windows中：（待续）

     - bufsize：与open()函数的bufsize含义相同，用于创建
       stdin/stdout/stderr管道对象：

       - 0：表示不使用缓存。
       - 1：行缓存（仅在universal_newlines=True，如文本模式中有用）。
       - 任何其他正数：使用与该数值接近的缓存大小。
       - 负数（默认）：使用系统默认缓存大小：io.DEFAULT_BUFFER_SIZE。

     - executable：很少使用。当shell=False时，表示替换ARGS指定的命令。

     - stdin、stdout和stderr：见run()函数。

     - preexec_fn：可调用对象，在至今才执行前执行。仅在POSIX中有效。不
       安全。

     - close_fds：默认为True，表示当子进程执行完毕后，文件描述符0、1和
       2将关闭（只在POSIX中有效）。

     - pass_fds：

     - cwd：

     - restore_signals

     - start_new_session

     - env：指定执行子进程时环境变量的映射。默认为None，即使用当前进程
       的环境变量。

     - universal_newlines：当为True时，stdin、stdout和stderr都以文本模
       式打开。默认为False，即以二进制模式打开。

     - startupinfo

     Popen对象支持with上下文管理器，当exit时，标准文件描述符被关闭，进
     程被等待：

     #+BEGIN_EXAMPLE python
       with Popen(['ifconfig'], stdout=PIPE) as proc:
            log.write(proc.stdout.read())
     #+END_EXAMPLE

*** Exceptions
    当新进程开始执行后，抛出的所有错误会被父进程重新抛出。此外，抛出的
    错误有child_traceback属性，为子进程traceback信息的字符串（？？？怎
    么查看）。

    最常见的错误为OSError，比如尝试执行不存在的命令。如果要处理抛出错
    误，需将其包含在内：

    #+BEGIN_EXAMPLE python
      try:
          subprocess.run(['ls', 'qwd'], stderr=subprocess.PIPE, check=True)
      except subprocess.CalledProcessError as proc_why:
          pass
      except OSError as os_why:
          print(os_why)
    #+END_EXAMPLE

    当在Popen中使用无效参数时，会抛出ValueError错误。

    当调用check_all()和check_output()的返回码不为0时，会抛出
    CalledProcessError。

    本模块中所有函数和方法都接受timeout参数，如call()和
    Popen.communicate()，当超时时，会抛出TimeExpired错误。

    本模块中所有错误都继承于SubprocessError。

** 安全
   使用本模块中的函数时，所有字符，包括shell元字符都可安全传入子进程。
   但当shell=True时，需保证为空格和元字符添加引号，避免 [[https://en.wikipedia.org/wiki/Code_injection#Shell_injection][shell注入]] 。

   避免使用shell=True，当使用时，使用shlex.quote()转义命令，转义空格和
   shell元字符。

** Popen对象
   Popen实例有以下方法和属性：

*** Pope. *poll* ()
    检查子进程是否终止。设置和返回returncode属性。？？？

    #+BEGIN_SRC python :session
      from subprocess import Popen
      with Popen(['ls']) as proc:
          print(proc.poll())
          proc.kill()
    #+END_SRC

*** Pope. *wait* (timeout=None)
    等待子进程终止。设置和返回returncode属性。

    如果进程在TIMEOUT参数指定的秒数内没有终止，抛出TimeoutExpired错误。
    可安全捕获此错误，然后在使用wait()方法。

    #+BEGIN_QUOTE
    *注意* ：当使用stdout=PIPE或stderr=PIPE，且子进程想管道输出内容过
    多，导致阻塞操作心态管道接受更多数据时，会造成“锁死”。使用
    Popen.communicate可避免此情况发生。？？？
    #+END_QUOTE

    #+BEGIN_QUOTE
    *注意* ：此函数使用非阻塞调用和短休眠。如需使用同步等待，可参考
    asyncio.create_subprocess_exec。
    #+END_QUOTE

*** Pope. *communicate* (input=None,timeout=None)
    与子进程交流：向stdin发送数据。从stdout和stderr读取数据，直到遇到
    EOF。等待子进程结束。

    返回值为(stdout_data, stderr_data)组成的元组，都为bytes对象。如果
    universal_newlines参数为True，则为字符串。

    input：可选参数，为向子进程发送的数据，如果为None则不发送数据。须
    为bytes对象，如果universal_newlines为True，则为字符串。

    如需指定input参数，向stdin发送数据，则创建Popen实例时，需声明
    stdin=PIPE；同样，如需从返回元组中获取数据，则需声明stdout=PIPE和
    stderr=PIPE，否则只能获取None。

    timeout：如果子进程在TIMEOUT参数指定的时间内为终止，则抛出
    TimeoutExpired错误。捕获此错误，再重新使用communicate()方法不会丢
    失任何输出数据。

    如果抛出TimeoutExpired错误后子进程还没被干掉，需手动干掉，再接受
    communicate()操作：

    #+BEGIN_EXAMPLE python
      proc = subprocess.Popen(...)
      try:
          outs, errs = proc.communicate(timeout=15)
      except TimeoutExpired:
             proc.kill()
             outs, errs = proc.communicate()
    #+END_EXAMPLE

    #+BEGIN_QUOTE
    *注意* ：此方法读取的数据会存储在内存中，所以当数据量大或无限时，
    不要使用此方法。
    #+END_QUOTE

*** Pope. *send_signal* (signal)
    向子进程发生SIGNAL信号。
*** Pope. *terminate* ()
    停止子进程。在POSIX中为发送SIGTERM，在Windows中，则是调用Win32 API
    的TerminateProcess()函数。

*** Pope. *kill* ()
    干掉子进程。在POSIX中为发送SIGKILL信号，在Windows中等价于terminate()。
*** Pope. *args*
    传入Popen的ARGS参数，为序列或字符串。
*** Pope. *stdin*
    如果stdin参数为PIPE，则此属性为可写流对象（与open()函数返回值相同）。
    如果universal_newlines参数为True，则为文本流，否则为二进制流。

    如果stdin参数为None，则此属性值也为None。

    #+BEGIN_SRC python :session
      from subprocess import *
      with Popen(['cat'], stdout=PIPE, stdin=PIPE) as proc:
          proc.stdin.write(b'123')
          print(proc.communicate())
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - ... ... ... 3
    - (b'123', None)
    #+END_SRC

*** Pope. *stdout*
    如果stdout参数为PIPE，则此属性为可读流对象（与open()函数返回值相
    同）。读取此流对象的返回值为子进程的输出值。如果universal_newlines
    参数为True，则为你文本流，否则为二进制流。

    如果stdout参数为None，则此属性值也为None。

*** Pope. *stderr*
    如果stderr参数为PIPE，则此属性为可读流对象（与open()函数返回值相
    同）。读取此流对象的返回值为子进程的输出值。如果universal_newlines
    参数为True，则为你文本流，否则为二进制流。

    如果stderr参数为None，则此属性值也为None。

    #+BEGIN_QUOTE
    *警告* ：避免OS的管道被填满，造成阻塞子进程，进而“锁死”，应使用
    communicate()，而非.stdin.write、stdout.read或stderr.read。
    #+END_QUOTE

*** Pope. *pid*
    返回子进程ID，如果shell=True，则是shell进程的ID。

*** Pope. *returncode*
    子进程返回码，由poll()和wait()设置（间接由communicate()设置）。

    None表示进程还没终止。

    负数-N，表示进程被信号N终止，（仅POSIX有效）。

** Windows Popen帮助 （待续）
*** 常量
** 旧的高阶API
   Python3.5前，下面3个函数旧API函数。现在可使用run()替换，但很多现有
   的代码都使用他们。

*** subprocess. *call* (args,*,stdin=None,stdout=None,stderr=None,shell=False,timeout=None)
    执行ARGS指定的命令，等待执行结束，返回returncode属性。

    除不支持input和check参数外，等价于：

    #+BEGIN_EXAMPLE python
      run(...).returncode
    #+END_EXAMPLE

    除TIMEOUT参数外，此函数的所有参数都传递给Popen接口。

    #+BEGIN_QUOTE
    *注意* ： 不要使用stdout=PIPE或stderr=PIPE。当OS管道没有被读取，且
    此函数产生的数据填满管道后，会造成阻塞。
    #+END_QUOTE

*** subprocess. *check_all* (args,*,stdin=None,stdout=None,stderr=None,shell=False,timeout=None)
    执行ARGS指定的命令，等待命令完成。如果返回码为0，返回，否则抛出
    CalledProcessError错误。可从CalledProcessError中获取returncode属性。

    除不支持input参数外，等价于：

    #+BEGIN_EXAMPLE python
      run(..., check=True)
    #+END_EXAMPLE

    除TIMEOUT参数外，此函数的所有参数都传递给Popen接口。

    #+BEGIN_QUOTE
    *注意* ： 不要使用stdout=PIPE或stderr=PIPE。当OS管道没有被读取，且
    此函数产生的数据填满管道后，会造成阻塞。
    #+END_QUOTE

*** subprocess. *check_output* (args,*,stdin=None,stdout=None,stderr=None,shell=False,timeout=None)
    执行命令，返回执行输出。

    如果返回码不为0，则抛出CalledProcessError。可通过
    CalledProcessError的returncode和output属性分别获取返回码和输出内容。

    除不支持input参数外，大多数参数都传递给run()函数的接口。等价于：

    #+BEGIN_EXAMPLE python
      run(..., check=True, stdout=PIPE).stdout
    #+END_EXAMPLE

    返回结果为bytes对象，编码形式依赖于命令执行环境。所以应该在应用层
    级上解码。？？？

    设置universal_newlines=True后，可使返回字符串。

    如需捕获stderr，可声明参数stderr=subprocess.STDOUT：

    #+BEGIN_SRC python :session
      import subprocess
      subprocess.check_output(
          'ls none_exists_file; exit 0',
          stderr=subprocess.STDOUT,
          shell=True)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - ... ... ... b"ls: cannot access 'none_exists_file': No such file or directory\n"
    #+END_SRC

** 使用subprocess模块替换旧函数

   #+BEGIN_QUOTE
   *注意* ： 本节中所有被替换的函数如果不能找到执行命令，都不会抛出错
   误；而替换函数会抛出OSError错误。

   此外，使用check_output()替换的版本中，如果执行返回码不为0，会抛出
   CalledProcessError错误，可使用output属性获取具体内容。
   #+END_QUOTE

*** 替换/bin/sh的反引号

    #+BEGIN_EXAMPLE sh
      output=`mycmd myarg`
    #+END_EXAMPLE

    可替换为：

    #+BEGIN_EXAMPLE python
      output = check_output(['mycmd', 'myarg'])
    #+END_EXAMPLE

*** 替换管道

    #+BEGIN_EXAMPLE sh
      oputput=`dmesg | grep hda`
    #+END_EXAMPLE

    可替换为：

    #+BEGIN_EXAMPLE python
      p1 = Popen(['dmesg'], stdout=PIPE)
      p2 = Popen(['grep', 'hda'], stdin=p1.stdout, stdout=PIPE)
      p1.stdout.close() # 保证p1在p2退出时接受SIGPIPE信号
      output=p2.communicate()[0]
    #+END_EXAMPLE

    如果输如可信任，可直接使用shell的管道：

    #+BEGIN_EXAMPLE python
      output = check_output('dmesg | grep hda', shell=True)
    #+END_EXAMPLE

*** 替换os.system()函数

    #+BEGIN_EXAMPLE python
      sts = os.system('mycmd' + ' myarg')
      # 替换为
      sts = call('mycmd' + ' myarg', shell=True)
    #+END_EXAMPLE

    更实际的例子为：

    #+BEGIN_EXAMPLE python
      try:
          retcode = call('mycmd', + ' myarg', shell=True)
          if rtcode < 0:
             print('子进程被信号中断', -rtcode, file=sys.stderr)
          else:
             print('子进程返回', rtcode, file=sys.stderr)
      except OSError as e:
          print('执行失败：', e, file=sys.stderr)
    #+END_EXAMPLE

*** 替换os.spawn类函数 （待续）
*** 替换os.popen()、os.popen2()和os.popen3() （待续）
*** 替换popen2模块的函数 （待续）
** 遗留Shell激活函数 （存在于2.x中，可能不安全，待续）
** 注意点 （待续）
*** 在Windows中将参数序列转换为字符串

* sched
* queue
* 支持上面模块服务的底层模块
** dummy_threading
** _thread
** _dummy_thread
