# Author: Claudio <3261958605@qq.com>
# Created: 2017-06-02 11:40:31
# Commentary:
#+TITLE: 并发执行

[[file:~/Desktop/Python/resources/site/docs.python.org/3.5/library/concurrency.html][本地页面]]

本章介绍的模块可实现并发执行代码。是否选用并发执行取决于程序需求，榨干
CPU性能还是IO性能，协作多任务还是优先多任务。

* threading - 以线程为基础并发
  参考：

  1. [[http://yoyzhou.github.io/blog/2013/02/28/python-threads-synchronization-locks/][@yoyzhou（可能Event小节有bug，去掉sleep(...)可发现）]]
  2. [[http://www.cnblogs.com/huxi/archive/2010/06/26/1765808.html][@AstralWind]]
  3. [[http://www.ywlib.com/archives/19.html][@一闻自习室]]

  threading模块主要用来同时运行I/O操作频繁的任务，如需利用多核CPU，可
  参考multiprocessing模块。

  本模块建立在底层_thread模块上，提供操作线程的高阶接口。还可参见queue
  模块。

  如果缺少_thread模块，则不能使用threading模块，此时可使用
  dummy_threading模块作为替代品。

** 模块函数
*** threading. *active_count* ()
    当前存活的Thread对象数量，等于threading.enumerate()调用结果的长度。

    #+BEGIN_SRC python :session
      import threading
      print('当前Thread对象数量：', threading.active_count())
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> 当前Thread对象数量： 1
    #+END_SRC

*** threading. *current_thread* ()
    返回当前Thread对象，与控制调用环境的线程相关。如果调用函数在不为通过
    threading模块创建，则返回功能优先的“虚假”线程对象。？？？
*** threading. *get_ident* ()
    返回当前线程的“身份”，为非0整数。此数值并没有直接的实际含义，主要
    用来作为一个“魔法cookie”。比如用来索引线程相关的字典。当线程退出，
    另一个线程创建时，线程“身份”可能被垃圾回收，并被重新使用。

    #+BEGIN_SRC python :session
      import threading
      print(threading.current_thread())
      print(threading.get_ident())
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - <_MainThread(MainThread, started 140373658789632)>
    - 140373658789632
    #+END_SRC

*** threading. *enumerate* ()
    返回当前所有存活线程注册的链表。

    包含：后台线程（daemonic threads）、current_thread()创建的“虚假”线
    程（dummy thread）、以及主线程。

    不包括：已经被终止的线程，还没开始执行的线程。

*** threading. *main_thread* ()
    返回主线程Thread对象。普通情况下，当Python解释器开启时就启动主线程。

*** threading. *settrace* (func) ？？？
    为所有threading模块创建的线程添加跟踪函数（“trace function”）。在
    执行run()方法前，FUNC参数会传递给sys.settrace()函数。

*** threading. *setprofile* (func) ？？？
    为所有threading模块创建的线程添加profile函数。在执行run()方法前，
    FUNC参数会传递给sys.setprofile()函数。

*** threading. *stack_size* ([size]) ？？？
    返回创建新线程时，线程使用的stack大小。
    
    size：可选参数，指定以后创建线程时分配的stack大小。默认为0，即使用
    系统默认配置。如果设置，则需为>=32,768（32KiB）。如果不支持设置，
    则抛出RuntimeError错误；如果数值无效，则抛出ValueError错误，不做修
    改。目前支持的最小stack为32KiB。

    设置时，对系统有依赖。（待续）

** 模块常量
*** threading. *TIMEOUT_MAX*
    本模块中函数/构造器TIMEOUT参数允许的最大值，如Lock.acquire()、
    Rlock.acquire()和Condition.wait()等。如果超过此值，则抛出
    OverflowError错误。

    #+BEGIN_SRC python :session
      import threading
      threading.TIMEOUT_MAX
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - 9223372036.0
    #+END_SRC

** 线程本地变量 ？？？
   线程本地变量，其值只在线程中有效。使用threading.local（或子类），可
   创建线程本地变量。

   #+BEGIN_EXAMPLE python
     mydata = threading.local()
     mydata.x = 1
   #+END_EXAMPLE

   实例的值在不同线程中相互独立。

*** class threading. *local*
    表示线程本地变量数据的类。

    具体用法可参考_threading_local模块的文档。

** Thread对象
   Thread类表示独立允许的线程活动。有两种办法创建线程：

   1. 在构造器中传递可调用对象。
   2. 使用子类，重置run()方法。

      *声明Thread子类时，只能重置__init__()和run()方法。*

   当创建Thread对象后，只有调用其start()方法才能激活线程。激活后在独立
   的线程中运行run()方法。

   当线程启动后，则表示线程“存活”。当run()方法执行结束——正常结束或抛出
   错误没被处理，则线程“终止”。可使用is_alive()方法判断线程使用“存活”。

   线程可调用join()方法，调用后，直到调用join()方法的线程的join()方法
   执行结束后，才会执行当前线程中的代码。

   Thread对象具有name属性，可在构造器中指定，此属性可写。

   当线程声明为“后台线程”时，即声明构造器的daemon参数为True，如果主线
   程退出时，“后台线程”还没执行完，也会随之退出。可通过修改Thread对象
   的daemon属性，或在构造器中声明。是否为“后台线程”，默认继承于创建它
   的线程。 *声明daemon=True的线程，不能调用join()方法。*

   #+BEGIN_SRC python :session
     import threading as td
     import time

     def job():
         time.sleep(0.1)
         print('执行子线程函数。')

     def multi_thread():
         threads = []
         for i in range(10):
             t = td.Thread(target=job, daemon=True)
             t.start()

     multi_thread()
     print('主线程执行结束')
   #+END_SRC

   #+RESULTS:
   #+BEGIN_SRC org
   - >>> >>> ... ... ... >>> ... ... ... ... ... >>> >>> 主线程执行结束
   #+END_SRC

   #+BEGIN_QUOTE
   *注意* ： “后台线程”退出可能非常“唐突”，如不能合理释放资源（如已打
   开文件和数据库事务）。如需优雅退出“后台线程”，可使其“非后台化”，并
   使用合适的信号机制，如后面介绍的threading.Event对象。
   #+END_QUOTE

   总是有一个“主线程”，即控制Python程序的初始线程，从不为“后台线程”。

   有可能会自动创建“虚拟线程对象（dummy thread objects）”。他们为“外部
   线程（alien threads）”，在threading模块外创建，如直接从C代码创建。
   “虚拟线程”功能有限，且总是“存活”，并且为“后台线程”，不能调用join()
   方法，不能被删除。

*** class threading. *Thread* (group=None,target=None,name=None,args=(),kwargs={},*,daemon=None)

    *使用此构造器时，只能使用关键字参数。* 各参数的含义为：

    group：需为None，为以后支持ThreadGroup实现扩展预留的参数。

    target：可调用对象，被run()方法激活。默认为None，即不进行任何调用。

    name：线程名称。构造时默认创建"Thread-N"，其中N为十进制数。

    args：target指定可调用对象的参数，默认为()，如果为单元素元组，须为
    (arg0,)形式。

    kwargs：字典对象，target指定可调用对象的关键字参数，默认为{}。

    daemon：明确声明新建线程是否为“后台线程”。如果为None（默认值），
    则根据创建线程的线程是否为“后台线程”而定。

    *如果子类重载此构造器，则需保证在__init__()声明中，做任何事前声明
    Thread.__init__()。*

**** start()
     激活线程。

     只能调用一次。目的时将Thread对象的run()方法放置在新建的线程中执行。

     如果调用多次，则抛出RuntimeError错误。

**** run()
     表示线程活动的方法。

     可在子类中重置此方法；标准的run()方法会调用构造器中target参数指定
     的可调用对象，并让其调用args和kwargs指定的参数。

**** join(timeout=None)
     等待直到线程执行结束。使所在线程中的代码，直到该线程的join()方法
     调用终止（正常结束、抛出错误不被处理、超过timeout指定时间）后才执
     行。

     timeout：如果不为None，须为指定秒数的浮点数。由于join()方法总是返
     回None，所以如果使用timeout参数，需使用is_alive()方法判断子线程是
     否依然“存活”，再决定是否重新调用join()方法。

     当timeout参数为None或缺省时，所有代码会被阻塞至子线程执行结束后才
     执行。

     一个线程对象可调用多次join()方法。

     如果对可能造成“锁死”的线程对象调用join()方法，会抛出RuntimeError
     错误。如果在调用start()方法前调用join()方法，也会抛出RuntimeError
     错误。

     #+BEGIN_SRC python :session
       import threading as td
       import time

       def job():
           time.sleep(2)
           print('子线程执行结束。')

       def multi_thread():
           t1 = td.Thread(target=job)
           t1.start()
           t1.join(1)
           print('子线程是否存活：', t1.is_alive())
           if t1.is_alive():
               t1.join()

       multi_thread()
       print('主线程执行结束')
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC org
     - >>> >>> ... ... ... >>> ... ... ... ... ... ... ... >>> 子线程是否存活： True
     - 子线程执行结束。
     - 主线程执行结束
     #+END_SRC

**** name
     用来辨别线程的字符串，没有实际含义。多个线程可有相同名字。初始名
     字由构造器自动生成。
**** getName()
**** setName()
     name属性的旧API。
**** ident
     “线程身份”，如果线程还没启动则为None，如果已启动则为非0整数。当一
     个线程退出，另一个线程启动时，此“身份”可能被重新利用。即使线程退
     出后，也可获取。

**** is_alive()
     如果线程为“存活”状态，则返回True。

     在run()方法开始执行前，run()方法结束前，都返回True。模块函数
     enumerate()返回内容只含当前“存活”线程。

**** daemon
     表示是否为“后台线程”的布尔值。如果赋值，则需在调用start()方法前，
     否则抛出RuntimeError错误。默认继承于创建该线程是否为“后台线程”，
     主线程不为“后台线程”，所以在主线程中创建的线程默认daemon=False。

     当没有非“后台线程”存活时，整个Python程序退出。

**** isDeamon()
**** setDaemon()
     daemon属性的旧API。

** Lock对象

   #+BEGIN_QUOTE
   [[http://www.cszhi.com/20130528/python-threading.html][@cszhi]] ：使用“互斥锁”可保护多个线程访问的公共资源，使各线程不抢夺。
   #+END_QUOTE

   一个原始的lock为一个同步原始，当锁定后，不属于任何一个特点线程。在
   Python中，此类型为目前最底层的同步原始，由_thread扩展模块直接实
   现。？？？

   一个原始lock有两种状态：“locked（锁定）”和“unlocked（去锁定）”。有
   两个基本方法：acquire()和release()。当“去锁定”后，使用acquire()可将
   状态改变为“锁定”状态，并立即返回。当“锁定”后，acquire()会使当前线程
   一直阻塞，直到另一个线程中调用release()方法，将其“解锁”，然后可重新
   调用acquire()将其“锁定”并返回。release()方法只能在“锁定”状态下调用，
   否则抛出RuntimeError错误。

   支持上下文管理器协议。

   当在多个线程中调用acquire()锁定线程后，再调用release()方法时只能解
   锁一个线程；具体解锁哪一个根据Python实现不定。

*** class threading. *Lock*
    实现原始lock对象的类。当对某个线程锁定后，直到调用release()才释放
    （任何线程可操作此释放行为）。

**** acquire(blocking=True,timeout=-1)
     获取锁，阻塞或非阻塞。

     当blocking参数设置为True时（默认），阻塞直到解锁，然后设置为“锁定”状
     态返回True。？？？

     当blocking参数为False时，不阻塞。？？？

     当使timeout参数为浮点数正数时，阻塞对多timeout指定的秒数，期间不
     能获取“锁”。如果timeout参数为-1，表示无限期等待。当bloking参数为
     False时，不得指定timeout参数。

     如果成功获取“锁”，返回True，否则返回False（如超过timeout指定时间）。

**** release()
     释放“锁”，可在任何线程中调用，不必是获取“锁”的那个线程。

     当“锁”被锁定时，将其解锁。如果多个线程正阻塞等待解锁，只能解锁其
     中一个。

     当在没锁定的“锁”上调用时，抛出RuntimeError错误。

     无返回值。

** Rlock对象

   #+BEGIN_QUOTE
   [[http://python.jobbole.com/81546/][@伯乐在线]] Rlock与lock的主要区别为：Rlock允许在同一线程中多次被
   acquire()，Lock则不允许。使用Rlock时，acquire()和release()应成对出
   现，才能释放所有“锁”。
   #+END_QUOTE

   可重入锁，“同步基础（synchronization primitive）”，可被单个线程获取
   多次。使用“拥有者线程”和“递归层级”的概念，以及lock的锁定/解锁状态。
   在锁定状态下，一些线程拥有锁；在解锁状态下，没有线程拥有锁。

   如需锁定锁，线程可调用acquire()方法，当线程拥有锁后就返回。如需解锁
   锁，线程可调用release()方法。acquire()/release()调用对可嵌套，最外
   层release()可将锁设置为解锁状态，使其线程可调用acquire()获取锁。

   可重入锁支持上下文管理协议。

*** class threading. *Rlock*
    实现可重入锁对象的类。可重入锁可被获取他的线程释放。当某个线程获取
    一个可重入锁后，同一个线程可在不阻塞的情况下再次获取，且该线程需在
    每次获取后将其释放。

    Rlock实际上为工厂函数，返回当前平台上效率最高的具体Rlock类（返回实
    例）。

**** acquire(blocking=True,timeout=-1) ？？？
     获取锁，阻塞或非阻塞。

     当不带任何参数时：如果当前线程已经拥有锁，则增加一个递归层级，立
     即返回；如果锁被另一个线程拥有，阻塞直到该锁被释放。一旦锁被释放
     （不被另一个线程拥有），立即获得所有权，增加一个递归层级并返回。
     如果有多个线程等待锁被释放，则每次释放后只有一个线程能够获取锁，
     无返回值。

     当blocking参数为True时（默认），与不带参数时相同，并返回True。

     当blocking参数为False时，不阻塞。但如果调用后造成阻塞，则立即返回
     False；否则与不带任何参数相同，并返回True。

     如果指定表示秒数的浮点数参数timeout，则阻塞最多timeout指定时长，
     期间其他线程不能获取锁。如果成功获取锁，返回True，如果超过timeout
     时长，则返回False。

**** release()
     释放锁，将递归层级减少一层。如果减少至0，则此时锁不被锁定（不被任
     何线程拥有），如果任何其他线程线程正被阻塞等待解锁，则只允许其中
     一个获取锁。如果减少后还不为0，则锁保持锁定，并且调用此方法的线程
     所有。

     只有在拥有锁的线程中才能调用。当锁没被锁定时调用此方法抛出
     RuntimeError错误。

     无返回值。
** Condition对象
*** class threading. *Condition* (lock=none)
    实现条件变量对象的类。一个条件变量可使一个或多个线程等待，直到接到
    另一个线程的通知。

    如果lock参数不为None，则需为Lock或Rlock对象，用作底层的锁。否则自
    动创建Rlock对象作为底层锁。

**** acquire(*args)
     获取锁。此方法调用底层锁的acquire()方法，返回该方法的返回值。
**** release()
     释放锁。此方法调用底层锁的release()方法，无返回值。

**** wait(timeout=None)
     等待（阻塞）直到接到通知或超过timeout直到时间。如果在没有获取锁的
     线程中调用，抛出RuntimeError错误。

     此方法释放底层锁，然后阻塞直到被同一条件变量，在另一个线程中调用
     notify()或notify_all()方法唤醒，或超过timeout时长。一旦唤醒或超过
     timeout时长，重新获得锁并返回。

     timeout参数需为指定秒数的浮点数。

     当底层锁为Rlock对象时，释放锁时，并不是使用Condition对象自身的
     release()方法，因为如果被多次递归获取，没有办法释放锁。实际上，使
     用Rlock对象的release()方法。这样，即时锁被多次递归获取，也可释放。
     重新获取锁时，再使用Rlock的接口恢复。

     除非指定timeout参数并超时，此方法始终返回True。

**** wait_for(predicate,timeout=None)
     等待直到predicate可调用对象返回True。可指定timeout参数限定等待时
     长。

     相当于重复调用wait()直到predicte返回值为True，或超时。返回值为最
     后一次调用predicate的返回值，如果超时返回False。

     如果忽视timeout参数功能，此方法大致等价于：

     #+BEGIN_EXAMPLE python
       while not predicate():
             cv.wait()
     #+END_EXAMPLE

     所以，与wait()的规则相同：当调用此方法时，必须拥有锁，然后返回后
     在重新获取锁。predicate在拥有锁时执行。

**** notify(n=1)
     默认情况下，唤醒使用相同条件变量等待的线程。如果调用线程当时不拥
     有锁，则抛出RuntimeError错误。

     此方法可唤醒使用相同条件变量等待的最多n个线程；如果没有线程处于等
     待状态，相当于“空操作”。

     目前的实现中，如果至少有n个线程正在等待，则会准确唤醒n个线程。然
     而，依赖此特性并不安全。以后的实现可能会唤醒多于n个的线程。

     #+BEGIN_QUOTE
     *注意* ： 直到可重新获取锁前，被唤醒的线程并不是真正从Condition对
     象的wait()方法返回。因为notify()并没有释放锁，而是调用线程。
     #+END_QUOTE

**** notify_all()
     唤醒所有使用该条件变量等待的线程。类似于notify()方法，不过是将所
     有等待的线程唤醒。如果调用线程当时不拥有锁，则抛出RuntimeError错
     误。

** Semaphore（信号量）对象
   计算机科学中最早的同步原始之一。

   信号量管理一个内部计数器，调用acquire()方法后减一，调用release()方
   法后加一。由于计数器永远不会小于0，所以当调用acquire()时，如果发现
   计数器值为0，则等待直到其他线程调用release()方法。

   支持with上下文管理器。

*** class threading. *Semaphore* (value=1)
    实现信号量对象的类。管理一个内部计数器。

    value：内部计数器的初始值，默认为1，如果指定值小于0，则抛出
    ValueError错误。

**** acquire(blocking=True,timeout=None)
     获取信号量。

     当不带参数时：如果内部计数器大于0，则将计数器减一并立即返回。如果
     为0，则阻塞直到其他线程调用release()方法将计数器调用加一。如果多
     次调用acquire()后阻塞，调用一次release()只能唤醒单个，且内部实现
     随机选择。如果不阻塞则返回True。

     blocking为False时：不阻塞，房blocking为True时如果阻塞则返回False；
     否则与不带任何参数相同。

     timeout不为None时：阻塞最多指定秒数。如果不带参数不会阻塞，则返回
     True，如果在指定时间内不能获取则返回False。

**** release()
     释放信号量，将内部计数器增加1。如果当前计数器为0，且其他线程正等
     待，则唤醒其中一个等待的线程。

*** class threading. *BoundedSemaphore* (value=1)
    实现“有限信号量”（Bounded Semaphore）的类。与Semaphore不同之处为：
    当调用release()方法将内部计数器加一后，如果超过value参数指定的初始
    值，则抛出ValueError错误。

*** Semaphore举例
    信号量常用于守护能力有限的资源访问，如数据库服务器。在任何资源大小
    固定的情况下，需使用“有限信号量”。在启动任何工作线程前，需在主线程
    中初始化信号量。

    #+BEGIN_EXAMPLE python
      max_connections = 5
      # ...
      pool_sema = BoundedSemaphore(value=max_connections)
    #+END_EXAMPLE

    一旦启动，工作线程如需访问数据库服务器，可调用信号量对象的
    release()和acquire()方法。

    #+BEGIN_EXAMPLE python
      with pool_sema:
           conn = connectdb()
           try:
              # ... 使用数据库连接
           finally:
              conn.close()
    #+END_EXAMPLE

    使用“有限信号量”，可防止无意间release()调用次数超过acquire()调用次
    数的情况。

** Event对象
   进程间最简单的交流机制：一个线程设置时间信号，其他线程等待该信号。

*** class threading. *Event*
    实现Event实例的类。

    一个Event对象管理内部的flag，此flag可调用set()方法设置为True，使用
    clear()方法设置为False。调用wait()方法会阻塞至此flag值为True为止。
    flag初始值为False。

**** is_set()
     当且仅当flag为True时返回True。
**** set()
     设置flag为True，在调用wait()方法的线程中，当flag为True时不再阻塞。

**** clear()
     设置flag为False，在调用wait()方法的线程中，直到再次调用set()方法
     前会一直阻塞。

**** wait(timeout=None)
     在线程中调用后，阻塞直到flag为True。如果本来就为True，则立即返回。
     否则阻塞直到另一个线程调用set()方法将flag设置为True，或阻塞超过
     timeout指定秒数。

     如果设置timeout参数，须为指定秒数的浮点数。

     不管在阻塞前还是阻塞后，只要flag为True，则此方法返回True。所以如
     果没有指定timeout参数，此方法始终返回True。

** Timer对象
   直到经过指定时长时才执行。Timer为Thread子类，所以也相当于创建一个线
   程。

   与Thread()实例相同，也是调用start()方法激活线程。可在等待过程中，调
   用cancel()方法停止。 *实际等待时长可能不与指定时长完全相等。*

   比如：

   #+BEGIN_EXAMPLE python
     from threading import Timer

     def hello():
         print('hello, world')

     t = Timer(2, hello)
     t.start()
   #+END_EXAMPLE

*** class threading. *Timer* (interval,function,args=None,kwargs=None)
    创建一个计时器，在interval时长后执行function函数，函数参数args和
    kwargs参数执行。args和kwargs参数的默认值分别为空链表和空字典。

**** cancel()
     停止计时器，取消将执行的函数。仅在等待过程中有效。

** Barrier对象
   为多个需互相等待的线程提供同步原始。没个需互相等待的线程中调用
   wait()方法，阻塞直到调用次数达到指定个数，此时所有线程同步释放。

   对于相同数量的线程，Barrier对象可重复使用。

   如下面同步启动客户端和服务器的例子：

   #+BEGIN_SRC python :session
     import time
     from threading import Barrier, Thread

     b = Barrier(2)

     def server():
         b.wait()
         print('server启动')

     def client():
         b.wait()
         print('client启动')

     server_td = Thread(target=server)
     client_td = Thread(target=client)

     server_td.start()
     time.sleep(0.1)
     print('客户端启动启动前')
     client_td.start()
   #+END_SRC

   #+RESULTS:
   #+BEGIN_SRC org
   - >>> >>> >>> >>> >>> ... ... ... >>> >>> ... ... ... >>> >>> >>> >>> >>> >>> >>> 客户端启动启动前
   - client启动
   - server启动
   #+END_SRC

*** class threading. *Barrier* (parties,action=None,timeout=None)
    创建Barrier对象，使用parties参数指定等待线程个数。

    action：可调用对象（默认为None），当所有等待线程同步释放时，由其中
    一个调用。

    timeout：如果wait()方法中的timeout参数为None，则使用此参数值作为默
    认值。

**** wait(timeout=None)
     在需等待的线程中调用。当调用此方法的线程个数达到parties参数指定个
     数时，这些线程同步释放。

     timeout：当提供时，覆盖构造器的timeout参数。

     返回值为0到parties-1间的整数，表示还有多少个线程需调用此方法才能
     同步释放。可用于在指定线程中执行特殊行为：

     #+BEGIN_EXAMPLE python
       i = barrier.wait()
       if i == 0:
          # 只需最后一个线程执行的内容->
          print('这是最后一个需等待的线程')
     #+END_EXAMPLE

     如果构造器中指定action参数，则所有线程同步释放前其中一个会调用该
     参数值。如果此调用抛出错误，则Barrier对象被只有损坏状态。

     如果等待时长超过timeout指定时长，则Barrier对象被置于损坏状态。

     当有其他线程处理等待状态时，如果Barrier对象已损坏或被重置，调用此
     方法可能抛出BrokenBarrierError错误。

**** reset()
     将Barrier对象置于初始状态。任何正等待的线程将接受一个
     BrokenBarrierError错误抛出。

     Note that using this function may can require some external
     synchronization if there are other threads whose state is
     unknown. If a barrier is broken it may be better to just leave it
     and create a new one.

**** abort()
     将Barrier对象置于损坏状态。此后再调用wait()方法将失败，并抛出
     BrokenBarrierError错误。

     比如，如果其中一个线程需放弃执行，防止应用锁死。？？？

     更好的方法时在其中一个线程中调用wait()方法时指定timeout参数。？？？

**** parties
     总共需等待的线程个数。
**** n_waiting
     当前等待的线程个数。
**** broken
     如果为损坏状态，返回True。
*** exception threading. *BrokenBarrierError*
    RuntimeError子类，当Barrier对象重置或损坏时抛出。
** 在with上下文管理器中使用locks、conditions和semaphores
   本模块中只要有acquire()和release()方法的对象，都可用在with上下文管
   理器中。进入时执行release()，退出时执行release()。所以：

   #+BEGIN_EXAMPLE python
     with some_block:
          # do something...
   #+END_EXAMPLE

   等价于：

   #+BEGIN_EXAMPLE python
     some_lock.acuqire()
     try:
         # do something...
     finally:
         some_lock.release()
   #+END_EXAMPLE

   目前，实例支持上下文管理器的类有：Lock、Rlock、Condition、Semaphore
   和BoundedSemaphore。

* multiprocessing - 以进程为基础的并发
* concurrent包
* concurrent.future
* subprocess
  subprocess模块用于产生新进程，连接自己的输出/输入/错误流管道，并获取
  返回码。此模块旨在替换几个旧模块和函数：

  #+BEGIN_EXAMPLE python
    os.system
    os.spawn*
  #+END_EXAMPLE

** 使用subprocess模块
   如需激活子进程，建议尽量使用run()函数；如需更高阶定制，可直接使用底
   层的Popen接口。

   run()函数在Python3.5时才新增，如需向后兼容，参考后面的“旧高阶API”。

*** subprocess. *run* (args,*,stdin=None,input=None,stderr=None,shell=False,timeout=None,check=False)
    执行ARGS指定的命令，等待执行结束，返回CompleteProcess实例。

    参数使用方法参考后面的“常用参数”。用法基本上与Popen构造器的参数用
    法相同，timeout、input和check除外。实际上，本函数所有参数都传递给
    Popen接口。

    默认情况下，不会捕获标准输出和标准错误流。如需捕获，传递PIPI作为
    STDOUT/STDERR参数值。

    TIMEOUT参数实际上传递给Popen.communicate()函数。如果超时，子进程被
    干掉，然后等待。子进程被终止后，TimeExpired错误会重新抛出。

    INPUT参数也会传递给Popen.communicate()函数，作为子进程的标准输入流。
    如果使用，须为比特序列，或参数UNIVERSAL_NEWLINES=True的情况下可为
    字符串。使用后，内部的Popen对象会自动将STDIN参数设置为PIPE，就可能
    不使用本函数的STDIN参数。

    如果CHECK参数为true，且子进程返回码（exit code）不为0，则抛出
    CalledProcessError错误。如果捕获的stdout和stderr，从抛出Exception
    的属性可获取本函数参数，以及退出码等信息。

    举例：

    #+BEGIN_EXAMPLE sh
      >>> subprocess.run(['ls', '-l']) # 不捕获输出，只是打印
      total 0
      -rw-r--r-- 1 claudio claudio 0 Jun  3 15:53 text.txt
      CompletedProcess(args=['ls', '-l'], returncode=0)
      >>> subprocess.run('exit 1', shell=True)
      CompletedProcess(args='exit 1', returncode=1)
      >>> subprocess.run('exit 1', shell=True, check=True)
      Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
        File "/usr/lib/python3.5/subprocess.py", line 398, in run
        output=stdout, stderr=stderr)
      >>> subprocess.run(['ls', '-l', '/dev/null'], stdout=subprocess.PIPE) # 捕获输出
      CompletedProcess(args=['ls', '-l', '/dev/null'], returncode=0, stdout=b'crw-rw-rw- 1 root root 1, 3 Jun  2 10:27 /dev/null\n')
    #+END_EXAMPLE

*** class subprocess. *CompletedProcess*
    run()函数返回值，表示该子进程已经执行完成。有下面属性。

**** args
     传递给run()函数执行的命令，可能是字符串也可能为链表。

**** returncode
     子进程返回码，0表示子进程成功执行完成。

     POSIX中，如果为数值-N，表示子进程被信号N终止。

**** stdout
     从子进程标准输出流捕获的内容，一般为bytes对象，如果run()使用参数
     universal_newlines=True参数，则为字符串。

**** stderr
     从子进程标准错误流捕获的内容，一般为bytes对象，如果run()使用参数
     universal_newlines=True参数，则为字符串。
**** check_returncode()
     如果returncode不为0，抛出CalledProcessError错误，否则返回None。

*** subprocess. *DEVNULL*
    可用于Popen的STDIN、STDOUT和STDERR参数的特殊值，表示使用特殊文件
    os.devnull。

*** subprocess. *PIPE*
    可用于Popen的STDIN、STDOUT和STDERR参数的特殊值，表示对应标准流会打
    开一个管道。与Popen.communicate()一起使用更有用。

*** subprocess. *STDOUT*
    用于Popen的stderr参数的特殊值，当stderr=subprocess.STDOUT时，可将
    标准错误流重定向到标准输出流。

*** exception subprocess. *SubprocessError*
    本模块所有exception的基础类。

*** exception subprocess. *TimeoutExpired*
    SubprocessError的子类，当等待子进程超时时抛出。有如需属性：

    #+BEGIN_SRC python :session
      import subprocess
      import sys
      DECODING = sys.getdefaultencoding()
      try:
          subprocess.run(['ping', 'bing.com'], stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE, timeout=2)
      except subprocess.TimeoutExpired as time_why:
          print('cmd：', time_why.cmd)
          print('timeout：', time_why.timeout)
          print('output：', time_why.output.decode(DECODING))
          print('stdout：', time_why.stdout.decode(DECODING))
          print('stderr：', time_why.stderr.decode(DECODING))
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> >>> >>> ... ... ... ... ... ... ... ... ... cmd： ['ping', 'bing.com']
    - timeout： 2
    - output： PING bing.com (204.79.197.200) 56(84) bytes of data.
    - 64 bytes from bing.com (204.79.197.200): icmp_seq=2 ttl=116 time=49.1 ms
    - stdout： PING bing.com (204.79.197.200) 56(84) bytes of data.
    - 64 bytes from bing.com (204.79.197.200): icmp_seq=2 ttl=116 time=49.1 ms
    - stderr：
    #+END_SRC

**** cmd
     激活子进程的命令。
**** timeout
     超时时长秒数。
**** output
     子进程输出（如果被run()或check_output()捕获），否则为None。
**** stdout
     output的别名，为保证与stderr语义一致。
**** stderr
     子进程标准错误流（如果被run()捕获），否则为None。

*** exception subprocess. *CalledProcessError*
    SubprocessError子类，当进程被check_all()或check_ooutput()执行返回
    非0返回码时抛出。

    #+BEGIN_SRC python :session
      import subprocess

      try:
          proc = subprocess.run(
              ['ls', 'not-exists'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
      except subprocess.CalledProcessError as why:
          print('returncode：', why.returncode)
          print('cmd：', why.cmd)
          print('output：', why.output)
          print('stdout：', why.stdout)
          print('stderr：', why.stderr)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - >>> ... ... ... ... ... ... ... ... ... returncode： 2
    - cmd： ['ls', 'not-exists']
    - output： b''
    - stdout： b''
    - stderr： b"ls: cannot access 'not-exists': No such file or directory\n"
    #+END_SRC

**** returncode
     子进程返回码。如果子进程因信号退出，则为表示信号的负数。
**** cmd
     激活子进程的命令。

**** output
     子进程输出（如果被run()或check_output()捕获），否则为None。
**** stdout
     output的别名，为保证与stderr语义一致。
**** stderr
     子进程标准错误流（如果被run()捕获），否则为None。

*** 常用参数
    为支持不同的使用场景，Popen构造器和run()函数使用大量可选参数。大多
    数情况下，许多参数可省略使用默认值，常用的参数如下：

**** ARGS
     执行命令，可为字符，也可为命令和参数组成的序列（如链表）。首选序
     列，这样可方便处理命令参数的转义和添加引号（如允许命令参数为有空
     格的字符串）。如果为单个字符串，要么SHELL参数需为True，要么执行命
     令不得带任何参数。

**** STDIN、STDOUT和STDERR
     表示命令执行的标准输入流、输出流和错误流定向方式。可选值为
     subprocess.PIPE、subprocess.DEVNULL、已存在的文件描述符（正数）、
     已存在的文件对象或None。PIPE表示会为子进程打开一个管道。DEVNULL表
     示使用os.devnull文件。默认为None，表示不对标准流进行任何重定向。
     子进程文件处理继承于父进程。此外，STDERR可设置为subprocess.STDOUT，
     将标准错误流重定向到标准输出流。

**** UNIVERSAL_NEWLINES
     如果UNIVERSAL_NEWLINES为False，则stdin、stdout和stderr都使用二进
     制模式，不会自动转换换行符。

     如果UNIVERSAL_NEWLINES为True，则文件对象以文本模式打开，使用
     locale.getpreferredecodiong(False)编码和解码。对应stdin，换行符
     "\n"自动转换为os.linesep；对于stdout，所有输入的换行符都转换为
     "\n"。

     #+BEGIN_QUOTE
     *注意* ：Popen.communicate()不会自动更新Popen.stdin、Popen.stdout
     和Popen.stderr不会的换行符属性。
     #+END_QUOTE

**** SHELL
     当SHELL属性为，命令会在shell环境中执行。即可使用shell本身的特性，
     如管道、文件名通配符、环境变量扩张、家目录"~"扩张等特性。不过，
     Python已提供类似shell的特性，如glob、fnmath、os.path.expanduser()
     等。

     #+BEGIN_QUOTE
     *注意* ：参考后文“安全”小节有关shell=True时的说明。
     #+END_QUOTE

     下面为使用shell=True后使用家目录扩张的例子：

     #+BEGIN_EXAMPLE ipython
       In [60]: subprocess.run(['ls', '~'])
       ls: cannot access '~': No such file or directory
       Out[60]: CompletedProcess(args=['ls', '~'], returncode=2)

       In [61]: subprocess.run(['ls', '~'], shell=True)
       Backup    Documents  Music           Pictures   Templates  Videos
       bin        Downloads  myarchive.tar.gz  Public  test
       Desktop  dwhelper   PDF                               python    test.txt
       Out[61]: CompletedProcess(args=['ls', '~'], returncode=0)
     #+END_EXAMPLE

*** POPEN构造器
    本模块的底层使用Popen类实现，可利用此类更灵活定制run()等函数不能处
    理的情况。

**** class subprocess. *Popen* (args,bufsize=-1,executable=None,stdin=None,stdout=None,stderr=None,preexec_fn=None,close_fds=True,shell=False,cwd=None,env=None,universal_newline=False,startupinfo=None,creationflags=0,restore_signals=True,start_new_session=False,pass_fds=())
     在程序中执行新进程。在POSIX中，使用与os.execvp()类似方法执行子程
     序；Windows中，调用系统CreateProcess()函数。参数使用方法如下：

     - args：为序列或字符串。默认情况下，如果args为序列，则第一个元素
       为需执行的命令；如果为字符串，则依赖不同系统类型，可参考后面关
       于shell和executable参数的介绍。 *首选使用序列，而非字符串。*

       在POSIX中，如果args为字符串，会将字符串解释为可支持程序的路径，
       如"/bin/ls"。但不能更任何参数。

       #+BEGIN_SRC python :session
         import shlex
         import subprocess
         commad_line = '''/usr/bin/viking -input eggs.txt -output "spam spam.txt" -cmd "echo '$MONEY'"'''
         args = shlex.split(commad_line)
         print(args)
         p = subprocess.Popen(args)
       #+END_SRC

       #+RESULTS:
       #+BEGIN_SRC org
       - >>> >>> >>> ['/usr/bin/viking', '-input', 'eggs.txt', '-output', 'spam spam.txt', '-cmd', "echo '$MONEY'"]
       #+END_SRC

       在Windows中，如果args为序列，会转换为字符串，因为系统调用时使用
       的CreateProcess()函数接受字符串参数。

     - shell：默认为False，指定是否使用shell执行程序。如果为True，建议
       使用字符串对象作为args参数值。

       *不建议使用shell=True*

       在POSIX中，当shell=True时，默认使用/bin/sh。ARGS为字符串，将直
       接执行字符串指定的命令，即字符换需与在命令行中直接输入的一样，
       比如引号和转义文件名中的空格的斜杠；如果ARGS为序列，则第一个元
       素表示命令，其余元素表示该命令的参数，即等价于：

       #+BEGIN_EXAMPLE python
         Popen(['/bin/sh', '-c', args[0], args[1], ...])
       #+END_EXAMPLE

       Windows中：（待续）

     - bufsize：与open()函数的bufsize含义相同，用于创建
       stdin/stdout/stderr管道对象：

       - 0：表示不使用缓存。
       - 1：行缓存（仅在universal_newlines=True，如文本模式中有用）。
       - 任何其他正数：使用与该数值接近的缓存大小。
       - 负数（默认）：使用系统默认缓存大小：io.DEFAULT_BUFFER_SIZE。

     - executable：很少使用。当shell=False时，表示替换ARGS指定的命令。

     - stdin、stdout和stderr：见run()函数。

     - preexec_fn：可调用对象，在至今才执行前执行。仅在POSIX中有效。不
       安全。

     - close_fds：默认为True，表示当子进程执行完毕后，文件描述符0、1和
       2将关闭（只在POSIX中有效）。

     - pass_fds：

     - cwd：

     - restore_signals

     - start_new_session

     - env：指定执行子进程时环境变量的映射。默认为None，即使用当前进程
       的环境变量。

     - universal_newlines：当为True时，stdin、stdout和stderr都以文本模
       式打开。默认为False，即以二进制模式打开。

     - startupinfo

     Popen对象支持with上下文管理器，当exit时，标准文件描述符被关闭，进
     程被等待：

     #+BEGIN_EXAMPLE python
       with Popen(['ifconfig'], stdout=PIPE) as proc:
            log.write(proc.stdout.read())
     #+END_EXAMPLE

*** Exceptions
    当新进程开始执行后，抛出的所有错误会被父进程重新抛出。此外，抛出的
    错误有child_traceback属性，为子进程traceback信息的字符串（？？？怎
    么查看）。

    最常见的错误为OSError，比如尝试执行不存在的命令。如果要处理抛出错
    误，需将其包含在内：

    #+BEGIN_EXAMPLE python
      try:
          subprocess.run(['ls', 'qwd'], stderr=subprocess.PIPE, check=True)
      except subprocess.CalledProcessError as proc_why:
          pass
      except OSError as os_why:
          print(os_why)
    #+END_EXAMPLE

    当在Popen中使用无效参数时，会抛出ValueError错误。

    当调用check_all()和check_output()的返回码不为0时，会抛出
    CalledProcessError。

    本模块中所有函数和方法都接受timeout参数，如call()和
    Popen.communicate()，当超时时，会抛出TimeExpired错误。

    本模块中所有错误都继承于SubprocessError。

** 安全
   使用本模块中的函数时，所有字符，包括shell元字符都可安全传入子进程。
   但当shell=True时，需保证为空格和元字符添加引号，避免 [[https://en.wikipedia.org/wiki/Code_injection#Shell_injection][shell注入]] 。

   避免使用shell=True，当使用时，使用shlex.quote()转义命令，转义空格和
   shell元字符。

** Popen对象
   Popen实例有以下方法和属性：

*** Pope. *poll* ()
    检查子进程是否终止。设置和返回returncode属性。？？？

    #+BEGIN_SRC python :session
      from subprocess import Popen
      with Popen(['ls']) as proc:
          print(proc.poll())
          proc.kill()
    #+END_SRC

*** Pope. *wait* (timeout=None)
    等待子进程终止。设置和返回returncode属性。

    如果进程在TIMEOUT参数指定的秒数内没有终止，抛出TimeoutExpired错误。
    可安全捕获此错误，然后在使用wait()方法。

    #+BEGIN_QUOTE
    *注意* ：当使用stdout=PIPE或stderr=PIPE，且子进程想管道输出内容过
    多，导致阻塞操作心态管道接受更多数据时，会造成“锁死”。使用
    Popen.communicate可避免此情况发生。？？？
    #+END_QUOTE

    #+BEGIN_QUOTE
    *注意* ：此函数使用非阻塞调用和短休眠。如需使用同步等待，可参考
    asyncio.create_subprocess_exec。
    #+END_QUOTE

*** Pope. *communicate* (input=None,timeout=None)
    与子进程交流：向stdin发送数据。从stdout和stderr读取数据，直到遇到
    EOF。等待子进程结束。

    返回值为(stdout_data, stderr_data)组成的元组，都为bytes对象。如果
    universal_newlines参数为True，则为字符串。

    input：可选参数，为向子进程发送的数据，如果为None则不发送数据。须
    为bytes对象，如果universal_newlines为True，则为字符串。

    如需指定input参数，向stdin发送数据，则创建Popen实例时，需声明
    stdin=PIPE；同样，如需从返回元组中获取数据，则需声明stdout=PIPE和
    stderr=PIPE，否则只能获取None。

    timeout：如果子进程在TIMEOUT参数指定的时间内为终止，则抛出
    TimeoutExpired错误。捕获此错误，再重新使用communicate()方法不会丢
    失任何输出数据。

    如果抛出TimeoutExpired错误后子进程还没被干掉，需手动干掉，再接受
    communicate()操作：

    #+BEGIN_EXAMPLE python
      proc = subprocess.Popen(...)
      try:
          outs, errs = proc.communicate(timeout=15)
      except TimeoutExpired:
             proc.kill()
             outs, errs = proc.communicate()
    #+END_EXAMPLE

    #+BEGIN_QUOTE
    *注意* ：此方法读取的数据会存储在内存中，所以当数据量大或无限时，
    不要使用此方法。
    #+END_QUOTE

*** Pope. *send_signal* (signal)
    向子进程发生SIGNAL信号。
*** Pope. *terminate* ()
    停止子进程。在POSIX中为发送SIGTERM，在Windows中，则是调用Win32 API
    的TerminateProcess()函数。

*** Pope. *kill* ()
    干掉子进程。在POSIX中为发送SIGKILL信号，在Windows中等价于terminate()。
*** Pope. *args*
    传入Popen的ARGS参数，为序列或字符串。
*** Pope. *stdin*
    如果stdin参数为PIPE，则此属性为可写流对象（与open()函数返回值相同）。
    如果universal_newlines参数为True，则为文本流，否则为二进制流。

    如果stdin参数为None，则此属性值也为None。

    #+BEGIN_SRC python :session
      from subprocess import *
      with Popen(['cat'], stdout=PIPE, stdin=PIPE) as proc:
          proc.stdin.write(b'123')
          print(proc.communicate())
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - ... ... ... 3
    - (b'123', None)
    #+END_SRC

*** Pope. *stdout*
    如果stdout参数为PIPE，则此属性为可读流对象（与open()函数返回值相
    同）。读取此流对象的返回值为子进程的输出值。如果universal_newlines
    参数为True，则为你文本流，否则为二进制流。

    如果stdout参数为None，则此属性值也为None。

*** Pope. *stderr*
    如果stderr参数为PIPE，则此属性为可读流对象（与open()函数返回值相
    同）。读取此流对象的返回值为子进程的输出值。如果universal_newlines
    参数为True，则为你文本流，否则为二进制流。

    如果stderr参数为None，则此属性值也为None。

    #+BEGIN_QUOTE
    *警告* ：避免OS的管道被填满，造成阻塞子进程，进而“锁死”，应使用
    communicate()，而非.stdin.write、stdout.read或stderr.read。
    #+END_QUOTE

*** Pope. *pid*
    返回子进程ID，如果shell=True，则是shell进程的ID。

*** Pope. *returncode*
    子进程返回码，由poll()和wait()设置（间接由communicate()设置）。

    None表示进程还没终止。

    负数-N，表示进程被信号N终止，（仅POSIX有效）。

** Windows Popen帮助 （待续）
*** 常量
** 旧的高阶API
   Python3.5前，下面3个函数旧API函数。现在可使用run()替换，但很多现有
   的代码都使用他们。

*** subprocess. *call* (args,*,stdin=None,stdout=None,stderr=None,shell=False,timeout=None)
    执行ARGS指定的命令，等待执行结束，返回returncode属性。

    除不支持input和check参数外，等价于：

    #+BEGIN_EXAMPLE python
      run(...).returncode
    #+END_EXAMPLE

    除TIMEOUT参数外，此函数的所有参数都传递给Popen接口。

    #+BEGIN_QUOTE
    *注意* ： 不要使用stdout=PIPE或stderr=PIPE。当OS管道没有被读取，且
    此函数产生的数据填满管道后，会造成阻塞。
    #+END_QUOTE

*** subprocess. *check_all* (args,*,stdin=None,stdout=None,stderr=None,shell=False,timeout=None)
    执行ARGS指定的命令，等待命令完成。如果返回码为0，返回，否则抛出
    CalledProcessError错误。可从CalledProcessError中获取returncode属性。

    除不支持input参数外，等价于：

    #+BEGIN_EXAMPLE python
      run(..., check=True)
    #+END_EXAMPLE

    除TIMEOUT参数外，此函数的所有参数都传递给Popen接口。

    #+BEGIN_QUOTE
    *注意* ： 不要使用stdout=PIPE或stderr=PIPE。当OS管道没有被读取，且
    此函数产生的数据填满管道后，会造成阻塞。
    #+END_QUOTE

*** subprocess. *check_output* (args,*,stdin=None,stdout=None,stderr=None,shell=False,timeout=None)
    执行命令，返回执行输出。

    如果返回码不为0，则抛出CalledProcessError。可通过
    CalledProcessError的returncode和output属性分别获取返回码和输出内容。

    除不支持input参数外，大多数参数都传递给run()函数的接口。等价于：

    #+BEGIN_EXAMPLE python
      run(..., check=True, stdout=PIPE).stdout
    #+END_EXAMPLE

    返回结果为bytes对象，编码形式依赖于命令执行环境。所以应该在应用层
    级上解码。？？？

    设置universal_newlines=True后，可使返回字符串。

    如需捕获stderr，可声明参数stderr=subprocess.STDOUT：

    #+BEGIN_SRC python :session
      import subprocess
      subprocess.check_output(
          'ls none_exists_file; exit 0',
          stderr=subprocess.STDOUT,
          shell=True)
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC org
    - ... ... ... b"ls: cannot access 'none_exists_file': No such file or directory\n"
    #+END_SRC

** 使用subprocess模块替换旧函数

   #+BEGIN_QUOTE
   *注意* ： 本节中所有被替换的函数如果不能找到执行命令，都不会抛出错
   误；而替换函数会抛出OSError错误。

   此外，使用check_output()替换的版本中，如果执行返回码不为0，会抛出
   CalledProcessError错误，可使用output属性获取具体内容。
   #+END_QUOTE

*** 替换/bin/sh的反引号

    #+BEGIN_EXAMPLE sh
      output=`mycmd myarg`
    #+END_EXAMPLE

    可替换为：

    #+BEGIN_EXAMPLE python
      output = check_output(['mycmd', 'myarg'])
    #+END_EXAMPLE

*** 替换管道

    #+BEGIN_EXAMPLE sh
      oputput=`dmesg | grep hda`
    #+END_EXAMPLE

    可替换为：

    #+BEGIN_EXAMPLE python
      p1 = Popen(['dmesg'], stdout=PIPE)
      p2 = Popen(['grep', 'hda'], stdin=p1.stdout, stdout=PIPE)
      p1.stdout.close() # 保证p1在p2退出时接受SIGPIPE信号
      output=p2.communicate()[0]
    #+END_EXAMPLE

    如果输如可信任，可直接使用shell的管道：

    #+BEGIN_EXAMPLE python
      output = check_output('dmesg | grep hda', shell=True)
    #+END_EXAMPLE

*** 替换os.system()函数

    #+BEGIN_EXAMPLE python
      sts = os.system('mycmd' + ' myarg')
      # 替换为
      sts = call('mycmd' + ' myarg', shell=True)
    #+END_EXAMPLE

    更实际的例子为：

    #+BEGIN_EXAMPLE python
      try:
          retcode = call('mycmd', + ' myarg', shell=True)
          if rtcode < 0:
             print('子进程被信号中断', -rtcode, file=sys.stderr)
          else:
             print('子进程返回', rtcode, file=sys.stderr)
      except OSError as e:
          print('执行失败：', e, file=sys.stderr)
    #+END_EXAMPLE

*** 替换os.spawn类函数 （待续）
*** 替换os.popen()、os.popen2()和os.popen3() （待续）
*** 替换popen2模块的函数 （待续）
** 遗留Shell激活函数 （存在于2.x中，可能不安全，待续）
** 注意点 （待续）
*** 在Windows中将参数序列转换为字符串

* sched
* queue
* 支持上面模块服务的底层模块
** dummy_threading
** _thread
** _dummy_thread
